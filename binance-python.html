<documents>
<document index="1">
<source>.github/CODEOWNERS</source>
<document_content>
* @carlosmiei

</document_content>
</document>
<document index="2">
<source>.github/ISSUE_TEMPLATE/bug_report.md</source>
<document_content>
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Code snippet to reproduce the behavior:

**Expected behavior**
A clear and concise description of what you expected to happen.

**Environment (please complete the following information):**
 - Python version: [e.g. 3.5]
 - Virtual Env: [e.g. virtualenv, conda]
 - OS: [e.g. Mac, Ubuntu]
 - python-binance version

**Logs**
Please set logging to debug and paste any logs here, or upload `debug.log` file to the issue.
```python
import logging
# This will log to both console and file
logging.basicConfig(level=logging.DEBUG,format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
handlers=[
logging.FileHandler('debug.log'),
logging.StreamHandler()
]
)
```

**Additional context**
Add any other context about the problem here.

</document_content>
</document>
<document index="3">
<source>.github/workflows/python-app.yml</source>
<document_content>
# This workflow will install Python dependencies, run tests and lint with a single version of Python
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-python

name: Python application

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

permissions:
  contents: read

jobs:
  lint:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
    - uses: actions/checkout@v5
    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: '3.9'
    - name: Install Ruff
      run: pip install ruff
    - name: Lint code with Ruff
      run: ruff check --output-format=github --target-version=py39 .
    - name: Check code formatting with Ruff
      run: ruff format --check .
      continue-on-error: true

  test:
    needs: lint
    runs-on: ubuntu-22.04
    timeout-minutes: 40
    strategy:
      max-parallel: 2
      matrix:
        python-version: ['3.8', '3.9', '3.10', '3.11', '3.12']
    env:
      PROXY: "http://188.245.226.105:8911"
      TEST_TESTNET: "true"
      TEST_API_KEY: "u4L8MG2DbshTfTzkx2Xm7NfsHHigvafxeC29HrExEmah1P8JhxXkoOu6KntLICUc"
      TEST_API_SECRET: "hBZEqhZUUS6YZkk7AIckjJ3iLjrgEFr5CRtFPp5gjzkrHKKC9DAv4OH25PlT6yq5"
      TEST_FUTURES_API_KEY: "227719da8d8499e8d3461587d19f259c0b39c2b462a77c9b748a6119abd74401"
      TEST_FUTURES_API_SECRET: "b14b935f9cfacc5dec829008733c40da0588051f29a44625c34967b45c11d73c"
    steps:
    - uses: actions/checkout@v5
    - name: Checking env
      run: |
        echo "PROXY: $PROXY"
        echo "Python version: ${{ matrix.python-version }}"
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v6
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest pytest-cov pyright tox
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
        if [ -f test-requirements.txt ]; then pip install -r test-requirements.txt; fi
    - name: Type check with pyright (Python 3.12 only)
      if: matrix.python-version == '3.12'
      run: pyright
    - name: Test with tox
      run: tox -e py
    - name: Coveralls Parallel
      uses: coverallsapp/github-action@v2
      with:
        parallel: true
  finish:
    needs: test
    if: ${{ always() }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
    - name: Coveralls Finished
      uses: coverallsapp/github-action@v2
      with:
        parallel-finished: true

</document_content>
</document>
<document index="4">
<source>.gitignore</source>
<document_content>
.tox
.cache/v/cache
docs/_build
binance/__pycache__/
build/
dist/
python_binance.egg-info/
*__pycache__
*.egg-info/
.idea/
venv*/
.vscode
.binance/
</document_content>
</document>
<document index="5">
<source>.pre-commit-config.yaml</source>
<document_content>
repos:
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
    -   id: check-yaml
    -   id: end-of-file-fixer
    -   id: trailing-whitespace

-   repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.8.1
    hooks:
    -   id: ruff
    -   id: ruff-format

-   repo: https://github.com/RobertCraigie/pyright-python
    rev: v1.1.389
    hooks:
    -   id: pyright

</document_content>
</document>
<document index="6">
<source>.readthedocs.yaml</source>
<document_content>
# Read the Docs configuration file for Sphinx projects
# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details

# Required
version: 2

# Set the OS, Python version and other tools you might need
build:
  os: ubuntu-22.04
  tools:
    python: "3.12"
    # You can also specify other tool versions:
    # nodejs: "20"
    # rust: "1.70"
    # golang: "1.20"

# Build documentation in the "docs/" directory with Sphinx
sphinx:
  configuration: docs/conf.py
  # You can configure Sphinx to use a different builder, for instance use the dirhtml builder for simpler URLs
  # builder: "dirhtml"
  # Fail on all warnings to avoid broken references
  # fail_on_warning: true

# Optionally build your docs in additional formats such as PDF and ePub
# formats:
#   - pdf
#   - epub

# Optional but recommended, declare the Python requirements required
# to build your documentation
# See https://docs.readthedocs.io/en/stable/guides/reproducible-builds.html
python:
  install:
    - requirements: docs/requirements.txt
    - requirements: requirements.txt

</document_content>
</document>
<document index="7">
<source>.travis.yml</source>
<document_content>
dist: xenial

language: python

python:
  - "3.6"
  - "3.7"
  - "3.8"
  - "3.9"

install:
  - pip install -r test-requirements.txt
  - pip install -r requirements.txt
  - pip install tox-travis

script:
  - tox

after_success:
  - coveralls

</document_content>
</document>
<document index="8">
<source>LICENSE</source>
<document_content>
MIT License

Copyright (c) 2017 sammchardy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

</document_content>
</document>
<document index="9">
<source>binance/__init__.py</source>
<document_content>
"""An unofficial Python wrapper for the Binance exchange API v3

.. moduleauthor:: Sam McHardy

"""

__version__ = "1.0.32"

from binance.async_client import AsyncClient  # noqa
from binance.client import Client  # noqa
from binance.ws.depthcache import (
    DepthCacheManager,  # noqa
    OptionsDepthCacheManager,  # noqa
    ThreadedDepthCacheManager,  # noqa
    FuturesDepthCacheManager,  # noqa
    OptionsDepthCacheManager,  # noqa
)
from binance.ws.streams import (
    BinanceSocketManager,  # noqa
    ThreadedWebsocketManager,  # noqa
    BinanceSocketType,  # noqa
)

from binance.ws.keepalive_websocket import KeepAliveWebsocket  # noqa

from binance.ws.reconnecting_websocket import ReconnectingWebsocket  # noqa

from binance.ws.constants import *  # noqa

from binance.exceptions import *  # noqa

from binance.enums import *  # noqa

</document_content>
</document>
<document index="10">
<source>binance/enums.py</source>
<document_content>
from enum import Enum

SYMBOL_TYPE_SPOT = "SPOT"

ORDER_STATUS_NEW = "NEW"
ORDER_STATUS_PARTIALLY_FILLED = "PARTIALLY_FILLED"
ORDER_STATUS_FILLED = "FILLED"
ORDER_STATUS_CANCELED = "CANCELED"
ORDER_STATUS_PENDING_CANCEL = "PENDING_CANCEL"
ORDER_STATUS_REJECTED = "REJECTED"
ORDER_STATUS_EXPIRED = "EXPIRED"

KLINE_INTERVAL_1SECOND = "1s"
KLINE_INTERVAL_1MINUTE = "1m"
KLINE_INTERVAL_3MINUTE = "3m"
KLINE_INTERVAL_5MINUTE = "5m"
KLINE_INTERVAL_15MINUTE = "15m"
KLINE_INTERVAL_30MINUTE = "30m"
KLINE_INTERVAL_1HOUR = "1h"
KLINE_INTERVAL_2HOUR = "2h"
KLINE_INTERVAL_4HOUR = "4h"
KLINE_INTERVAL_6HOUR = "6h"
KLINE_INTERVAL_8HOUR = "8h"
KLINE_INTERVAL_12HOUR = "12h"
KLINE_INTERVAL_1DAY = "1d"
KLINE_INTERVAL_3DAY = "3d"
KLINE_INTERVAL_1WEEK = "1w"
KLINE_INTERVAL_1MONTH = "1M"

SIDE_BUY = "BUY"
SIDE_SELL = "SELL"

ORDER_TYPE_LIMIT = "LIMIT"
ORDER_TYPE_MARKET = "MARKET"
ORDER_TYPE_STOP_LOSS = "STOP_LOSS"
ORDER_TYPE_STOP_LOSS_LIMIT = "STOP_LOSS_LIMIT"
ORDER_TYPE_TAKE_PROFIT = "TAKE_PROFIT"
ORDER_TYPE_TAKE_PROFIT_LIMIT = "TAKE_PROFIT_LIMIT"
ORDER_TYPE_LIMIT_MAKER = "LIMIT_MAKER"

FUTURE_ORDER_TYPE_LIMIT = "LIMIT"
FUTURE_ORDER_TYPE_MARKET = "MARKET"
FUTURE_ORDER_TYPE_STOP = "STOP"
FUTURE_ORDER_TYPE_STOP_MARKET = "STOP_MARKET"
FUTURE_ORDER_TYPE_TAKE_PROFIT = "TAKE_PROFIT"
FUTURE_ORDER_TYPE_TAKE_PROFIT_MARKET = "TAKE_PROFIT_MARKET"
FUTURE_ORDER_TYPE_LIMIT_MAKER = "LIMIT_MAKER"
FUTURE_ORDER_TYPE_TRAILING_STOP_MARKET = "TRAILING_STOP_MARKET"

TIME_IN_FORCE_GTC = "GTC"  # Good till cancelled
TIME_IN_FORCE_IOC = "IOC"  # Immediate or cancel
TIME_IN_FORCE_FOK = "FOK"  # Fill or kill
TIME_IN_FORCE_GTX = "GTX"  # Post only order
TIME_IN_FORCE_GTD = "GTD"  # Good till date

ORDER_RESP_TYPE_ACK = "ACK"
ORDER_RESP_TYPE_RESULT = "RESULT"
ORDER_RESP_TYPE_FULL = "FULL"

WEBSOCKET_DEPTH_5 = "5"
WEBSOCKET_DEPTH_10 = "10"
WEBSOCKET_DEPTH_20 = "20"

NO_SIDE_EFFECT_TYPE = "NO_SIDE_EFFECT"
MARGIN_BUY_TYPE = "MARGIN_BUY"
AUTO_REPAY_TYPE = "AUTO_REPAY"


class HistoricalKlinesType(Enum):
    SPOT = 1
    FUTURES = 2
    FUTURES_COIN = 3
    FUTURES_MARK_PRICE = 4
    FUTURES_INDEX_PRICE = 5
    FUTURES_COIN_MARK_PRICE = 6
    FUTURES_COIN_INDEX_PRICE = 7


class FuturesType(Enum):
    USD_M = 1
    COIN_M = 2


class ContractType(Enum):
    PERPETUAL = "perpetual"
    CURRENT_QUARTER = "current_quarter"
    NEXT_QUARTER = "next_quarter"

</document_content>
</document>
<document index="11">
<source>binance/exceptions.py</source>
<document_content>
# coding=utf-8
import json


class BinanceAPIException(Exception):
    def __init__(self, response, status_code, text):
        self.code = 0
        try:
            json_res = json.loads(text)
        except ValueError:
            self.message = "Invalid JSON error message from Binance: {}".format(
                response.text
            )
        else:
            self.code = json_res.get("code")
            self.message = json_res.get("msg")
        self.status_code = status_code
        self.response = response
        self.request = getattr(response, "request", None)

    def __str__(self):  # pragma: no cover
        return "APIError(code=%s): %s" % (self.code, self.message)


class BinanceRequestException(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return "BinanceRequestException: %s" % self.message


class BinanceOrderException(Exception):
    def __init__(self, code, message):
        self.code = code
        self.message = message

    def __str__(self):
        return "BinanceOrderException(code=%s): %s" % (self.code, self.message)


class BinanceOrderMinAmountException(BinanceOrderException):
    def __init__(self, value):
        message = "Amount must be a multiple of %s" % value
        super().__init__(-1013, message)


class BinanceOrderMinPriceException(BinanceOrderException):
    def __init__(self, value):
        message = "Price must be at least %s" % value
        super().__init__(-1013, message)


class BinanceOrderMinTotalException(BinanceOrderException):
    def __init__(self, value):
        message = "Total must be at least %s" % value
        super().__init__(-1013, message)


class BinanceOrderUnknownSymbolException(BinanceOrderException):
    def __init__(self, value):
        message = "Unknown symbol %s" % value
        super().__init__(-1013, message)


class BinanceOrderInactiveSymbolException(BinanceOrderException):
    def __init__(self, value):
        message = "Attempting to trade an inactive symbol %s" % value
        super().__init__(-1013, message)


class BinanceWebsocketUnableToConnect(Exception):
    pass


class BinanceWebsocketQueueOverflow(Exception):
    """Raised when the websocket message queue exceeds its maximum size."""
    pass

class BinanceWebsocketClosed(Exception):
    """Raised when websocket connection is closed."""
    pass

class ReadLoopClosed(Exception):
    """Raised when trying to read from read loop but already closed"""
    pass

class NotImplementedException(Exception):
    def __init__(self, value):
        message = f"Not implemented: {value}"
        super().__init__(message)


class UnknownDateFormat(Exception):
    ...

</document_content>
</document>
<document index="12">
<source>binance/helpers.py</source>
<document_content>
import asyncio
from decimal import Decimal
import json
from typing import Union, Optional, Dict

import dateparser
import pytz

from datetime import datetime, timezone

from binance.exceptions import UnknownDateFormat


def date_to_milliseconds(date_str: str) -> int:
    """Convert UTC date to milliseconds

    If using offset strings add "UTC" to date string e.g. "now UTC", "11 hours ago UTC"

    See dateparse docs for formats http://dateparser.readthedocs.io/en/latest/

    :param date_str: date in readable format, i.e. "January 01, 2018", "11 hours ago UTC", "now UTC"
    """
    # get epoch value in UTC
    epoch: datetime = datetime.fromtimestamp(0,timezone.utc)
    # parse our date string
    d: Optional[datetime] = dateparser.parse(date_str, settings={"TIMEZONE": "UTC"})
    if not d:
        raise UnknownDateFormat(date_str)

    # if the date is not timezone aware apply UTC timezone
    if d.tzinfo is None or d.tzinfo.utcoffset(d) is None:
        d = d.replace(tzinfo=pytz.utc)

    # return the difference in time
    return int((d - epoch).total_seconds() * 1000.0)


def interval_to_milliseconds(interval: str) -> Optional[int]:
    """Convert a Binance interval string to milliseconds

    :param interval: Binance interval string, e.g.: 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w

    :return:
         int value of interval in milliseconds
         None if interval prefix is not a decimal integer
         None if interval suffix is not one of m, h, d, w

    """
    seconds_per_unit: Dict[str, int] = {
        "s": 1,
        "m": 60,
        "h": 60 * 60,
        "d": 24 * 60 * 60,
        "w": 7 * 24 * 60 * 60,
    }
    try:
        return int(interval[:-1]) * seconds_per_unit[interval[-1]] * 1000
    except (ValueError, KeyError):
        return None


def round_step_size(
    quantity: Union[float, Decimal], step_size: Union[float, Decimal]
) -> float:
    """Rounds a given quantity to a specific step size

    :param quantity: required
    :param step_size: required

    :return: decimal
    """
    quantity = Decimal(str(quantity))
    return float(quantity - quantity % Decimal(str(step_size)))


def convert_ts_str(ts_str):
    if ts_str is None:
        return ts_str
    if type(ts_str) == int:
        return ts_str
    return date_to_milliseconds(ts_str)


def convert_list_to_json_array(l):
    if l is None:
        return l
    res = json.dumps(l)
    return res.replace(" ", "")


def get_loop():
    """check if there is an event loop in the current thread, if not create one
    inspired by https://stackoverflow.com/questions/46727787/runtimeerror-there-is-no-current-event-loop-in-thread-in-async-apscheduler
    """
    try:
        loop = asyncio.get_event_loop()
        return loop
    except RuntimeError as e:
        if str(e).startswith("There is no current event loop in thread"):
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            return loop
        else:
            raise

</document_content>
</document>
<document index="13">
<source>binance/ws/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="14">
<source>binance/ws/constants.py</source>
<document_content>
from enum import Enum

KEEPALIVE_TIMEOUT = 5 * 60  # 5 minutes


class WSListenerState(Enum):
    INITIALISING = "Initialising"
    STREAMING = "Streaming"
    RECONNECTING = "Reconnecting"
    EXITING = "Exiting"

</document_content>
</document>
<document index="15">
<source>binance/ws/keepalive_websocket.py</source>
<document_content>
import asyncio
import uuid
from binance.async_client import AsyncClient
from binance.ws.reconnecting_websocket import ReconnectingWebsocket
from binance.ws.constants import KEEPALIVE_TIMEOUT


class KeepAliveWebsocket(ReconnectingWebsocket):
    def __init__(
        self,
        client: AsyncClient,
        url,
        keepalive_type,
        prefix="ws/",
        is_binary=False,
        exit_coro=None,
        user_timeout=None,
        **kwargs,
    ):
        super().__init__(
            path=None,
            url=url,
            prefix=prefix,
            is_binary=is_binary,
            exit_coro=exit_coro,
            **kwargs,
        )
        self._keepalive_type = keepalive_type
        self._client = client
        self._user_timeout = user_timeout or KEEPALIVE_TIMEOUT
        self._timer = None
        self._subscription_id = None
        self._listen_key = None  # Used for non spot stream types

    async def __aexit__(self, *args, **kwargs):
        if not self._path:
            return
        if self._timer:
            self._timer.cancel()
            self._timer = None
        # Clean up subscription if it exists
        if self._subscription_id is not None:
            await self._unsubscribe_from_user_data_stream()
        await super().__aexit__(*args, **kwargs)

    def _build_path(self):
        self._path = self._listen_key
        time_unit = getattr(self._client, "TIME_UNIT", None)
        if time_unit:
            self._path = f"{self._listen_key}?timeUnit={time_unit}"

    async def _before_connect(self):
        if self._keepalive_type == "user":
            self._subscription_id = await self._subscribe_to_user_data_stream()
            # Reuse the ws_api connection that's already established
            self.ws = self._client.ws_api.ws
            self.ws_state = self._client.ws_api.ws_state
            self._queue = self._client.ws_api._queue
            return
        if not self._listen_key:
            self._listen_key = await self._get_listen_key()
            self._build_path()

    async def _after_connect(self):
        self._start_socket_timer()

    def _start_socket_timer(self):
        self._timer = self._loop.call_later(
            self._user_timeout, lambda: asyncio.create_task(self._keepalive_socket())
        )

    async def _subscribe_to_user_data_stream(self):
        """Subscribe to user data stream using WebSocket API"""
        params = {
            "id": str(uuid.uuid4()),
        }
        response = await self._client._ws_api_request(
            "userDataStream.subscribe.signature", 
            signed=True, 
            params=params
        )
        return response.get("subscriptionId")

    async def _unsubscribe_from_user_data_stream(self):
        """Unsubscribe from user data stream using WebSocket API"""
        if self._keepalive_type == "user" and self._subscription_id is not None:
            params = {
                "id": str(uuid.uuid4()),
                "subscriptionId": self._subscription_id,
            }
            await self._client._ws_api_request(
                "userDataStream.unsubscribe", 
                signed=False, 
                params=params
            )
            self._subscription_id = None

    async def _get_listen_key(self):
        if self._keepalive_type == "user":
            listen_key = await self._client.stream_get_listen_key()
        elif self._keepalive_type == "margin":  # cross-margin
            listen_key = await self._client.margin_stream_get_listen_key()
        elif self._keepalive_type == "futures":
            listen_key = await self._client.futures_stream_get_listen_key()
        elif self._keepalive_type == "coin_futures":
            listen_key = await self._client.futures_coin_stream_get_listen_key()
        elif self._keepalive_type == "portfolio_margin":
            listen_key = await self._client.papi_stream_get_listen_key()
        else:  # isolated margin
            # Passing symbol for isolated margin
            listen_key = await self._client.isolated_margin_stream_get_listen_key(
                self._keepalive_type
            )
        return listen_key

    async def _keepalive_socket(self):
        try:
            if self._keepalive_type == "user":
                return
            listen_key = await self._get_listen_key()
            if listen_key != self._listen_key:
                self._log.debug("listen key changed: reconnect")
                self._listen_key = listen_key
                self._build_path()
                self._reconnect()
            else:
                self._log.debug("listen key same: keepalive")
                if self._keepalive_type == "margin":  # cross-margin
                    await self._client.margin_stream_keepalive(self._listen_key)
                elif self._keepalive_type == "futures":
                    await self._client.futures_stream_keepalive(self._listen_key)
                elif self._keepalive_type == "coin_futures":
                        await self._client.futures_coin_stream_keepalive(self._listen_key)
                elif self._keepalive_type == "portfolio_margin":
                    await self._client.papi_stream_keepalive(self._listen_key)
                else:  # isolated margin
                    # Passing symbol for isolated margin
                    await self._client.isolated_margin_stream_keepalive(
                        self._keepalive_type, self._listen_key
                    )
        except Exception as e:
            self._log.error(f"error in keepalive_socket: {e}")
        finally:
            self._start_socket_timer()

</document_content>
</document>
<document index="16">
<source>binance/ws/threaded_stream.py</source>
<document_content>
import asyncio
import logging
import threading
from typing import Optional, Dict, Any

from binance.async_client import AsyncClient
from binance.helpers import get_loop


class ThreadedApiManager(threading.Thread):
    def __init__(
        self,
        api_key: Optional[str] = None,
        api_secret: Optional[str] = None,
        requests_params: Optional[Dict[str, Any]] = None,
        tld: str = "com",
        testnet: bool = False,
        session_params: Optional[Dict[str, Any]] = None,
        https_proxy: Optional[str] = None,
        _loop: Optional[asyncio.AbstractEventLoop] = None,
    ):
        """Initialise the BinanceSocketManager"""
        super().__init__()
        self._loop: asyncio.AbstractEventLoop = get_loop() if _loop is None else _loop
        self._client: Optional[AsyncClient] = None
        self._running: bool = True
        self._socket_running: Dict[str, bool] = {}
        self._log = logging.getLogger(__name__)
        self._client_params = {
            "api_key": api_key,
            "api_secret": api_secret,
            "requests_params": requests_params,
            "tld": tld,
            "testnet": testnet,
            "session_params": session_params,
            "https_proxy": https_proxy,
        }

    async def _before_socket_listener_start(self): ...

    async def socket_listener(self):
        try:
            self._client = await AsyncClient.create(loop=self._loop, **self._client_params)
            await self._before_socket_listener_start()
        except Exception as e:
            self._log.error(f"Failed to create client: {e}")
            self.stop()
        while self._running:
            await asyncio.sleep(0.2)
        while self._socket_running:
            await asyncio.sleep(0.2)
        self._log.info("Socket listener stopped")

    async def start_listener(self, socket, path: str, callback):
        async with socket as s:
            while self._socket_running[path]:
                try:
                    msg = await asyncio.wait_for(s.recv(), 3)
                except asyncio.TimeoutError:
                    ...
                    continue
                except Exception as e:
                    self._log.error(f"Error receiving message: {e}")
                    msg = {
                        "e": "error",
                        "type": e.__class__.__name__,
                        "m": f"{e}",
                    }
                if not msg:
                    continue  # Handle both async and sync callbacks
                if asyncio.iscoroutinefunction(callback):
                    asyncio.create_task(callback(msg))
                else:
                    callback(msg)
        del self._socket_running[path]

    def run(self):
        self._loop.run_until_complete(self.socket_listener())

    def stop_socket(self, socket_name):
        if socket_name in self._socket_running:
            self._socket_running[socket_name] = False

    async def stop_client(self):
        if not self._client:
            return
        await self._client.close_connection()

    def stop(self):
        self._log.debug("Stopping ThreadedApiManager")
        if not self._running:
            return
        self._running = False
        if self._client and self._loop and not self._loop.is_closed():
            try:
                future = asyncio.run_coroutine_threadsafe(
                    self.stop_client(), self._loop
                )
                future.result(timeout=5)  # Add timeout to prevent hanging
            except Exception as e:
                # Log the error but don't raise it
                self._log.error(f"Error stopping client: {e}")
        for socket_name in self._socket_running.keys():
            self._socket_running[socket_name] = False

</document_content>
</document>
<document index="17">
<source>binance/ws/websocket_api.py</source>
<document_content>
from typing import Dict, Optional
import asyncio

from websockets import WebSocketClientProtocol  # type: ignore

from .constants import WSListenerState
from .reconnecting_websocket import ReconnectingWebsocket
from binance.exceptions import BinanceAPIException, BinanceWebsocketUnableToConnect


class WebsocketAPI(ReconnectingWebsocket):
    def __init__(self, url: str, tld: str = "com", testnet: bool = False, https_proxy: Optional[str] = None):
        self._tld = tld
        self._testnet = testnet
        self._responses: Dict[str, asyncio.Future] = {}
        self._connection_lock: Optional[asyncio.Lock] = None
        super().__init__(url=url, prefix="", path="", is_binary=False, https_proxy=https_proxy)

    @property
    def connection_lock(self) -> asyncio.Lock:
        if self._connection_lock is None:
            loop = asyncio.get_event_loop()
            self._connection_lock = asyncio.Lock()
        return self._connection_lock

    def _handle_message(self, msg):
        """Override message handling to support request-response"""
        parsed_msg = super()._handle_message(msg)
        self._log.debug(f"Received message: {parsed_msg}")
        if parsed_msg is None:
            return None

        # Check if this is a subscription event (user data stream, etc.)
        # These have 'subscriptionId' and 'event' fields instead of 'id'
        if "subscriptionId" in parsed_msg and "event" in parsed_msg:
            return parsed_msg["event"]

        req_id, exception = None, None
        if "id" in parsed_msg:
            req_id = parsed_msg["id"]
        if "status" in parsed_msg:
            if parsed_msg["status"] != 200:
                exception = BinanceAPIException(
                    parsed_msg, parsed_msg["status"], self.json_dumps(parsed_msg["error"])
                )
        if req_id is not None and req_id in self._responses:
            if exception is not None:
                self._responses[req_id].set_exception(exception)
            else:
                self._responses[req_id].set_result(parsed_msg)
            return None  # Don't queue request-response messages
        elif exception is not None:
            raise exception
        else:
            self._log.warning(f"WS api receieved unknown message: {parsed_msg}")
            return None

    async def _ensure_ws_connection(self) -> None:
        """Ensure WebSocket connection is established and ready

        This function will:
        1. Check if connection exists and is streaming
        2. Attempt to connect if not
        3. Wait for connection to be ready
        4. Handle reconnection if needed
        """
        async with self.connection_lock:
            try:
                if (
                    self.ws is None
                    or (isinstance(self.ws, WebSocketClientProtocol) and self.ws.closed)
                    or self.ws_state != WSListenerState.STREAMING
                ):
                    await self.connect()

                    # Wait for connection to be ready
                    retries = 0
                    while (
                        self.ws_state != WSListenerState.STREAMING
                        and retries < self.MAX_RECONNECTS
                    ):
                        if self.ws_state == WSListenerState.RECONNECTING:
                            self._log.info("Connection is reconnecting, waiting...")
                            await self._wait_for_reconnect()

                        elif self.ws is None or self.ws.closed:
                            self._log.info("Connection lost, reconnecting...")
                            await self.connect()

                        retries += 1
                        await asyncio.sleep(self.MIN_RECONNECT_WAIT)

                    if self.ws_state != WSListenerState.STREAMING:
                        raise BinanceWebsocketUnableToConnect(
                            f"Failed to establish connection after {retries} attempts"
                        )

                    self._log.debug("WebSocket connection established")

            except Exception as e:
                self._log.error(f"Error ensuring WebSocket connection: {e}")
                raise BinanceWebsocketUnableToConnect(f"Connection failed: {str(e)}")

    async def request(self, id: str, payload: dict) -> dict:
        """Send request and wait for response"""
        await self._ensure_ws_connection()

        # Create future for response
        future = asyncio.Future()
        self._responses[id] = future

        try:
            # Send request
            if self.ws is None:
                raise BinanceWebsocketUnableToConnect(
                    "Trying to send request while WebSocket is not connected"
                )
            await self.ws.send(self.json_dumps(payload))

            # Wait for response
            response = await asyncio.wait_for(future, timeout=self.TIMEOUT)

            # Check for errors
            if "error" in response:
                raise BinanceWebsocketUnableToConnect(response["error"])

            return response.get("result", response)

        except asyncio.TimeoutError:
            raise BinanceWebsocketUnableToConnect("Request timed out")
        except Exception as e:
            raise e
        finally:
            self._responses.pop(id, None)

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Clean up responses before closing"""
        response_ids = list(self._responses.keys())  # Create a copy of keys
        for req_id in response_ids:
            future = self._responses.pop(req_id)  # Remove and get the future
            if not future.done():
                future.set_exception(
                    BinanceWebsocketUnableToConnect("WebSocket closing")
                )
        await super().__aexit__(exc_type, exc_val, exc_tb)

</document_content>
</document>
<document index="18">
<source>docs/Makefile</source>
<document_content>
# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line.
SPHINXOPTS    =
SPHINXBUILD   = python -msphinx
SPHINXPROJ    = python-binance
SOURCEDIR     = .
BUILDDIR      = _build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

rst:
	sphinx-apidoc -f -o ./ ../

</document_content>
</document>
<document index="19">
<source>docs/account.rst</source>
<document_content>
Account Endpoints
=================

Orders
------

Order Validation
^^^^^^^^^^^^^^^^

Binance has a number of rules around symbol pair orders with validation on minimum price, quantity and total order value.

Read more about their specifics in the `Filters <https://binance-docs.github.io/apidocs/spot/en/#filters>`_
section of the official API.

Read `Understanding Binance Order Filters <https://sammchardy.github.io/binance/2021/05/03/binance-order-filters.html>`_
for more information about price and quantity filters on `Binance <https://www.binance.com/?ref=10099792>`_.

It can be helpful to format the output using formatting

.. code:: python

    amount = 0.000234234
    precision = 5
    amt_str = "{:0.0{}f}".format(amount, precision)

Or if you have the tickSize or stepSize then use the helper to round to step size

.. code:: python

    from binance.helpers import round_step_size

    amount = 0.000234234
    tick_size = 0.00001
    rounded_amount = round_step_size(amount, tick_size)


`Fetch all orders <binance.html#binance.client.Client.get_all_orders>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    orders = client.get_all_orders(symbol='BNBBTC', limit=10)


`Place an order <binance.html#binance.client.Client.create_order>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Place an order**

Use the `create_order` function to have full control over creating an order

.. code:: python

    from binance.enums import *
    order = client.create_order(
        symbol='BNBBTC',
        side=SIDE_BUY,
        type=ORDER_TYPE_LIMIT,
        timeInForce=TIME_IN_FORCE_GTC,
        quantity=100,
        price='0.00001')

**Place a limit order**

Use the helper functions to easily place a limit buy or sell order

.. code:: python

    order = client.order_limit_buy(
        symbol='BNBBTC',
        quantity=100,
        price='0.00001')

    order = client.order_limit_sell(
        symbol='BNBBTC',
        quantity=100,
        price='0.00001')


**Place a market order**

Use the helper functions to easily place a market buy or sell order

.. code:: python

    order = client.order_market_buy(
        symbol='BNBBTC',
        quantity=100)

    order = client.order_market_sell(
        symbol='BNBBTC',
        quantity=100)

**Place an OCO order**

Use the `create_oco_order` function to have full control over creating an OCO order

.. code:: python

    from binance.enums import *
    order = client.create_oco_order(
        symbol='BNBBTC',
        side=SIDE_SELL,
        stopLimitTimeInForce=TIME_IN_FORCE_GTC,
        quantity=100,
        stopPrice='0.00001',
        price='0.00002')


`Place a test order <binance.html#binance.client.Client.create_test_order>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Creates and validates a new order but does not send it into the exchange.

.. code:: python

    from binance.enums import *
    order = client.create_test_order(
        symbol='BNBBTC',
        side=SIDE_BUY,
        type=ORDER_TYPE_LIMIT,
        timeInForce=TIME_IN_FORCE_GTC,
        quantity=100,
        price='0.00001')

`Check order status <binance.html#binance.client.Client.get_order>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    order = client.get_order(
        symbol='BNBBTC',
        orderId='orderId')


`Cancel an order <binance.html#binance.client.Client.cancel_order>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    result = client.cancel_order(
        symbol='BNBBTC',
        orderId='orderId')


`Get all open orders <binance.html#binance.client.Client.get_open_orders>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    orders = client.get_open_orders(symbol='BNBBTC')

`Get all orders <binance.html#binance.client.Client.get_all_orders>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    orders = client.get_all_orders(symbol='BNBBTC')


Account
-------

`Get account info <binance.html#binance.client.Client.get_account>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    info = client.get_account()

`Get asset balance <binance.html#binance.client.Client.get_asset_balance>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    balance = client.get_asset_balance(asset='BTC')

`Get account status <binance.html#binance.client.Client.get_account_status>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    status = client.get_account_status()

`Get account API trading status <binance.html#binance.client.Client.get_account_api_trading_status>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    status = client.get_account_api_trading_status()

`Get trades <binance.html#binance.client.Client.get_my_trades>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    trades = client.get_my_trades(symbol='BNBBTC')

`Get trade fees <binance.html#binance.client.Client.get_trade_fee>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    # get fees for all symbols
    fees = client.get_trade_fee()

    # get fee for one symbol
    fees = client.get_trade_fee(symbol='BNBBTC')

`Get asset details <binance.html#binance.client.Client.get_asset_details>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    details = client.get_asset_details()

`Get dust log <binance.html#binance.client.Client.get_dust_log>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    log = client.get_dust_log()

`Transfer dust <binance.html#binance.client.Client.transfer_dust>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    transfer = client.transfer_dust(asset='BNZ')


`Get Asset Dividend History <binance.html#binance.client.Client.get_asset_dividend_history>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    history = client.get_asset_dividend_history()


`Disable Fast Withdraw Switch <binance.html#binance.client.Client.disable_fast_withdraw_switch>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    client.disable_fast_withdraw_switch()


`Enable Fast Withdraw Switch <binance.html#binance.client.Client.enable_fast_withdraw_switch>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    client.enable_fast_withdraw_switch()

</document_content>
</document>
<document index="20">
<source>docs/binance.rst</source>
<document_content>
Binance API
===========

Client module
-------------

.. automodule:: binance.client
    :members:
    :undoc-members:
    :show-inheritance:

Async client module
-------------------

.. automodule:: binance.async_client
    :members:
    :undoc-members:
    :show-inheritance:

Websockets module
-----------------

.. automodule:: binance.ws.streams
    :members:
    :undoc-members:
    :show-inheritance:

Threaded streams module
-----------------------

.. automodule:: binance.ws.threaded_stream
    :members:
    :undoc-members:
    :show-inheritance:

depthcache module
-----------------

.. automodule:: binance.ws.depthcache
    :members:
    :undoc-members:
    :show-inheritance:

exceptions module
-----------------

.. automodule:: binance.exceptions
    :members:
    :undoc-members:
    :show-inheritance:

helpers module
--------------

.. automodule:: binance.helpers
    :members:
    :undoc-members:
    :show-inheritance:

</document_content>
</document>
<document index="21">
<source>docs/conf.py</source>
<document_content>
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# python-binance documentation build configuration file, created by
# sphinx-quickstart on Thu Sep 21 20:24:54 2017.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
import os
import sys

sys.path.insert(0, os.path.abspath(".."))


# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.imgmath",
    "sphinx.ext.viewcode",
    "sphinx.ext.githubpages",
    "sphinx_copybutton",
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
source_suffix = ".rst"

# The master toctree document.
master_doc = "index"

# General information about the project.
project = "python-binance"
copyright = "2017, Sam McHardy"
author = "Sam McHardy"

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = "0.2.0"
# The full version, including alpha/beta/rc tags.
release = "0.2.0"

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = "en"

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This patterns also effect to html_static_path and html_extra_path
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = "sphinx"

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
# html_theme = 'alabaster'
html_theme = "sphinx_rtd_theme"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#
# html_theme_options = {}

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]

# Custom sidebar templates, must be a dictionary that maps document names
# to template names.
#
# This is required for the alabaster theme
# refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars
html_sidebars = {
    "**": [
        "about.html",
        "navigation.html",
        "relations.html",  # needs 'show_related': True theme option to display
        "searchbox.html",
        "donate.html",
    ]
}


# -- Options for HTMLHelp output ------------------------------------------

# Output file base name for HTML help builder.
htmlhelp_basename = "python-binancedoc"


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #
    # 'papersize': 'letterpaper',
    # The font size ('10pt', '11pt' or '12pt').
    #
    # 'pointsize': '10pt',
    # Additional stuff for the LaTeX preamble.
    #
    # 'preamble': '',
    # Latex figure (float) alignment
    #
    # 'figure_align': 'htbp',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    (
        master_doc,
        "python-binance.tex",
        "python-binance Documentation",
        "Sam McHardy",
        "manual",
    ),
]


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    (master_doc, "python-binance", "python-binance Documentation", [author], 1)
]


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (
        master_doc,
        "python-binance",
        "python-binance Documentation",
        author,
        "python-binance",
        "One line description of project.",
        "Miscellaneous",
    ),
]


def skip(app, what, name, obj, skip, options):
    # Ensure that the __init__ method gets documented.
    if name == "__init__":
        return False
    return skip


def setup(app):
    app.connect("autodoc-skip-member", skip)

</document_content>
</document>
<document index="22">
<source>docs/constants.rst</source>
<document_content>
Binance Constants
=================

Binance requires specific string constants for Order Types, Order Side, Time in Force, Order response and Kline intervals these are found on `binance.client.Client`.

.. code:: python

    SYMBOL_TYPE_SPOT = 'SPOT'

    ORDER_STATUS_NEW = 'NEW'
    ORDER_STATUS_PARTIALLY_FILLED = 'PARTIALLY_FILLED'
    ORDER_STATUS_FILLED = 'FILLED'
    ORDER_STATUS_CANCELED = 'CANCELED'
    ORDER_STATUS_PENDING_CANCEL = 'PENDING_CANCEL'
    ORDER_STATUS_REJECTED = 'REJECTED'
    ORDER_STATUS_EXPIRED = 'EXPIRED'

    KLINE_INTERVAL_1SECOND = '1s'
    KLINE_INTERVAL_1MINUTE = '1m'
    KLINE_INTERVAL_3MINUTE = '3m'
    KLINE_INTERVAL_5MINUTE = '5m'
    KLINE_INTERVAL_15MINUTE = '15m'
    KLINE_INTERVAL_30MINUTE = '30m'
    KLINE_INTERVAL_1HOUR = '1h'
    KLINE_INTERVAL_2HOUR = '2h'
    KLINE_INTERVAL_4HOUR = '4h'
    KLINE_INTERVAL_6HOUR = '6h'
    KLINE_INTERVAL_8HOUR = '8h'
    KLINE_INTERVAL_12HOUR = '12h'
    KLINE_INTERVAL_1DAY = '1d'
    KLINE_INTERVAL_3DAY = '3d'
    KLINE_INTERVAL_1WEEK = '1w'
    KLINE_INTERVAL_1MONTH = '1M'

    SIDE_BUY = 'BUY'
    SIDE_SELL = 'SELL'

    ORDER_TYPE_LIMIT = 'LIMIT'
    ORDER_TYPE_MARKET = 'MARKET'
    ORDER_TYPE_STOP_LOSS = 'STOP_LOSS'
    ORDER_TYPE_STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT'
    ORDER_TYPE_TAKE_PROFIT = 'TAKE_PROFIT'
    ORDER_TYPE_TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT'
    ORDER_TYPE_LIMIT_MAKER = 'LIMIT_MAKER'

    TIME_IN_FORCE_GTC = 'GTC'
    TIME_IN_FORCE_IOC = 'IOC'
    TIME_IN_FORCE_FOK = 'FOK'

    ORDER_RESP_TYPE_ACK = 'ACK'
    ORDER_RESP_TYPE_RESULT = 'RESULT'
    ORDER_RESP_TYPE_FULL = 'FULL'

    # For accessing the data returned by Client.aggregate_trades().
    AGG_ID             = 'a'
    AGG_PRICE          = 'p'
    AGG_QUANTITY       = 'q'
    AGG_FIRST_TRADE_ID = 'f'
    AGG_LAST_TRADE_ID  = 'l'
    AGG_TIME           = 'T'
    AGG_BUYER_MAKES    = 'm'
    AGG_BEST_MATCH     = 'M'


For Websocket Depth these are found on `binance.websockets.BinanceSocketManager`

.. code:: python

    WEBSOCKET_DEPTH_5 = '5'
    WEBSOCKET_DEPTH_10 = '10'
    WEBSOCKET_DEPTH_20 = '20'

To use in your code reference either binance.client.Client or binance.websockets.BinanceSocketManager

.. code:: python

    from binance.client import Client
    from binance.websockets import BinanceSocketManager

    side = Client.SIDE_BUY

</document_content>
</document>
<document index="23">
<source>docs/depth_cache.rst</source>
<document_content>
Depth Cache
===========

To follow the depth cache updates for a symbol there are 2 options similar to websockets.

Use the `DepthCacheManager <binance.html#binance.depth_cache.DepthCacheManager>`_
(or `OptionsDepthCacheManager <binance.html#binance.depth_cache.OptionsDepthCacheManager>`_ for vanilla options) or
use the `ThreadedDepthCacheManager <binance.html#binance.depth_cache.ThreadedDepthCacheManager>`_
if you don't want to interact with asyncio.

ThreadedDepthCacheManager Websocket Usage
-----------------------------------------

Starting sockets on the ThreadedDepthCacheManager requires a callback parameter, similar to old implementations of
depth cache on python-binance pre v1

ThreadedDepthCacheManager takes similar parameters to the `Client <binance.html#binance.client.Client>`_ class
as it creates an AsyncClient internally.

As these use threads `start()` is required to be called before starting any depth cache streams.

To keep the ThreadedDepthCacheManager running using `join()` to join it to the main thread.

.. code:: python

    from binance import ThreadedDepthCacheManager

    def main():

        dcm = ThreadedDepthCacheManager()
        # start is required to initialise its internal loop
        dcm.start()

        def handle_depth_cache(depth_cache):
            print(f"symbol {depth_cache.symbol}")
            print("top 5 bids")
            print(depth_cache.get_bids()[:5])
            print("top 5 asks")
            print(depth_cache.get_asks()[:5])
            print("last update time {}".format(depth_cache.update_time))

        dcm_name = dcm.start_depth_cache(handle_depth_cache, symbol='BNBBTC')

        # multiple depth caches can be started
        dcm_name = dcm.start_depth_cache(handle_depth_cache, symbol='ETHBTC')

        dcm.join()


    if __name__ == "__main__":
       main()


**Stop Individual Depth Cache**

When starting a stream, a name for that stream will be returned. This can be used to stop that individual stream

.. code:: python

    from binance import ThreadedDepthCacheManager

    symbol = 'BNBBTC'

    dcm = ThreadedDepthCacheManager()
    dcm.start()

    def handle_depth_cache(depth_cache):
        print(f"message type: {msg['e']}")
        print(msg)

    dcm_name = dcm.start_depth_cache(handle_depth_cache, symbol='BNBBTC')

    # some time later

    dcm.stop_socket(dcm_name)

**Stop All Depth Cache streams**

.. code:: python

    from binance import ThreadedDepthCacheManager

    symbol = 'BNBBTC'

    dcm = ThreadedDepthCacheManager()
    dcm.start()

    def handle_depth_cache(depth_cache):
        print(f"message type: {msg['e']}")
        print(msg)

    dcm_name = dcm.start_depth_cache(handle_depth_cache, symbol='BNBBTC')

    # some time later

    dcm.stop()

Attempting to start a stream after `stop` is called will not work.


DepthCacheManager or OptionsDepthCacheManager Usage
---------------------------------------------------

Create the manager like so, passing the async api client, symbol and an optional callback function.

.. code:: python

    import asyncio

    from binance import AsyncClient, DepthCacheManager


    async def main():
        client = await AsyncClient.create()
        dcm = DepthCacheManager(client, 'BNBBTC')

        async with dcm as dcm_socket:
            while True:
                depth_cache = await dcm_socket.recv()
                print("symbol {}".format(depth_cache.symbol))
                print("top 5 bids")
                print(depth_cache.get_bids()[:5])
                print("top 5 asks")
                print(depth_cache.get_asks()[:5])
                print("last update time {}".format(depth_cache.update_time))

    if __name__ == "__main__":

        loop = asyncio.get_event_loop()
        loop.run_until_complete(main())

The `DepthCacheManager` returns an Asynchronous Context Manager which can be used with `async for`
or by interacting with the `__aenter__` and `__aexit__` functions

By default the depth cache will fetch the order book via REST request every 30 minutes.
This duration can be changed by using the `refresh_interval` parameter. To disable the refresh pass 0 or None.
The socket connection will stay open receiving updates to be replayed once the full order book is received.

Share a Socket Manager
----------------------

Here dcm1 and dcm2 share the same instance of BinanceSocketManager

.. code:: python

    from binance.websockets import BinanceSocketManager
    from binance.depthcache import DepthCacheManager
    bm = BinanceSocketManager(client)
    dcm1 = DepthCacheManager(client, 'BNBBTC', bm=bm)
    dcm2 = DepthCacheManager(client, 'ETHBTC', bm=bm)

Websocket Errors
----------------

If the underlying websocket is disconnected and is unable to reconnect None is returned for the depth_cache parameter.
If the underlying websocket is disconnected an error msg is passed to the callback and to recv() containing the error message.
In the case the BinanceWebsocketClosed is returned, the websocket will attempt to reconnect 5 times before returning a BinanceUnableToConnect error.
Example:

.. code:: python

            depth_cache = await dcm.recv()
            if isinstance(depth_cache, dict) and depth_cache.get('e') == 'error':
                logger.error(f"Received depth cache error in callback: {depth_cache}")
                if type == 'BinanceWebsocketClosed':
                    # ignore as attempts to reconnect
                    continue
                break

.. code:: python
            def handle_depth_cache(depth_cache):
                if isinstance(depth_cache, dict) and depth_cache.get('e') == 'error':
                    logger.error(f"Received depth cache error in callback: {depth_cache}")
                    type = depth_cache.get('type')
                    if type == 'BinanceWebsocketClosed':
                        # Automatically attempts to reconnect
                        return
                    dcm.stop()
                    return
                # handle non error cases here

Examples
--------

.. code:: python

    # 1 hour interval refresh
    dcm = DepthCacheManager(client, 'BNBBTC', refresh_interval=60*60)

    # disable refreshing
    dcm = DepthCacheManager(client, 'BNBBTC', refresh_interval=0)

.. code:: python

    async with dcm as dcm_socket:
        while True:
            depth_cache = await dcm_socket.recv()
            print("symbol {}".format(depth_cache.symbol))
            print("top 5 bids")
            print(depth_cache.get_bids()[:5])
            print("top 5 asks")
            print(depth_cache.get_asks()[:5])
            print("last update time {}".format(depth_cache.update_time))

To use the magic `__aenter__` and `__aexit__` functions to use this class without the `async with`

.. code:: python

    dcm = DepthCacheManager(client, 'BNBBTC')

    await dcm.__aenter__()
    depth_cache = await dcm.recv()
    print("symbol {}".format(depth_cache.symbol))
    print("top 5 bids")
    print(depth_cache.get_bids()[:5])
    print("top 5 asks")
    print(depth_cache.get_asks()[:5])
    print("last update time {}".format(depth_cache.update_time))

    # exit the context manager
    await dcm.__aexit__(None, None, None)

</document_content>
</document>
<document index="24">
<source>docs/exceptions.rst</source>
<document_content>
Exceptions
==========

BinanceRequestException
------------------------

Raised if a non JSON response is returned

BinanceAPIException
-------------------

On an API call error a binance.exceptions.BinanceAPIException will be raised.

The exception provides access to the

- `status_code` - response status code
- `response` - response object
- `code` - Binance error code
- `message` - Binance error message
- `request` - request object if available

.. code:: python

    try:
        client.get_all_orders()
    except BinanceAPIException as e:
        print e.status_code
        print e.message

</document_content>
</document>
<document index="25">
<source>docs/faqs.rst</source>
<document_content>
FAQ
=======

*Q: Why do I get "Timestamp for this request is not valid"*

*A*: This occurs in 2 different cases.

The timestamp sent is outside of the serverTime - recvWindow value
The timestamp sent is more than 1000ms ahead of the server time

Check that your system time is in sync. See `this issue <https://github.com/sammchardy/python-binance/issues/2#issuecomment-324878152>`_ for some sample code to check the difference between your local
time and the Binance server time.

*Q: Why do I get "Signature for this request is not valid"*

*A1*: One of your parameters may not be in the correct format.

Check recvWindow is an integer and not a string.

*A2*: You may need to regenerate your API Key and Secret

*A3*: You may be attempting to access the API from a Chinese IP address, these are now restricted by Binance.

</document_content>
</document>
<document index="26">
<source>docs/general.rst</source>
<document_content>
General Endpoints
=================

`Ping the server <binance.html#binance.client.Client.ping>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    client.ping()

`Get the server time <binance.html#binance.client.Client.get_server_time>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    time_res = client.get_server_time()

`Get system status <binance.html#binance.client.Client.get_system_status>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    status = client.get_system_status()

Returns

.. code-block:: python

    {
        "status": 0,        # 0: normal1system maintenance
        "msg": "normal"     # normal or System maintenance.
    }

`Get Exchange Info <binance.html#binance.client.Client.get_exchange_info>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    info = client.get_exchange_info()

`Get Symbol Info <binance.html#binance.client.Client.get_symbol_info>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Get the exchange info for a particular symbol

.. code:: python

    info = client.get_symbol_info('BNBBTC')

`Get All Coins Info <binance.html#binance.client.Client.get_all_tickers>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Get information of coins (available for deposit and withdraw) for user

.. code:: python

    info = client.get_all_tickers()

`Get Get Daily Account Snapshot <binance.html#binance.client.Client.get_account_snapshot>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Get daily account snapshot of specific type. Valid types: SPOT/MARGIN/FUTURES.

.. code:: python

    info = client.get_account_snapshot(type='SPOT')

`Get Current Products <binance.html#binance.client.Client.get_products>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This call is deprecated, use the above Exchange Info call

.. code:: python

    products = client.get_products()

</document_content>
</document>
<document index="27">
<source>docs/helpers.rst</source>
<document_content>
Helper Functions
================

.. autoclass:: binance.helpers
    :members: date_to_milliseconds, interval_to_milliseconds, round_step_size
    :noindex:

</document_content>
</document>
<document index="28">
<source>docs/index.rst</source>
<document_content>
.. python-binance documentation master file, created by
   sphinx-quickstart on Thu Sep 21 20:24:54 2017.

.. include:: ../README.rst

Contents
========

.. toctree::
   :maxdepth: 2

   overview
   constants
   general
   market_data
   account
   sub_accounts
   margin
   websockets
   depth_cache
   withdraw
   helpers
   exceptions
   faqs
   changelog

   binance

Index
==================

* :ref:`genindex`

</document_content>
</document>
<document index="29">
<source>docs/market_data.rst</source>
<document_content>
Market Data Endpoints
=====================


`Get Market Depth <binance.html#binance.client.Client.get_order_book>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    depth = client.get_order_book(symbol='BNBBTC')

`Get Recent Trades <binance.html#binance.client.Client.get_recent_trades>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    trades = client.get_recent_trades(symbol='BNBBTC')

`Get Historical Trades <binance.html#binance.client.Client.get_historical_trades>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    trades = client.get_historical_trades(symbol='BNBBTC')

`Get Aggregate Trades <binance.html#binance.client.Client.get_aggregate_trades>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    trades = client.get_aggregate_trades(symbol='BNBBTC')

`Aggregate Trade Iterator <binance.html#binance.client.Client.aggregate_trade_iter>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Iterate over aggregate trades for a symbol from a given date or a given order id.

.. code:: python

    agg_trades = client.aggregate_trade_iter(symbol='ETHBTC', start_str='30 minutes ago UTC')

    # iterate over the trade iterator
    for trade in agg_trades:
        print(trade)
        # do something with the trade data

    # convert the iterator to a list
    # note: generators can only be iterated over once so we need to call it again
    agg_trades = client.aggregate_trade_iter(symbol='ETHBTC', '30 minutes ago UTC')
    agg_trade_list = list(agg_trades)

    # example using last_id value
    agg_trades = client.aggregate_trade_iter(symbol='ETHBTC', last_id=23380478)
    agg_trade_list = list(agg_trades)


`Get Kline/Candlesticks <binance.html#binance.client.Client.get_klines>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    candles = client.get_klines(symbol='BNBBTC', interval=Client.KLINE_INTERVAL_30MINUTE)

`Get Historical Kline/Candlesticks <binance.html#binance.client.Client.get_historical_klines>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Fetch klines for any date range and interval

.. code:: python

    # fetch 1 minute klines for the last day up until now
    klines = client.get_historical_klines("BNBBTC", Client.KLINE_INTERVAL_1MINUTE, "1 day ago UTC")

    # fetch 30 minute klines for the last month of 2017
    klines = client.get_historical_klines("ETHBTC", Client.KLINE_INTERVAL_30MINUTE, "1 Dec, 2017", "1 Jan, 2018")

    # fetch weekly klines since it listed
    klines = client.get_historical_klines("NEOBTC", Client.KLINE_INTERVAL_1WEEK, "1 Jan, 2017")


`Get Historical Kline/Candlesticks using a generator <binance.html#binance.client.Client.get_historical_klines_generator>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Fetch klines using a generator

.. code:: python

    for kline in client.get_historical_klines_generator("BNBBTC", Client.KLINE_INTERVAL_1MINUTE, "1 day ago UTC"):
        print(kline)
        # do something with the kline

`Get average price for a symbol <binance.html#binance.client.Client.get_avg_price>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    avg_price = client.get_avg_price(symbol='BNBBTC')

`Get 24hr Ticker <binance.html#binance.client.Client.get_ticker>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    tickers = client.get_ticker()

`Get All Prices <binance.html#binance.client.Client.get_all_tickers>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Get last price for all markets.

.. code:: python

    prices = client.get_all_tickers()

`Get Orderbook Tickers <binance.html#binance.client.Client.get_orderbook_tickers>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Get first bid and ask entry in the order book for all markets.

.. code:: python

    tickers = client.get_orderbook_tickers()

</document_content>
</document>
<document index="30">
<source>docs/overview.rst</source>
<document_content>
Getting Started
===============

Installation
------------

``python-binance`` is available on `PYPI <https://pypi.python.org/pypi/python-binance/>`_.
Install with ``pip``:

.. code:: bash

    pip install python-binance

Register on Binance
-------------------

Firstly `register an account with Binance <https://accounts.binance.com/en/register?ref=10099792>`_.

Generate an API Key
-------------------

To use signed account methods you are required to `create an API Key  <https://www.binance.com/en/support/faq/360002502072>`_.

Initialise the client
---------------------

Pass your API Key and Secret

.. code:: python

    from binance.client import Client
    client = Client(api_key, api_secret)

or for Asynchronous client

.. code:: python

    async def main():

        # initialise the client
        client = await AsyncClient.create(api_key, api_secret)

    if __name__ == "__main__":

        loop = asyncio.get_event_loop()
        loop.run_until_complete(main())

Using the Spot, Futures or Vanilla Options Testnet
--------------------------------------------------

Binance offers a `Spot <https://testnet.binance.vision/>`_,
`Futures <https://testnet.binancefuture.com/>`_
and `Vanilla Options <https://testnet.binanceops.com/>`_ Testnet,
to test interacting with the exchange.

To enable this set the `testnet` parameter passed to the Client to True.

The testnet parameter will also be used by any websocket streams when the client is passed to the BinanceSocketManager.

.. code:: python

    client = Client(api_key, api_secret, testnet=True)

or for Asynchronous client

.. code:: python

    client = await AsyncClient.create(api_key, api_secret, testnet=True)

Using a different TLD
---------------------

If you are interacting with a regional version of Binance which has a different TLD such as `.us` or `.jp' then you
will need to pass this when creating the client, see examples below.

This tld will also be used by any websocket streams when the client is passed to the BinanceSocketManager.

.. code:: python

    client = Client(api_key, api_secret, tld='us')

or for Asynchronous client

.. code:: python

    client = await AsyncClient.create(api_key, api_secret, tld='us')


Making API Calls
----------------

Every method supports the passing of arbitrary parameters via keyword matching those in the `Binance API documentation <https://github.com/binance-exchange/binance-official-api-docs>`_.
These keyword arguments will be sent directly to the relevant endpoint.

Each API method returns a dictionary of the JSON response as per the `Binance API documentation <https://github.com/binance-exchange/binance-official-api-docs>`_.
The docstring of each method in the code references the endpoint it implements.

The Binance API documentation references a `timestamp` parameter, this is generated for you where required.

Some methods have a `recvWindow` parameter for `timing security, see Binance documentation <https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#timing-security>`_.

API Endpoints are rate limited by Binance at 20 requests per second, ask them if you require more.

Async API Calls
---------------

aiohttp is used to handle asyncio REST requests.

Each function available in the normal client is available in the AsyncClient class.

The only difference is to run within an asyncio event loop and await the function like below.

.. code:: python

    import asyncio
    from binance import AsyncClient

    async def main():
        client = await AsyncClient.create()

        # fetch exchange info
        res = await client.get_exchange_info()
        print(json.dumps(res, indent=2))

        await client.close_connection()

    if __name__ == "__main__":

        loop = asyncio.get_event_loop()
        loop.run_until_complete(main())

Read `Async basics for Binance <https://sammchardy.github.io/binance/2021/05/01/async-binance-basics.html>`_
for more information about asynchronous patterns.

API Rate Limit
--------------

Check the `get_exchange_info() <binance.html#binance.client.Client.get_exchange_info>`_ call for up to date rate limits.

At the current time Binance rate limits are:

- 1200 weights per minute
- 10 orders per second
- 100,000 orders per 24hrs

Some calls have a higher weight than others especially if a call returns information about all symbols.
Read the `official Binance documentation <https://github.com/binance-exchange/binance-official-api-docs>`_ for specific information.

On each request Binance returns `X-MBX-USED-WEIGHT-(intervalNum)(intervalLetter)` and `X-MBX-ORDER-COUNT-(intervalNum)`
headers.

Here are examples to access these

Asynchronous example

.. code:: python

    import asyncio
    from binance import AsyncClient

    api_key = '<api_key>'
    api_secret = '<api_secret>'

    async def main():
        client = await AsyncClient.create(api_key, api_secret)

        res = await client.get_exchange_info()
        print(client.response.headers)

        await client.close_connection()

    if __name__ == "__main__":

        loop = asyncio.get_event_loop()
        loop.run_until_complete(main())

Synchronous example


.. code:: python

    from binance import Client

    api_key = '<api_key>'
    api_secret = '<api_secret>'

    def main():
        client = Client(api_key, api_secret)

        res = client.get_exchange_info()
        print(client.response.headers)

    if __name__ == "__main__":
        main()
Requests Settings
-----------------

`python-binance` uses the `requests <http://docs.python-requests.org/en/master/>`_ library.

You can set custom requests parameters for all API calls when creating the client.

.. code:: python

    client = Client("api-key", "api-secret", {"verify": False, "timeout": 20})

You may also pass custom requests parameters through any API call to override default settings or the above settings specify new ones like the example below.

.. code:: python

    # this would result in verify: False and timeout: 5 for the get_all_orders call
    client = Client("api-key", "api-secret", {"verify": False, "timeout": 20})
    client.get_all_orders(symbol='BNBBTC', requests_params={'timeout': 5})

Check out the `requests documentation <http://docs.python-requests.org/en/master/>`_ for all options.

**Proxy Settings**

You can use the Requests Settings method above. For websockets python 3.8+ is required

.. code:: python

    proxies = {
        'http': 'http://10.10.1.10:3128',
        'https': 'http://10.10.1.10:1080'
    }

    # in the Client instantiation
    client = Client("api-key", "api-secret", {'proxies': proxies})

    # or on an individual call
    client.get_all_orders(symbol='BNBBTC', requests_params={'proxies': proxies})

Or set an environment variable for your proxy if required to work across all requests.

An example for Linux environments from the `requests Proxies documentation <http://docs.python-requests.org/en/master/user/advanced/#proxies>`_ is as follows.

.. code-block:: bash

    $ export HTTP_PROXY="http://10.10.1.10:3128"
    $ export HTTPS_PROXY="http://10.10.1.10:1080"

For Windows environments

.. code-block:: bash

    C:\>set HTTP_PROXY=http://10.10.1.10:3128
    C:\>set HTTPS_PROXY=http://10.10.1.10:1080

Logging
-------

python-binance uses the Python logging module. You can enable logging to help debug issues and monitor your application.

Basic Logging Setup
~~~~~~~~~~~~~~~~~~

To enable debug logging, add this at the start of your script:

.. code:: python

    import logging
    logging.basicConfig(level=logging.DEBUG)

Advanced Logging Setup
~~~~~~~~~~~~~~~~~~~~~

For more detailed logging with timestamps and log levels:

.. code:: python

    import logging

    # Configure logging
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    )

.. image:: https://analytics-pixel.appspot.com/UA-111417213-1/github/python-binance/docs/overview?pixel

</document_content>
</document>
<document index="31">
<source>docs/requirements.txt</source>
<document_content>
sphinx==8.1.3
sphinx_rtd_theme==3.0.1
sphinx-copybutton>=0.5.0

</document_content>
</document>
<document index="32">
<source>docs/sub_accounts.rst</source>
<document_content>
Sub Account Endpoints
=====================


`Get Sub Account list <binance.html#binance.client.Client.get_sub_account_list>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    accounts = client.get_sub_account_list()

`Get Sub Account Transfer History <binance.html#binance.client.Client.get_sub_account_transfer_history>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    history = client.get_sub_account_transfer_history(fromEmail='blah@gmail.com', toEmail='foo@gmail.com')

`Get Sub Account Assets <binance.html#binance.client.Client.get_sub_account_assets>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    assets = client.get_sub_account_assets(email='blah@gmail.com')

</document_content>
</document>
<document index="33">
<source>docs/withdraw.rst</source>
<document_content>
Withdraw Endpoints
==================

`Place a withdrawal <binance.html#binance.client.Client.withdraw>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Make sure you enable Withdrawal permissions for your API Key to use this call.

You must have withdrawn to the address through the website and approved the withdrawal via email before you can withdraw using the API.

.. code:: python

    from binance.exceptions import BinanceAPIException
    try:
        # name parameter will be set to the asset value by the client if not passed
        result = client.withdraw(
            coin='ETH',
            address='<eth_address>',
            amount=100)
    except BinanceAPIException as e:
        print(e)
    else:
        print("Success")

    # passing a name parameter
    result = client.withdraw(
        coin='ETH',
        address='<eth_address>',
        amount=100,
        name='Withdraw')

    # if the coin requires a extra tag or name such as XRP or XMR then pass an `addressTag` parameter.
    result = client.withdraw(
        coin='XRP',
        address='<xrp_address>',
        addressTag='<xrp_address_tag>',
        amount=10000)

`Fetch deposit history <binance.html#binance.client.Client.get_deposit_history>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    deposits = client.get_deposit_history()
    btc_deposits = client.get_deposit_history(coin='BTC')


`Fetch withdraw history <binance.html#binance.client.Client.get_withdraw_history>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    withdraws = client.get_withdraw_history()
    btc_withdraws = client.get_withdraw_history(coin='BTC')

`Get deposit address <binance.html#binance.client.Client.get_deposit_address>`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    address = client.get_deposit_address(coin='BTC')

</document_content>
</document>
<document index="34">
<source>examples/binace_socket_manager.py</source>
<document_content>
import os
import sys
import asyncio
import time

root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(root)

from binance import AsyncClient, BinanceSocketManager


async def main():
    client = await AsyncClient.create()
    bm = BinanceSocketManager(client)
    # start any sockets here, i.e a trade socket
    ts = bm.trade_socket("BTCUSDT")
    # then start receiving messages
    async with ts as tscm:
        start_time = time.time()
        while time.time() - start_time < 30:
            try:
                res = await tscm.recv()
                print(res)
            except Exception as e:
                print(f"An error occurred: {e}")
                break

    await client.close_connection()
    print("WebSocket connection closed after 10 seconds.")


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())

</document_content>
</document>
<document index="35">
<source>examples/create_oco_order.py</source>
<document_content>
import os
import sys

root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(root)

from binance.client import Client


api_key = ""  # your api_key here
secret = ""  # your secret here
client = Client(api_key, secret, testnet=True)


# create oco order
def create_oco_order():
    order = client.create_oco_order(
        symbol="LTCUSDT",
        side="SELL",
        quantity=0.3,
        aboveType="LIMIT_MAKER",
        belowType="STOP_LOSS",
        abovePrice=200,
        belowStopPrice=120,
    )
    print(order)
    # {
    #     "orderListId": 9365,
    #     "contingencyType": "OCO",
    #     "listStatusType": "EXEC_STARTED",
    #     "listOrderStatus": "EXECUTING",
    #     "listClientOrderId": "x-HNA2TXFJa9965a63237a3621d3f9df",
    #     "transactionTime": 1733229295138,
    #     "symbol": "LTCUSDT",
    #     "orders": [
    #         {
    #             "symbol": "LTCUSDT",
    #             "orderId": 5836416,
    #             "clientOrderId": "MxXFhDAC8h13wH8X3rXNKG",
    #         },
    #         {
    #             "symbol": "LTCUSDT",
    #             "orderId": 5836417,
    #             "clientOrderId": "a2UltweB2UB1XOdUTqOrzw",
    #         },
    #     ],
    #     "orderReports": [
    #         {
    #             "symbol": "LTCUSDT",
    #             "orderId": 5836416,
    #             "orderListId": 9365,
    #             "clientOrderId": "MxXFhDAC8h13wH8X3rXNKG",
    #             "transactTime": 1733229295138,
    #             "price": "0.00000000",
    #             "origQty": "0.30000000",
    #             "executedQty": "0.00000000",
    #             "origQuoteOrderQty": "0.00000000",
    #             "cummulativeQuoteQty": "0.00000000",
    #             "status": "NEW",
    #             "timeInForce": "GTC",
    #             "type": "STOP_LOSS",
    #             "side": "SELL",
    #             "stopPrice": "120.00000000",
    #             "workingTime": -1,
    #             "selfTradePreventionMode": "EXPIRE_MAKER",
    #         },
    #         {
    #             "symbol": "LTCUSDT",
    #             "orderId": 5836417,
    #             "orderListId": 9365,
    #             "clientOrderId": "a2UltweB2UB1XOdUTqOrzw",
    #             "transactTime": 1733229295138,
    #             "price": "200.00000000",
    #             "origQty": "0.30000000",
    #             "executedQty": "0.00000000",
    #             "origQuoteOrderQty": "0.00000000",
    #             "cummulativeQuoteQty": "0.00000000",
    #             "status": "NEW",
    #             "timeInForce": "GTC",
    #             "type": "LIMIT_MAKER",
    #             "side": "SELL",
    #             "workingTime": 1733229295138,
    #             "selfTradePreventionMode": "EXPIRE_MAKER",
    #         },
    #     ],
    # }


def main():
    create_oco_order()

main()

</document_content>
</document>
<document index="36">
<source>examples/create_order.py</source>
<document_content>
import os
import sys

root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(root)

from binance.client import Client


api_key = ""  # your api_key here
secret = ""  # your secret here
client = Client(api_key, secret, testnet=True)


# create futures order
def create_futures_order():
    order = client.futures_create_order(
        symbol="LTCUSDT",
        side="BUY",
        type="MARKET",
        quantity=0.1,
        positionSide="LONG",  # BOTH for One-way Mode ; LONG or SHORT for Hedge Mode
    )
    print(order)


def create_spot_order():
    order = client.create_order(
        symbol="LTCUSDT", side="BUY", type="LIMIT", price=60, quantity=0.1
    )
    print(order)


def main():
    create_futures_order()
    create_spot_order()


main()

</document_content>
</document>
<document index="37">
<source>examples/create_order_async.py</source>
<document_content>
import os
import sys
import asyncio

root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(root)

from binance import AsyncClient


# create futures order
async def main():
    api_key = ""  # your api_key here
    secret = ""  # your secret here
    client = AsyncClient(api_key, secret, testnet=True)
    order = await client.futures_create_order(
        symbol="LTCUSDT",
        side="BUY",
        type="MARKET",
        quantity=0.1,
        positionSide="LONG",  # BOTH for One-way Mode ; LONG or SHORT for Hedge Mode
    )
    print(order)
    await client.close_connection()


asyncio.run(main())

</document_content>
</document>
<document index="38">
<source>examples/depth_cache_example.py</source>
<document_content>
#!/usr/bin/env python3

import os
import sys

root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(root)

import asyncio
import logging
from binance import AsyncClient
from binance.ws.depthcache import DepthCacheManager 

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

async def main():
    # Initialize the client
    client = await AsyncClient.create()

    # Symbol to monitor
    symbol = 'BTCUSDT'
    
    # Create a depth cache manager instance
    async with DepthCacheManager(
        client=client,
        symbol=symbol,
    ) as dcm:
        logger.info(f"Started depth cache for {symbol}")
        
        # Monitor depth cache updates for 1 minute
        for _ in range(100):  # 6 iterations * 10 seconds = 1 minute
            depth_cache = await dcm.recv()
            if isinstance(depth_cache, dict) and depth_cache.get('e') == 'error':
                logger.error(f"Received depth cache error in callback: {depth_cache}")
                if type == 'BinanceWebsocketClosed':
                    # ignore as attempts to reconnect
                    continue
                break
            
            # Get current bids and asks
            bids = depth_cache.get_bids()[:5]  # Top 5 bids
            asks = depth_cache.get_asks()[:5]  # Top 5 asks
            
            logger.info("Top 5 bids:")
            for bid in bids:
                logger.info(f"Price: {bid[0]}, Quantity: {bid[1]}")
            
            logger.info("Top 5 asks:")
            for ask in asks:
                logger.info(f"Price: {ask[0]}, Quantity: {ask[1]}")
            
            logger.info(f"Last update time: {depth_cache.update_time}")
                
    # Close the client
    await client.close_connection()

if __name__ == '__main__':
    # Run the async example
    asyncio.run(main())

</document_content>
</document>
<document index="39">
<source>examples/depth_cache_threaded_example.py</source>
<document_content>
#!/usr/bin/env python3

import os
import sys

root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(root)

import logging
from binance.ws.depthcache import ThreadedDepthCacheManager

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def main():
        dcm = ThreadedDepthCacheManager()
        dcm.start()
        
        def handle_depth_cache(depth_cache):
            if isinstance(depth_cache, dict) and depth_cache.get('e') == 'error':
                logger.error(f"Received depth cache error in callback: {depth_cache}")
                type = depth_cache.get('type')
                if type == 'BinanceWebsocketClosed':
                    # Automatically attempts to reconnect
                    return
                logger.error(f"Error received - Closing depth cache: {depth_cache}")
                dcm.stop()
                return
                 
            logger.info(f"symbol {depth_cache.symbol}")
            logger.info(depth_cache.get_bids()[:5])
            
        dcm.start_depth_cache(handle_depth_cache, symbol='BNBBTC')
        dcm.join()


if __name__ == "__main__":
   main()

</document_content>
</document>
<document index="40">
<source>examples/save_historical_data.py</source>
<document_content>
import time
import dateparser
import pytz
import json

from datetime import datetime
from binance.client import Client


def date_to_milliseconds(date_str):
    """Convert UTC date to milliseconds

    If using offset strings add "UTC" to date string e.g. "now UTC", "11 hours ago UTC"

    See dateparse docs for formats http://dateparser.readthedocs.io/en/latest/

    :param date_str: date in readable format, i.e. "January 01, 2018", "11 hours ago UTC", "now UTC"
    :type date_str: str
    """
    # get epoch value in UTC
    assert date_str is not None
    epoch = datetime.utcfromtimestamp(0).replace(tzinfo=pytz.utc)
    # parse our date string
    d = dateparser.parse(date_str)
    assert d is not None
    # if the date is not timezone aware apply UTC timezone
    if d.tzinfo is None or d.tzinfo.utcoffset(d) is None:
        d = d.replace(tzinfo=pytz.utc)

    # return the difference in time
    return int((d - epoch).total_seconds() * 1000.0)


def interval_to_milliseconds(interval):
    """Convert a Binance interval string to milliseconds

    :param interval: Binance interval string 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w
    :type interval: str

    :return:
         None if unit not one of m, h, d or w
         None if string not in correct format
         int value of interval in milliseconds
    """
    ms = None
    seconds_per_unit = {"m": 60, "h": 60 * 60, "d": 24 * 60 * 60, "w": 7 * 24 * 60 * 60}

    unit = interval[-1]
    if unit in seconds_per_unit:
        try:
            ms = int(interval[:-1]) * seconds_per_unit[unit] * 1000
        except ValueError:
            pass
    return ms


def get_historical_klines(symbol, interval, start_str, end_str=None):
    """Get Historical Klines from Binance

    See dateparse docs for valid start and end string formats http://dateparser.readthedocs.io/en/latest/

    If using offset strings for dates add "UTC" to date string e.g. "now UTC", "11 hours ago UTC"

    :param symbol: Name of symbol pair e.g BNBBTC
    :type symbol: str
    :param interval: Biannce Kline interval
    :type interval: str
    :param start_str: Start date string in UTC format
    :type start_str: str
    :param end_str: optional - end date string in UTC format
    :type end_str: str

    :return: list of OHLCV values

    """
    # create the Binance client, no need for api key
    client = Client("", "")

    # init our list
    output_data = []

    # setup the max limit
    limit = 500

    # convert interval to useful value in seconds
    timeframe = interval_to_milliseconds(interval)
    assert timeframe is not None
    # convert our date strings to milliseconds
    start_ts = date_to_milliseconds(start_str)

    # if an end time was passed convert it
    end_ts = None
    if end_str:
        end_ts = date_to_milliseconds(end_str)

    idx = 0
    # it can be difficult to know when a symbol was listed on Binance so allow start time to be before list date
    symbol_existed = False
    while True:
        # fetch the klines from start_ts up to max 500 entries or the end_ts if set
        temp_data = client.get_klines(
            symbol=symbol,
            interval=interval,
            limit=limit,
            startTime=start_ts,
            endTime=end_ts,
        )

        # handle the case where our start date is before the symbol pair listed on Binance
        if not symbol_existed and len(temp_data):
            symbol_existed = True

        if symbol_existed:
            # append this loops data to our output data
            output_data += temp_data

            # update our start timestamp using the last value in the array and add the interval timeframe
            start_ts = temp_data[len(temp_data) - 1][0] + timeframe
        else:
            # it wasn't listed yet, increment our start date
            start_ts += timeframe

        idx += 1
        # check if we received less than the required limit and exit the loop
        if len(temp_data) < limit:
            # exit the while loop
            break

        # sleep after every 3rd call to be kind to the API
        if idx % 3 == 0:
            time.sleep(1)

    return output_data


symbol = "ETHBTC"
start = "1 Dec, 2017"
end = "1 Jan, 2018"
interval = Client.KLINE_INTERVAL_30MINUTE

klines = get_historical_klines(symbol, interval, start, end)

# open a file with filename including symbol, interval and start and end converted to milliseconds
with open(
    "Binance_{}_{}_{}-{}.json".format(
        symbol, interval, date_to_milliseconds(start), date_to_milliseconds(end)
    ),
    "w",  # set file write mode
) as f:
    f.write(json.dumps(klines))

</document_content>
</document>
<document index="41">
<source>examples/websocket.py</source>
<document_content>
import os
import sys

root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(root)

from binance import ThreadedWebsocketManager

api_key = "<api_key>"
api_secret = "<api_secret>"


def main():
    symbol = "BNBBTC"

    twm = ThreadedWebsocketManager(api_key=api_key, api_secret=api_secret)
    # start is required to initialise its internal loop
    twm.start()

    def handle_socket_message(msg):
        if msg.get("e") == "error":
            print(f"WebSocket error: {msg.get('m', 'Unknown error')}")

            return

        # Process message normally
        print(msg)

    # Store socket names for potential restart
    sockets = []

    # Start kline socket
    kline_socket = twm.start_kline_socket(callback=handle_socket_message, symbol=symbol)
    sockets.append(("kline", kline_socket, symbol))

    # Start depth socket
    depth_socket = twm.start_depth_socket(callback=handle_socket_message, symbol=symbol)
    sockets.append(("depth", depth_socket, symbol))

    # Start multiplex socket
    streams = ["bnbbtc@miniTicker", "bnbbtc@bookTicker"]
    twm.start_multiplex_socket(callback=handle_socket_message, streams=streams)

    twm.join()


if __name__ == "__main__":
    main()

</document_content>
</document>
<document index="42">
<source>examples/ws_create_order.py</source>
<document_content>
import os
import sys


root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(root)

from binance.client import Client

## create order using websockets sync
## the API is very similar to the REST API


def main():
    api_key = ""  # your api_key here
    secret = ""  # your secret here
    client = Client(api_key, secret, testnet=True)
    order = client.ws_create_order(
        symbol="LTCUSDT",
        side="BUY",
        type="MARKET",
        quantity=0.1,
    )
    print(order["orderId"])


main()

</document_content>
</document>
<document index="43">
<source>examples/ws_create_order_async.py</source>
<document_content>
import os
import sys
import asyncio


root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(root)

from binance import AsyncClient

## create order using websockets async
## the API is very similar to the REST API


async def main():
    api_key = ""  # your api_key here
    secret = ""  # your secret here
    client = AsyncClient(api_key, secret, testnet=True)
    order = await client.ws_create_order(
        symbol="LTCUSDT",
        side="BUY",
        type="MARKET",
        quantity=0.1,
    )
    print(order["orderId"])
    await client.close_connection()


asyncio.run(main())

</document_content>
</document>
<document index="44">
<source>pyproject.toml</source>
<document_content>
[tool.ruff]
preview = true
lint.ignore = ["F722","F841","F821","E402","E501","E902","E713","E741","E714", "E275","E721","E266", "E261"]

[tool.pytest.ini_options]
timeout = 90
timeout_method = "thread"
asyncio_default_fixture_loop_scope = "function"


</document_content>
</document>
<document index="45">
<source>pyrightconfig.json</source>
<document_content>
{
	"include": [
		"binance"
	],
	"reportMissingImports": false,
	"reportMissingModuleSource": false,
	"typeCheckingMode": "basic",
	"reportWildcardImportFromLibrary": false
}

</document_content>
</document>
<document index="46">
<source>pytest.ini</source>
<document_content>

</document_content>
</document>
<document index="47">
<source>requirements.txt</source>
<document_content>
aiohttp
dateparser
pycryptodome
requests
websockets
websockets_proxy; python_version >= '3.8'
</document_content>
</document>
<document index="48">
<source>setup.cfg</source>
<document_content>
[bdist_wheel]
universal = 1

[pep8]
ignore = E501

</document_content>
</document>
<document index="49">
<source>setup.py</source>
<document_content>
#!/usr/bin/env python
from setuptools import setup, find_packages
import codecs
import os
import re

with codecs.open(
    os.path.join(os.path.abspath(os.path.dirname(__file__)), "binance", "__init__.py"),
    "r",
    "latin1",
) as fp:
    try:
        version = re.findall(r'^__version__ = "([^"]+)"\r?$', fp.read(), re.M)[0]
    except IndexError:
        raise RuntimeError("Unable to determine version.")

with open("README.rst", "r") as fh:
    long_description = fh.read()

setup(
    name="python-binance",
    version=version,
    packages=find_packages(exclude=["tests", "examples"]),
    description="Binance REST API python implementation",
    long_description=long_description,
    long_description_content_type="text/x-rst",
    url="https://github.com/sammchardy/python-binance",
    author="Sam McHardy",
    license="MIT",
    author_email="",
    install_requires=[
        "requests",
        "six",
        "dateparser",
        "aiohttp",
        "websockets",
        "pycryptodome",
    ],
    keywords="binance exchange rest api bitcoin ethereum btc eth neo",
    classifiers=[
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.5",
        "Programming Language :: Python :: 3.6",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Programming Language :: Python",
        "Topic :: Software Development :: Libraries :: Python Modules",
    ],
)

</document_content>
</document>
<document index="50">
<source>test-requirements.txt</source>
<document_content>
coverage
pytest
pytest-asyncio
pytest-cov
pytest-xdist
pytest-rerunfailures
pytest-timeout
requests-mock
tox
setuptools
aioresponses
pre-commit
orjson

</document_content>
</document>
<document index="51">
<source>tests/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="52">
<source>tests/conftest.py</source>
<document_content>
import pytest
import pytest_asyncio
from binance.client import Client
from binance.async_client import AsyncClient
import os
import asyncio
import logging

from binance.ws.streams import ThreadedWebsocketManager

proxies = {}
proxy = os.getenv("PROXY")

proxy = "http://188.245.226.105:8911"
if proxy:
    proxies = {"http": proxy, "https": proxy}  # tmp: improve this in the future
else:
    print("No proxy set")

api_key = os.getenv("TEST_API_KEY")
api_secret = os.getenv("TEST_API_SECRET")
futures_api_key = os.getenv("TEST_FUTURES_API_KEY")
futures_api_secret = os.getenv("TEST_FUTURES_API_SECRET")
testnet = os.getenv("TEST_TESTNET", "true").lower() == "true"
api_key = "u4L8MG2DbshTfTzkx2Xm7NfsHHigvafxeC29HrExEmah1P8JhxXkoOu6KntLICUc"
api_secret = "hBZEqhZUUS6YZkk7AIckjJ3iLjrgEFr5CRtFPp5gjzkrHKKC9DAv4OH25PlT6yq5"
testnet = True # only for spot now
demo = True # spot and swap
futures_api_key = "HjhMFvuF1veWQVdUbLIy7TiCYe9fj4W6sEukmddD8TM9kPVRHMK6nS2SdV5mwE5u"
futures_api_secret = "Suu9pWcO9zbvVuc6cSQsVuiiw2DmmA8DgHrUfePF9s2RtaHa0zxK3eAF4MfIk7Pd"


# Configure logging for all tests
@pytest.fixture(autouse=True)
def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
        force=True,  # This ensures the config is applied even if logging was initialized elsewhere
    )
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(
        logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    )
    logging.getLogger().addHandler(console_handler)


@pytest.fixture(scope="function")
def client():
    return Client(api_key, api_secret, {"proxies": proxies}, testnet=testnet)


@pytest.fixture(scope="function")
def liveClient():
    return Client(api_key, api_secret, {"proxies": proxies}, testnet=False)


@pytest.fixture(scope="function")
def futuresClient():
    return Client(
        futures_api_key, futures_api_secret, {"proxies": proxies}, demo=demo
    )


@pytest_asyncio.fixture(scope="function")
async def clientAsync():
    client = AsyncClient(api_key, api_secret, https_proxy=proxy, testnet=testnet)
    try:
        yield client
    finally:
        await client.close_connection()


@pytest_asyncio.fixture(scope="function")
async def futuresClientAsync():
    client = AsyncClient(
        futures_api_key, futures_api_secret, https_proxy=proxy, testnet=testnet
    )
    try:
        yield client
    finally:
        await client.close_connection()


@pytest_asyncio.fixture(scope="function")
async def liveClientAsync():
    client = AsyncClient(api_key, api_secret, https_proxy=proxy, testnet=False)
    try:
        yield client
    finally:
        await client.close_connection()

@pytest.fixture(scope="function")
def manager():
    return ThreadedWebsocketManager(
        api_key="test_key", api_secret="test_secret", https_proxy=proxy, testnet=True
    )

@pytest.fixture(autouse=True, scope="function")
def event_loop():
    """Create new event loop for each test"""
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        yield loop
    finally:
        # Clean up pending tasks
        try:
            pending = asyncio.all_tasks(loop)
            for task in pending:
                task.cancel()
            if pending:
                loop.run_until_complete(asyncio.gather(*pending, return_exceptions=True))
        except Exception:
            pass  # Ignore cleanup errors
        finally:
            loop.close()
            asyncio.set_event_loop(None)


def pytest_addoption(parser):
    parser.addoption(
        "--run-spot", action="store_true", default=True, help="Run margin tests"
    )
    parser.addoption(
        "--run-futures", action="store_true", default=True, help="Run margin tests"
    )
    parser.addoption(
        "--run-margin", action="store_true", default=False, help="Run margin tests"
    )
    parser.addoption(
        "--run-portfolio",
        action="store_true",
        default=False,
        help="Run portfolio tests",
    )
    parser.addoption(
        "--run-gift-card",
        action="store_true",
        default=False,
        help="Run gift card tests",
    )


def pytest_configure(config):
    config.addinivalue_line("markers", "spot: mark a test as part of the spot tests")
    config.addinivalue_line(
        "markers", "futures: mark a test as part of the futures tests"
    )
    config.addinivalue_line(
        "markers", "margin: mark a test as part of the margin tests"
    )
    config.addinivalue_line(
        "markers", "portfolio: mark a test as part of the portfolio tests"
    )
    config.addinivalue_line(
        "markers", "gift_card: mark a test as part of the gift card tests"
    )


def pytest_collection_modifyitems(config, items):
    skip_spot = pytest.mark.skip(reason="need --run-spot option to run")
    skip_futures = pytest.mark.skip(reason="need --run-futures option to run")
    skip_margin = pytest.mark.skip(reason="need --run-margin option to run")
    skip_portfolio = pytest.mark.skip(reason="need --run-portfolio option to run")
    skip_gift_card = pytest.mark.skip(reason="need --run-gift-card option to run")
    for item in items:
        if "spot" in item.keywords and not config.getoption("--run-spot"):
            item.add_marker(skip_spot)
        if "futures" in item.keywords and not config.getoption("--run-futures"):
            item.add_marker(skip_futures)
        if "margin" in item.keywords and not config.getoption("--run-margin"):
            item.add_marker(skip_margin)
        if "portfolio" in item.keywords and not config.getoption("--run-portfolio"):
            item.add_marker(skip_portfolio)
        if "gift_card" in item.keywords and not config.getoption("--run-gift-card"):
            item.add_marker(skip_gift_card)


def call_method_and_assert_uri_contains(client, method_name, expected_string, *args, **kwargs):
    """
    Helper function to test that a client method calls the expected URI.
    
    Args:
        client: The client instance to test
        method_name: Name of the method to call (as string)
        expected_string: String that should be present in the URI
        *args, **kwargs: Arguments to pass to the client method
    
    Returns:
        The result of the method call
    """
    from unittest.mock import patch
    
    with patch.object(client, '_request', wraps=client._request) as mock_request:
        # Get the method from the client and call it
        method = getattr(client, method_name)
        result = method(*args, **kwargs)
        
        # Assert that _request was called
        mock_request.assert_called_once()
        
        # Get the arguments passed to _request
        args_passed, kwargs_passed = mock_request.call_args
        
        # The second argument is the URI
        uri = args_passed[1]
        
        # Assert that the URL contains the expected string
        assert expected_string in uri, f"Expected '{expected_string}' in URL, but got: {uri}"
        
        return result

</document_content>
</document>
<document index="53">
<source>tests/test_api_request.py</source>
<document_content>
from binance.client import Client
from binance.exceptions import BinanceAPIException, BinanceRequestException
import pytest
import requests_mock
import os

proxies = {}
proxy = os.getenv("PROXY")
if proxy:
    proxies = {"http": proxy, "https": proxy}  # tmp: improve this in the future
else:
    print("No proxy set")

client = Client("api_key", "api_secret", {"proxies": proxies})


def test_invalid_json():
    """Test Invalid response Exception"""

    with pytest.raises(BinanceRequestException):
        with requests_mock.mock() as m:
            m.get(
                "https://www.binance.com/exchange-api/v1/public/asset-service/product/get-products?includeEtf=true",
                text="<head></html>",
            )
            m.get(
                "https://www.binance.com/bapi/asset/v2/public/asset-service/product/get-products?includeEtf=true",
                text="<head></html>",
            )
            client.get_products()


def test_api_exception():
    """Test API response Exception"""

    with pytest.raises(BinanceAPIException):
        with requests_mock.mock() as m:
            json_obj = {"code": 1002, "msg": "Invalid API call"}
            m.get("https://api.binance.com/api/v3/time", json=json_obj, status_code=400)
            client.get_server_time()


def test_api_exception_invalid_json():
    """Test API response Exception"""

    with pytest.raises(BinanceAPIException):
        with requests_mock.mock() as m:
            not_json_str = "<html><body>Error</body></html>"
            m.get(
                "https://api.binance.com/api/v3/time",
                text=not_json_str,
                status_code=400,
            )
            client.get_server_time()

</document_content>
</document>
<document index="54">
<source>tests/test_async_client_gift_card copy.py</source>
<document_content>
import pytest

pytestmark = [pytest.mark.gift_card, pytest.mark.asyncio]


async def test_gift_card_fetch_token_limit(liveClientAsync):
    await liveClientAsync.gift_card_fetch_token_limit(baseToken="BUSD")


async def test_gift_card_fetch_rsa_public_key(liveClientAsync):
    await liveClientAsync.gift_card_fetch_rsa_public_key()


async def test_gift_card_create_verify_and_redeem(liveClientAsync):
    # create a gift card
    response = await liveClientAsync.gift_card_create(token="USDT", amount=1.0)
    assert response["data"]["referenceNo"] is not None
    assert response["data"]["code"] is not None
    # verify the gift card
    response = await liveClientAsync.gift_card_verify(
        referenceNo=response["data"]["referenceNo"]
    )
    assert response["data"]["valid"] == "SUCCESS"
    # redeem the gift card
    redeem_response = await liveClientAsync.gift_card_redeem(
        code=response["data"]["code"],
    )
    assert response["data"]["referenceNo"] == redeem_response["data"]["referenceNo"]


async def test_gift_card_create_dual_token_and_redeem(liveClientAsync):
    response = await liveClientAsync.gift_card_create_dual_token(
        baseToken="USDT", faceToken="BNB", baseTokenAmount=1.0
    )
    assert response["data"]["referenceNo"] is not None
    assert response["data"]["code"] is not None
    # verify the gift card
    response = await liveClientAsync.gift_card_verify(
        referenceNo=response["data"]["referenceNo"]
    )
    assert response["data"]["valid"] == "SUCCESS"
    # redeem the gift card
    redeem_response = await liveClientAsync.gift_card_redeem(
        code=response["data"]["code"],
    )
    assert response["data"]["referenceNo"] == redeem_response["data"]["referenceNo"]

</document_content>
</document>
<document index="55">
<source>tests/test_async_client_options.py</source>
<document_content>
import pytest
import sys

pytestmark = [pytest.mark.options, pytest.mark.asyncio, pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")]

@pytest.fixture
def options_symbol(liveClient):
    prices = liveClient.options_price()
    return prices[0]["symbol"]

async def test_options_ping(liveClientAsync):
    await liveClientAsync.options_ping()

async def test_options_time(liveClientAsync):
    await liveClientAsync.options_time()

@pytest.mark.skip(reason="Not implemented")
async def test_options_info(liveClientAsync):
    await liveClientAsync.options_info()

async def test_options_exchange_info(liveClientAsync):
    await liveClientAsync.options_exchange_info()

async def test_options_index_price(liveClientAsync):
    await liveClientAsync.options_index_price(underlying="BTCUSDT")

async def test_options_price(liveClientAsync):
    prices = await liveClientAsync.options_price()

async def test_options_mark_price(liveClientAsync):
    await liveClientAsync.options_mark_price()

async def test_options_order_book(liveClientAsync, options_symbol):
    await liveClientAsync.options_order_book(symbol=options_symbol)

async def test_options_klines(liveClientAsync, options_symbol):
    await liveClientAsync.options_klines(symbol=options_symbol, interval="1m")

async def test_options_recent_trades(liveClientAsync, options_symbol):
    await liveClientAsync.options_recent_trades(symbol=options_symbol)

async def test_options_historical_trades(liveClientAsync, options_symbol):
    await liveClientAsync.options_historical_trades(symbol=options_symbol)

# Account and trading interface endpoints

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_account_info(liveClientAsync):
    await liveClientAsync.options_account_info()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_funds_transfer(liveClientAsync):
    await liveClientAsync.options_funds_transfer()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_positions(liveClientAsync):
    await liveClientAsync.options_positions()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_bill(liveClientAsync):
    await liveClientAsync.options_bill()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_place_order(liveClientAsync):
    await liveClientAsync.options_place_order()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_test_options_place_batch_order(liveClientAsync):
    await liveClientAsync.test_options_place_batch_order()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_cancel_order(liveClientAsync):
    await liveClientAsync.options_cancel_order()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_cancel_batch_order(liveClientAsync):
    await liveClientAsync.options_cancel_batch_order()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_cancel_all_orders(liveClientAsync):
    await liveClientAsync.options_cancel_all_orders()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_query_order(liveClientAsync):
    await liveClientAsync.options_query_order()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_query_pending_orders(liveClientAsync):
    await liveClientAsync.options_query_pending_orders()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_query_order_history(liveClientAsync):
    await liveClientAsync.options_query_order_history()

@pytest.mark.skip(reason="No sandbox to environmnet to test")
async def test_options_user_trades(liveClientAsync):
    await liveClientAsync.options_user_trades()

</document_content>
</document>
<document index="56">
<source>tests/test_async_client_ws_api.py</source>
<document_content>
import pytest
import sys
pytestmark = [pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+"), pytest.mark.asyncio()]

async def test_ws_get_order_book(clientAsync):
    await clientAsync.ws_get_order_book(symbol="BTCUSDT")

async def test_ws_get_recent_trades(clientAsync):
    await clientAsync.ws_get_recent_trades(symbol="BTCUSDT")

async def test_ws_get_historical_trades(clientAsync):
    await clientAsync.ws_get_historical_trades(symbol="BTCUSDT")

async def test_ws_get_aggregate_trades(clientAsync):
    await clientAsync.ws_get_aggregate_trades(symbol="BTCUSDT")

async def test_ws_get_klines(clientAsync):
    await clientAsync.ws_get_klines(symbol="BTCUSDT", interval="1m")

async def test_ws_get_uiKlines(clientAsync):
    await clientAsync.ws_get_uiKlines(symbol="BTCUSDT", interval="1m")

async def test_ws_get_avg_price(clientAsync):
    await clientAsync.ws_get_avg_price(symbol="BTCUSDT")

async def test_ws_get_ticker(clientAsync):
    await clientAsync.ws_get_ticker(symbol="BTCUSDT")

async def test_ws_get_trading_day_ticker(clientAsync):
    await clientAsync.ws_get_trading_day_ticker(symbol="BTCUSDT")

async def test_ws_get_symbol_ticker_window(clientAsync):
    await clientAsync.ws_get_symbol_ticker_window(symbol="BTCUSDT")

async def test_ws_get_symbol_ticker(clientAsync):
    await clientAsync.ws_get_symbol_ticker(symbol="BTCUSDT")

async def test_ws_get_orderbook_ticker(clientAsync):
    await clientAsync.ws_get_orderbook_ticker(symbol="BTCUSDT")

async def test_ws_ping(clientAsync):
    await clientAsync.ws_ping()

async def test_ws_get_time(clientAsync):
    await clientAsync.ws_get_time()

async def test_ws_get_exchange_info(clientAsync):
    await clientAsync.ws_get_exchange_info(symbol="BTCUSDT")

</document_content>
</document>
<document index="57">
<source>tests/test_async_client_ws_futures_requests.py</source>
<document_content>
import asyncio
import pytest
import sys

from binance.exceptions import BinanceAPIException, BinanceWebsocketUnableToConnect
from .test_get_order_book import assert_ob
from .test_order import assert_contract_order

try:
    from unittest.mock import patch  # Python 3.8+
except ImportError:
    from asynctest import patch  # Python 3.7


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_get_order_book(futuresClientAsync):
    orderbook = await futuresClientAsync.ws_futures_get_order_book(symbol="BTCUSDT")
    assert_ob(orderbook)


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_concurrent_ws_futures_get_order_book(futuresClientAsync):
    symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT", "ADAUSDT"]

    async def get_orderbook(symbol):
        orderbook = await futuresClientAsync.ws_futures_get_order_book(symbol=symbol)
        assert_ob(orderbook)
        return orderbook

    tasks = [get_orderbook(symbol) for symbol in symbols]
    results = await asyncio.gather(*tasks)

    # Verify results
    assert len(results) == len(symbols)
    for orderbook in results:
        assert_ob(orderbook)


@pytest.mark.asyncio()
async def test_bad_request(futuresClientAsync):
    with pytest.raises(BinanceAPIException):
        await futuresClientAsync.ws_futures_get_order_book()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_get_all_tickers(futuresClientAsync):
    await futuresClientAsync.ws_futures_get_all_tickers()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_get_order_book_ticker(futuresClientAsync):
    await futuresClientAsync.ws_futures_get_order_book_ticker()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_create_get_edit_cancel_order_with_orjson(futuresClientAsync):
    if 'orjson' not in sys.modules:
        raise ImportError("orjson is not available")
    
    ticker = await futuresClientAsync.ws_futures_get_order_book_ticker(symbol="LTCUSDT")
    positions = await futuresClientAsync.ws_futures_v2_account_position(
        symbol="LTCUSDT"
    )
    order = await futuresClientAsync.ws_futures_create_order(
        symbol=ticker["symbol"],
        side="SELL",
        positionSide=positions[0]["positionSide"],
        type="LIMIT",
        timeInForce="GTC",
        quantity=0.1,
        price=str(float(ticker["bidPrice"]) + 5),
    )
    assert_contract_order(futuresClientAsync, order)
    order = await futuresClientAsync.ws_futures_edit_order(
        orderid=order["orderId"],
        symbol=order["symbol"],
        quantity=0.11,
        side=order["side"],
        price=order["price"],
    )
    assert_contract_order(futuresClientAsync, order)
    order = await futuresClientAsync.ws_futures_get_order(
        symbol="LTCUSDT", orderid=order["orderId"]
    )
    assert_contract_order(futuresClientAsync, order)
    order = await futuresClientAsync.ws_futures_cancel_order(
        orderid=order["orderId"], symbol=order["symbol"]
    )

@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_create_get_edit_cancel_order_without_orjson(futuresClientAsync):
    with patch.dict('sys.modules', {'orjson': None}):
        ticker = await futuresClientAsync.ws_futures_get_order_book_ticker(symbol="LTCUSDT")
        positions = await futuresClientAsync.ws_futures_v2_account_position(
            symbol="LTCUSDT"
        )
        order = await futuresClientAsync.ws_futures_create_order(
            symbol=ticker["symbol"],
            side="SELL",
            positionSide=positions[0]["positionSide"],
            type="LIMIT",
            timeInForce="GTC",
            quantity=0.1,
            price=str(float(ticker["bidPrice"]) + 5),
        )
        assert_contract_order(futuresClientAsync, order)
        order = await futuresClientAsync.ws_futures_edit_order(
            orderid=order["orderId"],
            symbol=order["symbol"],
            quantity=0.11,
            side=order["side"],
            price=order["price"],
        )
        assert_contract_order(futuresClientAsync, order)
        order = await futuresClientAsync.ws_futures_get_order(
            symbol="LTCUSDT", orderid=order["orderId"]
        )
        assert_contract_order(futuresClientAsync, order)
        order = await futuresClientAsync.ws_futures_cancel_order(
            orderid=order["orderId"], symbol=order["symbol"]
        )


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_v2_account_position(futuresClientAsync):
    await futuresClientAsync.ws_futures_v2_account_position()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_account_position(futuresClientAsync):
    await futuresClientAsync.ws_futures_account_position()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_v2_account_balance(futuresClientAsync):
    await futuresClientAsync.ws_futures_v2_account_balance()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_account_balance(futuresClientAsync):
    await futuresClientAsync.ws_futures_account_balance()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_v2_account_status(futuresClientAsync):
    await futuresClientAsync.ws_futures_v2_account_status()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_futures_account_status(futuresClientAsync):
    await futuresClientAsync.ws_futures_account_status()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_ws_futures_fail_to_connect(futuresClientAsync):
    # Close any existing connection first
    await futuresClientAsync.close_connection()
    
    # Mock the WebSocket API's connect method to raise an exception
    with patch.object(futuresClientAsync.ws_future, 'connect', side_effect=ConnectionError("Simulated connection failure")):
        with pytest.raises(BinanceWebsocketUnableToConnect):
            await futuresClientAsync.ws_futures_get_order_book(symbol="BTCUSDT")

</document_content>
</document>
<document index="58">
<source>tests/test_client.py</source>
<document_content>
import sys
import pytest
from binance.client import Client
from binance.exceptions import BinanceAPIException, BinanceRequestException
from .conftest import proxies, api_key, api_secret, testnet, call_method_and_assert_uri_contains


def test_client_initialization(client):
    assert client.API_KEY is not None
    assert client.API_SECRET is not None


@pytest.mark.skip(reason="Endpoint not documented")
def test_get_products(client):
    client.get_products()


def test_get_exchange_info(client):
    client.get_exchange_info()


def test_get_symbol_info(client):
    client.get_symbol_info("BTCUSDT")


def test_ping(client):
    call_method_and_assert_uri_contains(client, 'ping', '/v3/')



def test_get_server_time(client):
    client.get_server_time()


def test_get_all_tickers(client):
    client.get_all_tickers()


def test_get_orderbook_tickers(client):
    client.get_orderbook_tickers()


def test_get_order_book(client):
    client.get_order_book(symbol="BTCUSDT")


def test_get_recent_trades(client):
    client.get_recent_trades(symbol="BTCUSDT")


def test_get_historical_trades(client):
    client.get_historical_trades(symbol="BTCUSDT")


def test_get_aggregate_trades(client):
    client.get_aggregate_trades(symbol="BTCUSDT")


def test_get_klines(client):
    client.get_klines(symbol="BTCUSDT", interval="1d")

def test_get_ui_klines(client):
    client.get_ui_klines(symbol="BTCUSDT", interval="1d")

def test_get_avg_price(client):
    client.get_avg_price(symbol="BTCUSDT")


def test_get_ticker(client):
    client.get_ticker(symbol="BTCUSDT")


def test_get_symbol_ticker(client):
    client.get_symbol_ticker(symbol="BTCUSDT")


def test_get_orderbook_ticker(client):
    call_method_and_assert_uri_contains(client, 'get_orderbook_ticker', '/v3/', symbol="BTCUSDT")


def test_get_account(client):
    client.get_account()


def test_get_asset_balance(client):
    client.get_asset_balance(asset="BTC")


def test_get_asset_balance_no_asset_provided(client):
    client.get_asset_balance()


def test_get_my_trades(client):
    client.get_my_trades(symbol="BTCUSDT")


def test_get_system_status(client):
    client.get_system_status()


# User Stream Endpoints


def test_stream_get_listen_key_and_close(client):
    listen_key = client.stream_get_listen_key()
    client.stream_close(listen_key)


# Quoting interface endpoints
@pytest.mark.skip(reason="Endpoint not working on testnet")
def test_get_account_status(client):
    client.get_account_status()


@pytest.mark.skip(reason="Endpoint not working on testnet")
def test_get_account_api_trading_status(client):
    client.get_account_api_trading_status()


@pytest.mark.skip(reason="Endpoint not working on testnet")
def test_get_account_api_permissions(client):
    client.get_account_api_permissions()


@pytest.mark.skip(reason="Endpoint not working on testnet")
def test_get_dust_assets(client):
    client.get_dust_assets()


#########################
# Websocket API Requests #
#########################


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_order_book(client):
    client.ws_get_order_book(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_recent_trades(client):
    client.ws_get_recent_trades(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_historical_trades(client):
    client.ws_get_historical_trades(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_aggregate_trades(client):
    client.ws_get_aggregate_trades(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_klines(client):
    client.ws_get_klines(symbol="BTCUSDT", interval="1m")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_uiKlines(client):
    client.ws_get_uiKlines(symbol="BTCUSDT", interval="1m")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_avg_price(client):
    client.ws_get_avg_price(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_ticker(client):
    ticker = client.ws_get_ticker(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_trading_day_ticker(client):
    client.ws_get_trading_day_ticker(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_symbol_ticker_window(client):
    client.ws_get_symbol_ticker_window(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_symbol_ticker(client):
    client.ws_get_symbol_ticker(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_orderbook_ticker(client):
    client.ws_get_orderbook_ticker(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_ping(client):
    client.ws_ping()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_time(client):
    client.ws_get_time()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_get_exchange_info(client):
    client.ws_get_exchange_info(symbol="BTCUSDT")


def test_time_unit_microseconds():
    micro_client = Client(
        api_key,
        api_secret,
        {"proxies": proxies},
        testnet=testnet,
        time_unit="MICROSECOND",
    )
    micro_trades = micro_client.get_recent_trades(symbol="BTCUSDT")
    assert len(str(micro_trades[0]["time"])) >= 16, (
        "Time should be in microseconds (16+ digits)"
    )


def test_time_unit_milloseconds():
    milli_client = Client(
        api_key,
        api_secret,
        {"proxies": proxies},
        testnet=testnet,
        time_unit="MILLISECOND",
    )
    milli_trades = milli_client.get_recent_trades(symbol="BTCUSDT")
    assert len(str(milli_trades[0]["time"])) == 13, (
        "Time should be in milliseconds (13 digits)"
    )


def test_handle_response(client):
    # Test successful JSON response
    mock_response = type('Response', (), {
        'status_code': 200,
        'text': '{"key": "value"}',
        'json': lambda: {"key": "value"}
    })
    assert client._handle_response(mock_response) == {"key": "value"}

    # Test empty response
    mock_empty_response = type('Response', (), {
        'status_code': 200,
        'text': ''
    })
    assert client._handle_response(mock_empty_response) == {}

    # Test invalid JSON response
    mock_invalid_response = type('Response', (), {
        'status_code': 200,
        'text': 'invalid json',
        'json': lambda: exec('raise ValueError()')
    })
    with pytest.raises(BinanceRequestException):
        client._handle_response(mock_invalid_response)

    # Test error status code
    mock_error_response = type('Response', (), {
        'status_code': 400,
        'text': 'error message'
    })
    with pytest.raises(BinanceAPIException):
        client._handle_response(mock_error_response)

</document_content>
</document>
<document index="59">
<source>tests/test_client_gift_card.py</source>
<document_content>
import pytest
import requests_mock

pytestmark = pytest.mark.gift_card


def test_mock_gift_card_fetch_token_limit(liveClient):
    """Test gift card token limit endpoint with mocked response"""
    expected_response = {
        "code": "000000",
        "message": "success",
        "data": [{"coin": "BNB", "fromMin": "0.01", "fromMax": "1"}],
        "success": True,
    }

    with requests_mock.mock() as m:
        m.get(
            "https://api.binance.com/sapi/v1/giftcard/buyCode/token-limit",
            json=expected_response,
        )

        response = liveClient.gift_card_fetch_token_limit(baseToken="BUSD")
        assert response == expected_response


def test_gift_card_fetch_token_limit(liveClient):
    liveClient.gift_card_fetch_token_limit(baseToken="BUSD")


def test_gift_card_fetch_rsa_public_key(liveClient):
    liveClient.gift_card_fetch_rsa_public_key()


def test_gift_card_create_verify_and_redeem(liveClient):
    # create a gift card
    response = liveClient.gift_card_create(token="USDT", amount=1.0)
    assert response["data"]["referenceNo"] is not None
    assert response["data"]["code"] is not None
    # verify the gift card
    response = liveClient.gift_card_verify(referenceNo=response["data"]["referenceNo"])
    assert response["data"]["valid"] == "SUCCESS"
    # redeem the gift card
    redeem_response = liveClient.gift_card_redeem(
        code=response["data"]["code"],
    )
    assert response["data"]["referenceNo"] == redeem_response["data"]["referenceNo"]


def test_gift_card_create_dual_token_and_redeem(liveClient):
    response = liveClient.gift_card_create_dual_token(
        baseToken="USDT", faceToken="BNB", baseTokenAmount=1.0
    )
    assert response["data"]["referenceNo"] is not None
    assert response["data"]["code"] is not None
    # verify the gift card
    response = liveClient.gift_card_verify(referenceNo=response["data"]["referenceNo"])
    assert response["data"]["valid"] == "SUCCESS"
    # redeem the gift card
    redeem_response = liveClient.gift_card_redeem(
        code=response["data"]["code"],
    )
    assert response["data"]["referenceNo"] == redeem_response["data"]["referenceNo"]

</document_content>
</document>
<document index="60">
<source>tests/test_client_options.py</source>
<document_content>
import pytest
import sys


pytestmark = [pytest.mark.options, pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")]


@pytest.fixture
def options_symbol(liveClient):
    prices = liveClient.options_price()
    return prices[0]["symbol"]


def test_options_ping(liveClient):
    liveClient.options_ping()


def test_options_time(liveClient):
    liveClient.options_time()


@pytest.mark.skip(reason="Not implemented")
def test_options_info(liveClient):
    liveClient.options_info()


def test_options_exchange_info(liveClient):
    liveClient.options_exchange_info()


def test_options_index_price(liveClient):
    liveClient.options_index_price(underlying="BTCUSDT")


def test_options_price(liveClient):
    liveClient.options_price()


def test_options_mark_price(liveClient):
    liveClient.options_mark_price()


def test_options_order_book(liveClient, options_symbol):
    liveClient.options_order_book(symbol=options_symbol)


def test_options_klines(liveClient, options_symbol):
    liveClient.options_klines(symbol=options_symbol, interval="1m")


def test_options_recent_trades(liveClient, options_symbol):
    liveClient.options_recent_trades(symbol=options_symbol)


def test_options_historical_trades(liveClient, options_symbol):
    liveClient.options_historical_trades(symbol=options_symbol)


# Account and trading interface endpoints


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_account_info(liveClient):
    liveClient.options_account_info()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_funds_transfer(liveClient):
    liveClient.options_funds_transfer()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_positions(liveClient):
    liveClient.options_positions()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_bill(liveClient):
    liveClient.options_bill()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_place_order(liveClient):
    liveClient.options_place_order()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_test_options_place_batch_order(liveClient):
    liveClient.test_options_place_batch_order()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_cancel_order(liveClient):
    liveClient.options_cancel_order()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_cancel_batch_order(liveClient):
    liveClient.options_cancel_batch_order()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_cancel_all_orders(liveClient):
    liveClient.options_cancel_all_orders()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_query_order(liveClient):
    liveClient.options_query_order()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_query_pending_orders(liveClient):
    liveClient.options_query_pending_orders()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_query_order_history(liveClient):
    liveClient.options_query_order_history()


@pytest.mark.skip(reason="No sandbox to environmnet to test")
def test_options_user_trades(liveClient):
    liveClient.options_user_trades()

</document_content>
</document>
<document index="61">
<source>tests/test_client_portfolio.py</source>
<document_content>
import pytest

# Apply the 'portfolio' mark to all tests in this file
pytestmark = pytest.mark.portfolio


def test_papi_get_balance(client):
    client.papi_get_balance()


def test_papi_get_account(client):
    client.papi_get_account()


def test_papi_get_margin_max_borrowable(client):
    client.papi_get_margin_max_borrowable()


def test_papi_get_margin_max_withdraw(client):
    client.papi_get_margin_max_withdraw()


def test_papi_get_um_position_risk(client):
    client.papi_get_um_position_risk()


def test_papi_get_cm_position_risk(client):
    client.papi_get_cm_position_risk()


def test_papi_set_um_leverage(client):
    client.papi_set_um_leverage()


def test_papi_set_cm_leverage(client):
    client.papi_set_cm_leverage()


def test_papi_change_um_position_side_dual(client):
    client.papi_change_um_position_side_dual()


def test_papi_get_um_position_side_dual(client):
    client.papi_get_um_position_side_dual()


def test_papi_get_cm_position_side_dual(client):
    client.papi_get_cm_position_side_dual()


def test_papi_get_um_leverage_bracket(client):
    client.papi_get_um_leverage_bracket()


def test_papi_get_cm_leverage_bracket(client):
    client.papi_get_cm_leverage_bracket()


def test_papi_get_um_api_trading_status(client):
    client.papi_get_um_api_trading_status()


def test_papi_get_um_comission_rate(client):
    client.papi_get_um_comission_rate()


def test_papi_get_cm_comission_rate(client):
    client.papi_get_cm_comission_rate()


def test_papi_get_margin_margin_loan(client):
    client.papi_get_margin_margin_loan()


def test_papi_get_margin_repay_loan(client):
    client.papi_get_margin_repay_loan()


def test_papi_get_repay_futures_switch(client):
    client.papi_get_repay_futures_switch()


def test_papi_repay_futures_switch(client):
    client.papi_repay_futures_switch()


def test_papi_get_margin_interest_history(client):
    client.papi_get_margin_interest_history()


def test_papi_repay_futures_negative_balance(client):
    client.papi_repay_futures_negative_balance()


def test_papi_get_portfolio_interest_history(client):
    client.papi_get_portfolio_interest_history()


def test_papi_fund_auto_collection(client):
    client.papi_fund_auto_collection()


def test_papi_fund_asset_collection(client):
    client.papi_fund_asset_collection()


def test_papi_bnb_transfer(client):
    client.papi_bnb_transfer()


def test_papi_get_um_income_history(client):
    client.papi_get_um_income_history()


def test_papi_get_cm_income_history(client):
    client.papi_get_cm_income_history()


def test_papi_get_um_account(client):
    client.papi_get_um_account()


def test_papi_get_um_account_v2(client):
    client.papi_get_um_account_v2()


def test_papi_get_cm_account(client):
    client.papi_get_cm_account()


def test_papi_get_um_account_config(client):
    client.papi_get_um_account_config()


def test_papi_get_um_symbol_config(client):
    client.papi_get_um_symbol_config()


def test_papi_get_um_trade_asyn(client):
    client.papi_get_um_trade_asyn()


def test_papi_get_um_trade_asyn_id(client):
    client.papi_get_um_trade_asyn_id()


def test_papi_get_um_order_asyn(client):
    client.papi_get_um_order_asyn()


def test_papi_get_um_order_asyn_id(client):
    client.papi_get_um_order_asyn_id()


def test_papi_get_um_income_asyn(client):
    client.papi_get_um_income_asyn()


def test_papi_get_um_income_asyn_id(client):
    client.papi_get_um_income_asyn_id()


# Public papi endpoints


def test_papi_ping(client):
    client.papi_ping()


# Trade papi endpoints


def test_papi_create_um_order(client):
    client.papi_create_um_order()


def test_papi_create_um_conditional_order(client):
    client.papi_create_um_conditional_order()


def test_papi_create_cm_order(client):
    client.papi_create_cm_order()


def test_papi_create_cm_conditional_order(client):
    client.papi_create_cm_conditional_order()


def test_papi_create_margin_order(client):
    client.papi_create_margin_order()


def test_papi_margin_loan(client):
    client.papi_margin_loan()


def test_papi_repay_loan(client):
    client.papi_repay_loan()


def test_papi_margin_order_oco(client):
    client.papi_margin_order_oco()


def test_papi_cancel_um_order(client):
    client.papi_cancel_um_order()


def test_papi_cancel_um_all_open_orders(client):
    client.papi_cancel_um_all_open_orders()


def test_papi_cancel_um_conditional_order(client):
    client.papi_cancel_um_conditional_order()


def test_papi_cancel_um_conditional_all_open_orders(client):
    client.papi_cancel_um_conditional_all_open_orders()


def test_papi_cancel_cm_order(client):
    client.papi_cancel_cm_order()


def test_papi_cancel_cm_all_open_orders(client):
    client.papi_cancel_cm_all_open_orders()


def test_papi_cancel_cm_conditional_order(client):
    client.papi_cancel_cm_conditional_order()


def test_papi_cancel_cm_conditional_all_open_orders(client):
    client.papi_cancel_cm_conditional_all_open_orders()


def test_papi_cancel_margin_order(client):
    client.papi_cancel_margin_order()


def test_papi_cancel_margin_order_list(client):
    client.papi_cancel_margin_order_list()


def test_papi_cancel_margin_all_open_orders(client):
    client.papi_cancel_margin_all_open_orders()


def test_papi_modify_um_order(client):
    client.papi_modify_um_order()


def test_papi_modify_cm_order(client):
    client.papi_modify_cm_order()


def test_papi_get_um_order(client):
    client.papi_get_um_order()


def test_papi_get_um_all_orders(client):
    client.papi_get_um_all_orders()


def test_papi_get_um_open_order(client):
    client.papi_get_um_open_order()


def test_papi_get_um_open_orders(client):
    client.papi_get_um_open_orders()


def test_papi_get_um_conditional_all_orders(client):
    client.papi_get_um_conditional_all_orders()


def test_papi_get_um_conditional_open_orders(client):
    client.papi_get_um_conditional_open_orders()


def test_papi_get_um_conditional_open_order(client):
    client.papi_get_um_conditional_open_order()


def test_papi_get_um_conditional_order_history(client):
    client.papi_get_um_conditional_order_history()


def test_papi_get_cm_order(client):
    client.papi_get_cm_order()


def test_papi_get_cm_all_orders(client):
    client.papi_get_cm_all_orders()


def test_papi_get_cm_open_order(client):
    client.papi_get_cm_open_order()


def test_papi_get_cm_open_orders(client):
    client.papi_get_cm_open_orders()


def test_papi_get_cm_conditional_all_orders(client):
    client.papi_get_cm_conditional_all_orders()


def test_papi_get_cm_conditional_open_orders(client):
    client.papi_get_cm_conditional_open_orders()


def test_papi_get_cm_conditional_open_order(client):
    client.papi_get_cm_conditional_open_order()


def test_papi_get_cm_conditional_order_history(client):
    client.papi_get_cm_conditional_order_history()


def test_papi_get_um_force_orders(client):
    client.papi_get_um_force_orders()


def test_papi_get_cm_force_orders(client):
    client.papi_get_cm_force_orders()


def test_papi_get_um_order_amendment(client):
    client.papi_get_um_order_amendment()


def test_papi_get_cm_order_amendment(client):
    client.papi_get_cm_order_amendment()


def test_papi_get_margin_force_orders(client):
    client.papi_get_margin_force_orders()


def test_papi_get_um_user_trades(client):
    client.papi_get_um_user_trades()


def test_papi_get_cm_user_trades(client):
    client.papi_get_cm_user_trades()


def test_papi_get_um_adl_quantile(client):
    client.papi_get_um_adl_quantile()


def test_papi_get_cm_adl_quantile(client):
    client.papi_get_cm_adl_quantile()


def test_papi_set_um_fee_burn(client):
    client.papi_set_um_fee_burn()


def test_papi_get_um_fee_burn(client):
    client.papi_get_um_fee_burn()


def test_papi_get_margin_order(client):
    client.papi_get_margin_order()


def test_papi_get_margin_open_orders(client):
    client.papi_get_margin_open_orders()


def test_papi_get_margin_all_orders(client):
    client.papi_get_margin_all_orders()


def test_papi_get_margin_order_list(client):
    client.papi_get_margin_order_list()


def test_papi_get_margin_all_order_list(client):
    client.papi_get_margin_all_order_list()


def test_papi_get_margin_open_order_list(client):
    client.papi_get_margin_open_order_list()


def test_papi_get_margin_my_trades(client):
    client.papi_get_margin_my_trades()


def test_papi_get_margin_repay_debt(client):
    client.papi_get_margin_repay_debt()


def test_close_connection(client):
    client.close_connection()

</document_content>
</document>
<document index="62">
<source>tests/test_client_ws_api.py</source>
<document_content>
import sys
import pytest
from binance.client import Client
from .conftest import proxies, api_key, api_secret, testnet
from .test_get_order_book import assert_ob

pytestmark = [pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")]

def test_ws_get_order_book(client):
    orderbook = client.ws_get_order_book(symbol="BTCUSDT")
    assert_ob(orderbook)


def test_ws_get_recent_trades(client):
    client.ws_get_recent_trades(symbol="BTCUSDT")


def test_ws_get_historical_trades(client):
    client.ws_get_historical_trades(symbol="BTCUSDT")


def test_ws_get_aggregate_trades(client):
    client.ws_get_aggregate_trades(symbol="BTCUSDT")


def test_ws_get_klines(client):
    client.ws_get_klines(symbol="BTCUSDT", interval="1m")


def test_ws_get_uiKlines(client):
    client.ws_get_uiKlines(symbol="BTCUSDT", interval="1m")


def test_ws_get_avg_price(client):
    client.ws_get_avg_price(symbol="BTCUSDT")


def test_ws_get_ticker(client):
    client.ws_get_ticker(symbol="BTCUSDT")


def test_ws_get_trading_day_ticker(client):
    client.ws_get_trading_day_ticker(symbol="BTCUSDT")


def test_ws_get_symbol_ticker_window(client):
    client.ws_get_symbol_ticker_window(symbol="BTCUSDT")


def test_ws_get_symbol_ticker(client):
    client.ws_get_symbol_ticker(symbol="BTCUSDT")


def test_ws_get_orderbook_ticker(client):
    client.ws_get_orderbook_ticker(symbol="BTCUSDT")


def test_ws_ping(client):
    client.ws_ping()


def test_ws_get_time(client):
    client.ws_get_time()


def test_ws_get_exchange_info(client):
    client.ws_get_exchange_info(symbol="BTCUSDT")


def test_ws_time_microseconds():
    micro_client = Client(
        api_key,
        api_secret,
        {"proxies": proxies},
        testnet=testnet,
        time_unit="MICROSECOND",
    )
    micro_trades = micro_client.ws_get_recent_trades(symbol="BTCUSDT")
    assert len(str(micro_trades[0]["time"])) >= 16, (
        "WS time should be in microseconds (16+ digits)"
    )


def test_ws_time_milliseconds():
    milli_client = Client(
        api_key,
        api_secret,
        {"proxies": proxies},
        testnet=testnet,
        time_unit="MILLISECOND",
    )
    milli_trades = milli_client.ws_get_recent_trades(symbol="BTCUSDT")
    assert len(str(milli_trades[0]["time"])) == 13, (
        "WS time should be in milliseconds (13 digits)"
    )

</document_content>
</document>
<document index="63">
<source>tests/test_client_ws_futures_requests.py</source>
<document_content>
import pytest
import sys
from binance.exceptions import BinanceAPIException
from .test_get_order_book import assert_ob
from .test_order import assert_contract_order


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_futures_get_order_book(futuresClient):
    orderbook = futuresClient.ws_futures_get_order_book(symbol="BTCUSDT")
    assert_ob(orderbook)


def test_bad_request(futuresClient):
    with pytest.raises(BinanceAPIException):
        futuresClient.ws_futures_get_order_book()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_futures_get_all_tickers(futuresClient):
    futuresClient.ws_futures_get_all_tickers()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_futures_get_order_book_ticker(futuresClient):
    futuresClient.ws_futures_get_order_book_ticker()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_futures_create_get_edit_cancel_order(futuresClient):
    ticker = futuresClient.ws_futures_get_order_book_ticker(symbol="LTCUSDT")
    positions = futuresClient.ws_futures_v2_account_position(symbol="LTCUSDT")
    order = futuresClient.ws_futures_create_order(
        symbol=ticker["symbol"],
        side="SELL",
        positionSide=positions[0]["positionSide"],
        type="LIMIT",
        timeInForce="GTC",
        quantity=0.1,
        price=str(round(float(ticker["bidPrice"]) + 2)),
    )
    assert_contract_order(futuresClient, order)
    order = futuresClient.ws_futures_edit_order(
        orderid=order["orderId"],
        symbol=order["symbol"],
        quantity=0.11,
        side=order["side"],
        price=order["price"],
    )
    assert_contract_order(futuresClient, order)
    order = futuresClient.ws_futures_get_order(
        symbol="LTCUSDT", orderid=order["orderId"]
    )
    assert_contract_order(futuresClient, order)
    order = futuresClient.ws_futures_cancel_order(
        orderid=order["orderId"], symbol=order["symbol"]
    )


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_futures_v2_account_position(futuresClient):
    futuresClient.ws_futures_v2_account_position()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_futures_account_position(futuresClient):
    futuresClient.ws_futures_account_position()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_futures_v2_account_balance(futuresClient):
    futuresClient.ws_futures_v2_account_balance()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_futures_account_balance(futuresClient):
    futuresClient.ws_futures_account_balance()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_futures_v2_account_status(futuresClient):
    futuresClient.ws_futures_v2_account_status()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
def test_ws_futures_account_status(futuresClient):
    futuresClient.ws_futures_account_status()

</document_content>
</document>
<document index="64">
<source>tests/test_cryptography.py</source>
<document_content>
from binance.client import Client

test_cases = [
    {
        "description": "Unencrypted PKCS8 ed22519 private key",
        "private_key": "-----BEGIN PRIVATE KEY-----\nMC4CAQAwBQYDK2VwBCIEIPQmzwVKJETqVd7L9E/DFbkvrOigy1tLL+9QF0mSn6dV\n-----END PRIVATE KEY-----\n",
        "password": None,
        "expected_signature": "a4Pm3p02D2HXtNfo3DBaVCe9Ov7kledewgYtGjekotFmZ5wXa3mC5AtLB7CpAphyNjeyovIuDP+9fyjYmsojCw==",
    },
    {
        "description": "Unencrypted PKCS8 ed22519 private key in bytes",
        "private_key": b"-----BEGIN PRIVATE KEY-----\nMC4CAQAwBQYDK2VwBCIEIPQmzwVKJETqVd7L9E/DFbkvrOigy1tLL+9QF0mSn6dV\n-----END PRIVATE KEY-----\n",
        "password": None,
        "expected_signature": "a4Pm3p02D2HXtNfo3DBaVCe9Ov7kledewgYtGjekotFmZ5wXa3mC5AtLB7CpAphyNjeyovIuDP+9fyjYmsojCw==",
    },
    {
        "description": "Encrypted PKCS8 RSA private key",
        "private_key": "-----BEGIN ENCRYPTED PRIVATE KEY-----\nMIIFNTBfBgkqhkiG9w0BBQ0wUjAxBgkqhkiG9w0BBQwwJAQQWW+iEMYYCPUntrPq\nZ2RCMAICCAAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEASoEEIw3ViSuTp8JeN43\n5VGlHt0EggTQBvEzd2w2F561CzU+MDouZDOPj4RTIStC471z0/bxTgYqH3gYchoe\nOfi2lsLuD8B+ivIRuXB8GT66BIseIOMV8t/tiMe97rFI/cV4h6DrBO1xlmSrBG97\nvFF9qPA5yPRlrHtWKkGxhXteNVsT3w/7Y7KsulO/gA2KpsOElMElOhUP462Yd0Wl\nOxAIV3+knl2niozws2Kq3EdzTF3N6hlavUPryiU/w4RRsPN5qgjchVVLq/sYRYhx\nN8uWJbkjhCcHsULkD5KkdgddR0VOhpQPXIdY+gPkSBJq1ltRWy/TYdXiU2fEBNZW\nhFUVrxnS76+u2R3vukY2IAX8zTC6h2AbCBG+r4XXzgk/l/4peySKHsPQRzQ0in39\na9o5sctOmUNeD4uJ6cClXDdqyEwXhnPmRKZjJ8qeH4D9wl7HOG7iQsYiyfJe/igi\nFEXVRZOtLBdbwX45rU6wiWWjxzY+mDnw4BXE31ZBPwgtoh+CLTyK8NI8LnCV/CgO\nzOY4sm/KDWmbfTTZjLSdYRFj7wEpOdUWjZ13viDFZqnmy/o1auvLmBcqbRrCyW+B\nOMI7aHE0mZ/52vEFQYU1tH0BxMmRfWXUCJj0TjwxDY6BQmmW4YlhsrgGNekLFDo1\n6phFd0pA4UPqGXfNLzHp1dtLhUEb4YzcpDn+HMzMf1gfez7qeqU28nNFg/AwwqHZ\nTWdGclCFjiah7SfvOslob4vdLGwkUhgCBKQUQoU1DltX2GOgIv9SNY3q6X0NwdZG\nL5gqk225WVUwIRzmi5nfUEXlbaTvyHg3BuGedUKJ91IhRCW1ZjvU8GQcfVsu8bse\nTCKMdr7wi/zEZXSldCza6vL4m3tmBLtWkHVOW8bcDWvoVwRswbFHfleHzckl7EeC\n9C4TRa66gA5UOv14SrpC8noQUNpSegg+1KI4BSNvwaheiSUqjQbisb0qYCxML0ZP\nmQodwVsXG6LYo+Y6y6CpHbT7UYkfa59q/CGOZByL1bEzzgd98ZHwjihOjHVaV6sY\nBW018AvGxr7kjEU4LNqIteydTp0o31ZJN/qK78w5EQFfJxfImrx/E4nYKtg4higj\nKOQCgJALKIveidqQEFsbGWsulYrMXwnu0nPThofR1D8eCJZpdTxvOh2nIrNrAeY8\nZMAwG1uQos5A0yEZ1auHxz+rb4errnk92OnVlWnElf1TwwlkFFNLdNDl8VpiMP40\n6en9VtlOfgH8AwB03WsoeuEQsxYTIcRKWZZPRsLx3hd0BsOw0FcYDSX2XIGPkVVW\niYf9hzFSQsWV3d6utloIm4nG8XONfNaRimGECbUSZyHZimrO1m4Gga5pE3LKuDri\nJKR2lR7b6XPR7+FS+lG1zq5KY7onAVQY1oABfTjpJRju6pQGWt70hairo6EaVC3u\nrBy8UkLwBbfDuigSvsVk+sF2+Ic0IzX6IniU0F5kMe+MKqGB4aicXP6FFGBpPFTe\nv6yHD+DYAu1rnlXrqmFL50CfutTF78uPPJ9D2Sm0DcGPFj+6IrCigj48uxoHR9Qb\nFeNzfsmVwoFAWWq/MpkPbX6Aql8ddCbpMxDUUkybwVV9rJmEMTLil44FrxKAKFhP\n0Av7JeFvdz15pfnf/IQ3IOvVhHGFChFS13sbYSvFHMQF3P0BiyvjhBI=\n-----END ENCRYPTED PRIVATE KEY-----\n",
        "password": "testpwd",
        "expected_signature": "S4l9IONXGHIdt4NjwmpCIhawDTitjUQls73d+mi0HJTSbTGyn95NabX5hC9+n6HsTqLcWPvxKgTvLFMnTaf6Jxl+xwQMbu9/6mw88KF7i1pEQizerKcr91rPUPVBQ4OY10Q018QEamIAymRgo/eoRYSm7CqCdeibGyO0XfXZBaJnVGFJ9hgrPIwSKHgeUnfK8qMenULvL0qKMEJ6ziYPiqh7k9xX3xIV7lGIpokk+ekqlFd01f/Lov45osJCFuccJO4xuUUZewZnVGF7Uw6Rim3UsKhXKZUN9WZWa5RT+dpBIJ5DTBIXBSvowwj3GZC3j+XvWw8Sn0Ls9836l89BXw==",
    },
    {
        "description": "Encrypted PKCS8 RSA private key in bytes",
        "private_key": b"-----BEGIN ENCRYPTED PRIVATE KEY-----\nMIIFNTBfBgkqhkiG9w0BBQ0wUjAxBgkqhkiG9w0BBQwwJAQQWW+iEMYYCPUntrPq\nZ2RCMAICCAAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEASoEEIw3ViSuTp8JeN43\n5VGlHt0EggTQBvEzd2w2F561CzU+MDouZDOPj4RTIStC471z0/bxTgYqH3gYchoe\nOfi2lsLuD8B+ivIRuXB8GT66BIseIOMV8t/tiMe97rFI/cV4h6DrBO1xlmSrBG97\nvFF9qPA5yPRlrHtWKkGxhXteNVsT3w/7Y7KsulO/gA2KpsOElMElOhUP462Yd0Wl\nOxAIV3+knl2niozws2Kq3EdzTF3N6hlavUPryiU/w4RRsPN5qgjchVVLq/sYRYhx\nN8uWJbkjhCcHsULkD5KkdgddR0VOhpQPXIdY+gPkSBJq1ltRWy/TYdXiU2fEBNZW\nhFUVrxnS76+u2R3vukY2IAX8zTC6h2AbCBG+r4XXzgk/l/4peySKHsPQRzQ0in39\na9o5sctOmUNeD4uJ6cClXDdqyEwXhnPmRKZjJ8qeH4D9wl7HOG7iQsYiyfJe/igi\nFEXVRZOtLBdbwX45rU6wiWWjxzY+mDnw4BXE31ZBPwgtoh+CLTyK8NI8LnCV/CgO\nzOY4sm/KDWmbfTTZjLSdYRFj7wEpOdUWjZ13viDFZqnmy/o1auvLmBcqbRrCyW+B\nOMI7aHE0mZ/52vEFQYU1tH0BxMmRfWXUCJj0TjwxDY6BQmmW4YlhsrgGNekLFDo1\n6phFd0pA4UPqGXfNLzHp1dtLhUEb4YzcpDn+HMzMf1gfez7qeqU28nNFg/AwwqHZ\nTWdGclCFjiah7SfvOslob4vdLGwkUhgCBKQUQoU1DltX2GOgIv9SNY3q6X0NwdZG\nL5gqk225WVUwIRzmi5nfUEXlbaTvyHg3BuGedUKJ91IhRCW1ZjvU8GQcfVsu8bse\nTCKMdr7wi/zEZXSldCza6vL4m3tmBLtWkHVOW8bcDWvoVwRswbFHfleHzckl7EeC\n9C4TRa66gA5UOv14SrpC8noQUNpSegg+1KI4BSNvwaheiSUqjQbisb0qYCxML0ZP\nmQodwVsXG6LYo+Y6y6CpHbT7UYkfa59q/CGOZByL1bEzzgd98ZHwjihOjHVaV6sY\nBW018AvGxr7kjEU4LNqIteydTp0o31ZJN/qK78w5EQFfJxfImrx/E4nYKtg4higj\nKOQCgJALKIveidqQEFsbGWsulYrMXwnu0nPThofR1D8eCJZpdTxvOh2nIrNrAeY8\nZMAwG1uQos5A0yEZ1auHxz+rb4errnk92OnVlWnElf1TwwlkFFNLdNDl8VpiMP40\n6en9VtlOfgH8AwB03WsoeuEQsxYTIcRKWZZPRsLx3hd0BsOw0FcYDSX2XIGPkVVW\niYf9hzFSQsWV3d6utloIm4nG8XONfNaRimGECbUSZyHZimrO1m4Gga5pE3LKuDri\nJKR2lR7b6XPR7+FS+lG1zq5KY7onAVQY1oABfTjpJRju6pQGWt70hairo6EaVC3u\nrBy8UkLwBbfDuigSvsVk+sF2+Ic0IzX6IniU0F5kMe+MKqGB4aicXP6FFGBpPFTe\nv6yHD+DYAu1rnlXrqmFL50CfutTF78uPPJ9D2Sm0DcGPFj+6IrCigj48uxoHR9Qb\nFeNzfsmVwoFAWWq/MpkPbX6Aql8ddCbpMxDUUkybwVV9rJmEMTLil44FrxKAKFhP\n0Av7JeFvdz15pfnf/IQ3IOvVhHGFChFS13sbYSvFHMQF3P0BiyvjhBI=\n-----END ENCRYPTED PRIVATE KEY-----\n",
        "password": "testpwd",
        "expected_signature": "S4l9IONXGHIdt4NjwmpCIhawDTitjUQls73d+mi0HJTSbTGyn95NabX5hC9+n6HsTqLcWPvxKgTvLFMnTaf6Jxl+xwQMbu9/6mw88KF7i1pEQizerKcr91rPUPVBQ4OY10Q018QEamIAymRgo/eoRYSm7CqCdeibGyO0XfXZBaJnVGFJ9hgrPIwSKHgeUnfK8qMenULvL0qKMEJ6ziYPiqh7k9xX3xIV7lGIpokk+ekqlFd01f/Lov45osJCFuccJO4xuUUZewZnVGF7Uw6Rim3UsKhXKZUN9WZWa5RT+dpBIJ5DTBIXBSvowwj3GZC3j+XvWw8Sn0Ls9836l89BXw==",
    },
]


def test_encryption():
    data = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "type": "LIMIT",
        "quantity": 1,
        "timestamp": 1631234567890,
        "price": 50000,
    }

    for case in test_cases:
        client = Client(
            api_key="api_key",
            api_secret="api_secret",
            private_key=case["private_key"],
            private_key_pass=case["password"],
            ping=False,
        )
        signature = client._generate_signature(data, False)
        assert signature == case["expected_signature"], (
            f"Test failed: {case['description']}"
        )

</document_content>
</document>
<document index="65">
<source>tests/test_depth_cache.py</source>
<document_content>
from binance.ws.depthcache import DepthCache
from decimal import Decimal
import pytest

TEST_SYMBOL = "BNBBTC"


@pytest.fixture
def fresh_cache():
    return DepthCache(TEST_SYMBOL, Decimal)


def test_add_bids(fresh_cache):
    """Verify basic functionality for adding a bid to the cache"""
    high_bid = [0.111, 489]
    mid_bid = [0.018, 300]
    low_bid = [0.001, 100]
    for bid in [high_bid, low_bid, mid_bid]:
        fresh_cache.add_bid(bid)

    bids = fresh_cache.get_bids()

    assert len(bids) == 3

    assert bids == sorted(bids, reverse=True)

    assert isinstance(bids[0][0], Decimal)
    assert isinstance(bids[0][1], Decimal)


def test_add_asks(fresh_cache):
    """Verify basic functionality for adding an ask to the cache"""
    high_ask = [0.111, 489]
    mid_ask = [0.018, 300]
    low_ask = [0.001, 100]

    for ask in [high_ask, low_ask, mid_ask]:
        fresh_cache.add_ask(ask)

    asks = fresh_cache.get_asks()

    # Three asks should be in the cache
    assert len(asks) == 3

    # Lowest ask price should be first (ascending order)
    assert asks == sorted(asks)

    assert isinstance(asks[0][0], Decimal)
    assert isinstance(asks[0][1], Decimal)

</document_content>
</document>
<document index="66">
<source>tests/test_futures.py</source>
<document_content>
import requests_mock
import json
from binance.client import Client
import re

client = Client(api_key="api_key", api_secret="api_secret", ping=False)


def test_futures_position_information():
    with requests_mock.mock() as m:
        url_matcher = re.compile(
            r"https:\/\/fapi.binance.com\/fapi\/v3\/positionRisk\?.+"
        )
        response = [
            {
                "symbol": "LTCUSDT",
                "positionSide": "LONG",
                "positionAmt": "0.700",
                "entryPrice": "75.6",
                "breakEvenPrice": "75.63024",
                "markPrice": "73.18000000",
                "unRealizedProfit": "-1.69400000",
                "liquidationPrice": "0",
                "isolatedMargin": "0",
                "notional": "51.22600000",
                "marginAsset": "USDT",
                "isolatedWallet": "0",
                "initialMargin": "10.24520000",
                "maintMargin": "0.33296900",
                "positionInitialMargin": "10.24520000",
                "openOrderInitialMargin": "0",
                "adl": 0,
                "bidNotional": "0",
                "askNotional": "0",
                "updateTime": 1729436057076,
            }
        ]
        m.register_uri("GET", url_matcher, json=json.dumps(response), status_code=200)
        pos = client.futures_position_information(symbol="LTCUSDT")
        assert m.last_request.qs["symbol"][0] == "LTCUSDT".lower()
        assert m.last_request.path == "/fapi/v3/positionrisk"


def test_futures_position_information_version_override():
    with requests_mock.mock() as m:
        url_matcher = re.compile(
            r"https:\/\/fapi.binance.com\/fapi\/v2\/positionRisk\?.+"
        )
        response = [
            {
                "symbol": "LTCUSDT",
                "positionSide": "LONG",
                "positionAmt": "0.700",
                "entryPrice": "75.6",
                "breakEvenPrice": "75.63024",
                "markPrice": "73.18000000",
                "unRealizedProfit": "-1.69400000",
                "liquidationPrice": "0",
                "isolatedMargin": "0",
                "notional": "51.22600000",
                "marginAsset": "USDT",
                "isolatedWallet": "0",
                "initialMargin": "10.24520000",
                "maintMargin": "0.33296900",
                "positionInitialMargin": "10.24520000",
                "openOrderInitialMargin": "0",
                "adl": 0,
                "bidNotional": "0",
                "askNotional": "0",
                "updateTime": 1729436057076,
            }
        ]
        m.register_uri("GET", url_matcher, json=json.dumps(response), status_code=200)
        pos = client.futures_position_information(symbol="LTCUSDT", version=2)
        assert m.last_request.qs["symbol"][0] == "LTCUSDT".lower()
        assert m.last_request.path == "/fapi/v2/positionrisk"


def test_futures_account_balance():
    with requests_mock.mock() as m:
        url_matcher = re.compile(r"https:\/\/fapi.binance.com\/fapi\/v3\/balance\?.+")
        m.register_uri("GET", url_matcher, json={}, status_code=200)
        client.futures_account_balance()
        assert m.last_request.path == "/fapi/v3/balance"


def test_futures_account_config():
    with requests_mock.mock() as m:
        url_matcher = re.compile(
            r"https:\/\/fapi.binance.com\/fapi\/v1\/accountConfig\?.+"
        )
        m.register_uri("GET", url_matcher, json={}, status_code=200)
        client.futures_account_config()
        assert m.last_request.path == "/fapi/v1/accountconfig"

</document_content>
</document>
<document index="67">
<source>tests/test_get_order_book.py</source>
<document_content>
import pytest
import sys
from binance.exceptions import BinanceAPIException


def assert_ob(order_book):
    assert isinstance(order_book, dict)
    assert "lastUpdateId" in order_book
    assert "bids" in order_book
    assert "asks" in order_book

    assert isinstance(order_book["bids"], list)
    assert isinstance(order_book["asks"], list)

    if order_book["bids"]:
        bid = order_book["bids"][0]
        assert len(bid) == 2
        assert all(isinstance(item, str) for item in bid[:2])

    if order_book["asks"]:
        ask = order_book["asks"][0]
        assert len(ask) == 2
        assert all(isinstance(item, str) for item in ask[:2])


def test_get_order_book(client):
    try:
        order_book = client.get_order_book(symbol="BTCUSDT")
        assert_ob(order_book)

    except BinanceAPIException as e:
        pytest.fail(f"API request failed: {str(e)}")


def test_futures_get_order_book(client):
    try:
        order_book = client.futures_order_book(symbol="BTCUSDT")
        assert_ob(order_book)

    except BinanceAPIException as e:
        pytest.fail(f"API request failed: {str(e)}")


def test_get_order_book_with_limit(client):
    try:
        order_book = client.get_order_book(symbol="BTCUSDT", limit=5)

        assert_ob(order_book)
        assert len(order_book["bids"]) <= 5
        assert len(order_book["asks"]) <= 5

    except BinanceAPIException as e:
        pytest.fail(f"API request failed: {str(e)}")


@pytest.mark.asyncio(scope="function")
async def test_get_order_book_async(clientAsync):
    order_book = await clientAsync.get_order_book(symbol="BTCUSDT")
    assert_ob(order_book)


@pytest.mark.asyncio(scope="function")
async def test_futures_get_order_book_async(clientAsync):
    try:
        order_book = await clientAsync.futures_order_book(symbol="BTCUSDT")
        assert_ob(order_book)
    except BinanceAPIException as e:
        pytest.fail(f"API request failed: {str(e)}")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio()
async def test_ws_get_order_book(clientAsync):
    order_book = await clientAsync.ws_get_order_book(symbol="BTCUSDT")
    assert_ob(order_book)

</document_content>
</document>
<document index="68">
<source>tests/test_headers.py</source>
<document_content>
import requests_mock
import pytest
from aioresponses import aioresponses

from binance import Client, AsyncClient

client = Client(api_key="api_key", api_secret="api_secret", ping=False)


def test_get_headers():
    with requests_mock.mock() as m:
        m.get("https://api.binance.com/api/v3/account", json={}, status_code=200)
        client.get_account()
        headers = m.last_request._request.headers
        assert "Content-Type" in headers
        assert headers["Content-Type"] == "application/json"


def test_post_headers():
    with requests_mock.mock() as m:
        m.post("https://api.binance.com/api/v3/order", json={}, status_code=200)
        client.create_order(symbol="LTCUSDT", side="BUY", type="MARKET", quantity=0.1)
        headers = m.last_request._request.headers
        assert "Content-Type" in headers
        assert headers["Content-Type"] == "application/x-www-form-urlencoded"


def test_post_headers_overriden():
    with requests_mock.mock() as m:
        m.post("https://api.binance.com/api/v3/order", json={}, status_code=200)
        client.create_order(
            symbol="LTCUSDT",
            side="BUY",
            type="MARKET",
            quantity=0.1,
            headers={"Content-Type": "myvalue"},
        )
        headers = m.last_request._request.headers
        assert "Content-Type" in headers
        assert headers["Content-Type"] == "myvalue"


@pytest.mark.asyncio()
async def test_post_headers_async():
    clientAsync = AsyncClient(
        api_key="api_key", api_secret="api_secret"
    )  # reuse client later
    with aioresponses() as m:

        def handler(url, **kwargs):
            headers = kwargs["headers"]
            assert "Content-Type" in headers
            assert headers["Content-Type"] == "application/x-www-form-urlencoded"

        m.post(
            "https://api.binance.com/api/v3/order",
            payload={"id": 1},
            status=200,
            callback=handler,
        )
        await clientAsync.create_order(
            symbol="LTCUSDT", side="BUY", type="MARKET", quantity=0.1
        )
        await clientAsync.close_connection()


@pytest.mark.asyncio()
async def test_post_headers_overriden_async():
    clientAsync = AsyncClient(
        api_key="api_key", api_secret="api_secret"
    )  # reuse client later
    with aioresponses() as m:

        def handler(url, **kwargs):
            headers = kwargs["headers"]
            assert "Content-Type" in headers
            assert headers["Content-Type"] == "myvalue"

        m.post(
            "https://api.binance.com/api/v3/order",
            payload={"id": 1},
            status=200,
            callback=handler,
        )
        await clientAsync.create_order(
            symbol="LTCUSDT",
            side="BUY",
            type="MARKET",
            quantity=0.1,
            headers={"Content-Type": "myvalue"},
        )
        await clientAsync.close_connection()

</document_content>
</document>
<document index="69">
<source>tests/test_init.py</source>
<document_content>
from binance import (
    AsyncClient,
    Client,
    DepthCacheManager,
    OptionsDepthCacheManager,
    ThreadedDepthCacheManager,
    FuturesDepthCacheManager,
    BinanceSocketManager,
    ThreadedWebsocketManager,
    BinanceSocketType,
    KeepAliveWebsocket,
    ReconnectingWebsocket
)

def test_version():
    """Test that __version__ is defined"""
    from binance import __version__
    assert isinstance(__version__, str)
    assert __version__ is not None

def test_client_import():
    """Test Client class import"""
    assert Client is not None
    assert isinstance(Client, type)

def test_async_client_import():
    """Test AsyncClient class import"""
    assert AsyncClient is not None
    assert isinstance(AsyncClient, type)

def test_depth_cache_imports():
    """Test depth cache related imports"""
    assert DepthCacheManager is not None
    assert OptionsDepthCacheManager is not None
    assert ThreadedDepthCacheManager is not None
    assert FuturesDepthCacheManager is not None
    assert isinstance(DepthCacheManager, type)
    assert isinstance(OptionsDepthCacheManager, type)
    assert isinstance(ThreadedDepthCacheManager, type)
    assert isinstance(FuturesDepthCacheManager, type)

def test_websocket_imports():
    """Test websocket related imports"""
    assert BinanceSocketManager is not None
    assert ThreadedWebsocketManager is not None
    assert BinanceSocketType is not None
    assert isinstance(BinanceSocketManager, type)
    assert isinstance(ThreadedWebsocketManager, type)

def test_websocket_utility_imports():
    """Test websocket utility imports"""
    assert KeepAliveWebsocket is not None
    assert ReconnectingWebsocket is not None
    assert isinstance(KeepAliveWebsocket, type)
    assert isinstance(ReconnectingWebsocket, type)

</document_content>
</document>
<document index="70">
<source>tests/test_order.py</source>
<document_content>
def assert_contract_order(client, order):
    assert isinstance(order, dict)

    assert order["clientOrderId"].startswith(client.CONTRACT_ORDER_PREFIX)
    assert order["symbol"]

</document_content>
</document>
<document index="71">
<source>tests/test_ping.py</source>
<document_content>
import os
import pytest


proxies = {}
proxy = os.getenv("PROXY")


def test_papi_ping_sync(client):
    ping_response = client.papi_ping()
    assert ping_response is not None


def test_ping_sync(client):
    ping_response = client.ping()
    assert ping_response is not None


def test_futures_ping(client):
    ping_response = client.futures_ping()
    assert ping_response is not None


def test_coin_ping(client):
    ping_response = client.futures_coin_ping()
    assert ping_response is not None


@pytest.mark.asyncio()
async def test_papi_ping_async(clientAsync):
    ping_response = await clientAsync.papi_ping()
    assert ping_response is not None


@pytest.mark.asyncio()
async def test_ping_async(clientAsync):
    ping_response = await clientAsync.ping()
    assert ping_response is not None


@pytest.mark.asyncio()
async def test_futures_ping_async(clientAsync):
    ping_response = await clientAsync.futures_ping()
    assert ping_response is not None


@pytest.mark.asyncio()
async def test_coin_ping_async(clientAsync):
    ping_response = await clientAsync.futures_coin_ping()
    assert ping_response is not None

</document_content>
</document>
<document index="72">
<source>tests/test_reconnecting_websocket.py</source>
<document_content>
import sys
import pytest
import gzip
import json
from unittest.mock import patch, create_autospec, Mock
from binance.ws.reconnecting_websocket import ReconnectingWebsocket
from binance.ws.constants import WSListenerState
from binance.exceptions import BinanceWebsocketUnableToConnect, ReadLoopClosed
from websockets import WebSocketClientProtocol  # type: ignore
from websockets.protocol import State
import asyncio

try:
    from unittest.mock import AsyncMock  # Python 3.8+
except ImportError:
    from asynctest import CoroutineMock as AsyncMock  # Python 3.7


@pytest.mark.asyncio
async def test_init():
    ws = ReconnectingWebsocket(url="wss://test.url", path="/test")
    assert ws._url == "wss://test.url"
    assert ws._path == "/test"
    assert ws.ws_state == WSListenerState.INITIALISING


@pytest.mark.asyncio
async def test_json_dumps():
    ws = ReconnectingWebsocket(url="wss://test.url")
    data = {"key": "value"}
    dumped = ws.json_dumps(data)
    assert isinstance(dumped, (str, bytes))


@pytest.mark.asyncio
async def test_json_loads():
    ws = ReconnectingWebsocket(url="wss://test.url")
    data_str = '{"key": "value"}'
    loaded = ws.json_loads(data_str)
    assert loaded == {"key": "value"}


@pytest.mark.asyncio
async def test_json_loads_invalid():
    ws = ReconnectingWebsocket(url="wss://test.url")
    data_str = "invalid json"
    with pytest.raises(json.JSONDecodeError):
        ws.json_loads(data_str)


@pytest.mark.asyncio
async def test_handle_message():
    ws = ReconnectingWebsocket(url="wss://test.url")
    message = '{"key": "value"}'
    result = ws._handle_message(message)
    assert result == {"key": "value"}


@pytest.mark.asyncio
async def test_handle_message_binary():
    ws = ReconnectingWebsocket(url="wss://test.url", is_binary=True)
    data = b'{"key": "value"}'
    compressed = gzip.compress(data)
    result = ws._handle_message(compressed)
    assert result == {"key": "value"}


@pytest.mark.asyncio
async def test_handle_message_invalid_json():
    ws = ReconnectingWebsocket(url="wss://test.url")
    message = "invalid json"
    with pytest.raises(Exception):
        ws._handle_message(message)


@pytest.mark.asyncio
async def test_recv_message():
    ws = ReconnectingWebsocket(url="wss://test.url")
    await ws._queue.put({"test": "data"})
    # Simulate the read loop being active
    ws._handle_read_loop = Mock()
    result = await ws.recv()
    assert result == {"test": "data"}


@pytest.mark.skipif(sys.version_info < (3, 8), reason="Requires Python 3.8+")
@pytest.mark.asyncio
async def test_before_reconnect():
    ws = ReconnectingWebsocket(url="wss://test.url")
    ws.ws = AsyncMock()
    ws._conn = AsyncMock()
    ws._reconnects = 0
    await ws.before_reconnect()
    assert ws.ws is None
    ws._conn.__aexit__.assert_awaited()
    assert ws._reconnects == 1


def test_get_reconnect_wait():
    ws = ReconnectingWebsocket(url="wss://test.url")
    wait_time = ws._get_reconnect_wait(2)
    assert 1 <= wait_time <= ws.MAX_RECONNECT_SECONDS


@pytest.mark.skipif(sys.version_info < (3, 8), reason="Requires Python 3.8+")
@pytest.mark.asyncio
async def test_connect_max_reconnects_exceeded():
    """Test ws.connect exceeds maximum reconnect attempts."""
    ws = ReconnectingWebsocket(url="wss://test.url")
    ws.MAX_RECONNECTS = 2  # type: ignore # Set max reconnects to a low number for testing
    ws._before_connect = AsyncMock()
    ws._after_connect = AsyncMock()
    ws._conn = AsyncMock()
    exception = Exception("Connection failed")
    ws._conn.__aenter__.side_effect = exception

    with patch.object(ws._log, "error") as mock_log:
        with pytest.raises(BinanceWebsocketUnableToConnect):
            for _ in range(3):  # Exceed MAX_RECONNECTS
                await ws._run_reconnect()
        mock_log.assert_called_with(f"Max reconnections {ws.MAX_RECONNECTS} reached:")

    assert ws._reconnects == ws.MAX_RECONNECTS


@pytest.mark.skipif(sys.version_info < (3, 8), reason="Requires Python 3.8+")
@pytest.mark.asyncio
async def test_recieve_invalid_json():
    # Create mock WebSocket client
    mock_socket = create_autospec(WebSocketClientProtocol)
    mock_socket.recv = AsyncMock(return_value="invalid json{")
    mock_socket.state = AsyncMock()

    # Mock websockets.connect to return our mock socket
    with patch("websockets.connect") as mock_connect:
        mock_connect.return_value.__aenter__.return_value = mock_socket

        ws = ReconnectingWebsocket(url="wss://test.url")
        async with ws:
            msg = await ws.recv()
            assert msg["e"] == "error"
            assert msg["type"] == "JSONDecodeError"  # JSON parsing error


@pytest.mark.skipif(sys.version_info < (3, 8), reason="Requires Python 3.8+")
@pytest.mark.asyncio
async def test_receive_valid_json():
    # Create mock WebSocket client
    msgRecv = '{"e": "value"}'
    mock_socket = create_autospec(WebSocketClientProtocol)
    mock_socket.recv = AsyncMock(return_value=msgRecv)
    mock_socket.state = AsyncMock()

    # Mock websockets.connect to return our mock socket
    with patch("websockets.connect") as mock_connect:
        mock_connect.return_value.__aenter__.return_value = mock_socket

        ws = ReconnectingWebsocket(url="wss://test.url")
        async with ws:
            msg = await ws.recv()
            assert msg == json.loads(msgRecv)


@pytest.mark.skipif(sys.version_info < (3, 8), reason="Requires Python 3.8+")
@pytest.mark.asyncio
async def test_connect_fails_to_connect_on_enter_context():
    """Test ws.connect raises a ConnectionClosedError."""
    ws = ReconnectingWebsocket(url="wss://test.url")
    ws._conn = AsyncMock()
    exception = Exception("Connection closed")
    ws._conn.__aenter__.side_effect = exception
    with pytest.raises(Exception):
        await ws.__aenter__()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="Requires Python 3.8+")
@pytest.mark.asyncio
async def test_connect_fails_to_connect_after_disconnect():
    # Create mock WebSocket client
    mock_socket = create_autospec(WebSocketClientProtocol)
    mock_socket.recv = AsyncMock(side_effect=delayed_return)
    mock_socket.state = AsyncMock()

    # Create mock connect that succeeds first, then fails
    mock_connect = AsyncMock()
    mock_connect.return_value.__aenter__.side_effect = [
        mock_socket,  # First call succeeds
        Exception("Connection failed"),  # Subsequent calls fail
    ]

    with patch("websockets.connect", return_value=mock_connect.return_value):
        ws = ReconnectingWebsocket(url="wss://test.url")
        async with ws as ws:
            assert ws.ws is not None
            msg = await ws.recv()
            ws.ws.state = State.CLOSED
            await ws.ws.close()
            while msg["e"] != "error":
                msg = await ws.recv()
            # Receive the closed message attempting to reconnect
            while msg["type"] == "BinanceWebsocketClosed":
                msg = await ws.recv()
            # After retrying to reconnect, receive BinanceWebsocketUnableToConnect
            assert msg["e"] == "error"
            assert msg["type"] == "BinanceWebsocketUnableToConnect"


async def delayed_return():
    await asyncio.sleep(0.1)  # 100 ms delay
    return '{"e": "value"}'


@pytest.mark.skipif(sys.version_info < (3, 8), reason="Requires Python 3.8+")
@pytest.mark.asyncio
async def test_recv_read_loop_closed():
    """Test that recv() raises ReadLoopClosed when read loop is closed."""
    ws = ReconnectingWebsocket(url="wss://test.url")
    
    # Simulate read loop being closed by setting _handle_read_loop to None
    ws._handle_read_loop = None
    
    with pytest.raises(ReadLoopClosed) as exc_info:
        await ws.recv()
    
    assert "Read loop has been closed" in str(exc_info.value)
    assert "please reset the websocket connection" in str(exc_info.value)

</document_content>
</document>
<document index="73">
<source>tests/test_socket_manager.py</source>
<document_content>
from binance import BinanceSocketManager, AsyncClient
import pytest
from .conftest import proxy


def assert_message(msg):
    assert msg["stream"] == "!ticker@arr"
    assert len(msg["data"]) > 0


@pytest.mark.asyncio()
async def test_ticker_socket():
    client = await AsyncClient.create(testnet=True, https_proxy=proxy)
    bm = BinanceSocketManager(client)

    ts = bm.futures_ticker_socket()

    async with ts as tscm:
        try:
            res = await tscm.recv()
            assert_message(res)
        except Exception as e:
            print(f"An error occurred: {e}")

    await client.close_connection()

</document_content>
</document>
<document index="74">
<source>tests/test_streams.py</source>
<document_content>
import sys
from binance import BinanceSocketManager
import pytest

from binance.async_client import AsyncClient
from .conftest import proxy, api_key, api_secret, testnet


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_socket_stopped_on_aexit(clientAsync):
    bm = BinanceSocketManager(clientAsync)
    ts1 = bm.trade_socket("BNBBTC")
    async with ts1:
        pass
    assert bm._conns == {}, "socket should be removed from _conn on exit"
    ts2 = bm.trade_socket("BNBBTC")
    assert ts2 is not ts1, "socket should be removed from _conn on exit"
    await clientAsync.close_connection()

@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_socket_stopped_on_aexit_futures(futuresClientAsync):
    bm = BinanceSocketManager(futuresClientAsync)
    ts1 = bm.futures_user_socket()
    async with ts1:
        pass
    assert bm._conns == {}, "socket should be removed from _conn on exit"
    await futuresClientAsync.close_connection()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_socket_spot_market_time_unit_microseconds():
    clientAsync = AsyncClient(
        api_key, api_secret, https_proxy=proxy, testnet=testnet, time_unit="MICROSECOND"
    )
    bm = BinanceSocketManager(clientAsync)
    ts1 = bm.symbol_ticker_socket("BTCUSDT")
    async with ts1:
        trade = await ts1.recv()
        assert len(str(trade["E"])) >= 16, "Time should be in microseconds (16+ digits)"
    await clientAsync.close_connection()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_socket_spot_market_time_unit_milliseconds():
    clientAsync = AsyncClient(
        api_key, api_secret, https_proxy=proxy, testnet=testnet, time_unit="MILLISECOND"
    )
    bm = BinanceSocketManager(clientAsync)
    ts1 = bm.symbol_ticker_socket("BTCUSDT")
    async with ts1:
        trade = await ts1.recv()
        assert len(str(trade["E"])) == 13, "Time should be in milliseconds (13 digits)"
    await clientAsync.close_connection()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_socket_spot_user_data_time_unit_microseconds():
    clientAsync = AsyncClient(
        api_key, api_secret, https_proxy=proxy, testnet=testnet, time_unit="MICROSECOND"
    )
    bm = BinanceSocketManager(clientAsync)
    ts1 = bm.user_socket()
    async with ts1:
        await clientAsync.create_order(
            symbol="LTCUSDT", side="BUY", type="MARKET", quantity=0.1
        )
        trade = await ts1.recv()
        assert len(str(trade["E"])) >= 16, "Time should be in microseconds (16+ digits)"
    await clientAsync.close_connection()


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_socket_spot_user_data_time_unit_milliseconds():
    clientAsync = AsyncClient(
        api_key, api_secret, https_proxy=proxy, testnet=testnet, time_unit="MILLISECOND"
    )
    bm = BinanceSocketManager(clientAsync)
    ts1 = bm.user_socket()
    async with ts1:
        await clientAsync.create_order(
            symbol="LTCUSDT", side="BUY", type="MARKET", quantity=0.1
        )
        trade = await ts1.recv()
        assert len(str(trade["E"])) == 13, "Time should be in milliseconds (13 digits)"
    await clientAsync.close_connection()

</document_content>
</document>
<document index="75">
<source>tests/test_streams_options.py</source>
<document_content>
import sys
import pytest
import logging
from binance import BinanceSocketManager

pytestmark = [
    pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+"),
    pytest.mark.asyncio
]

# Configure logger for this module
logger = logging.getLogger(__name__)

# Test constants
OPTION_SYMBOL = "BTC-251226-60000-P"
UNDERLYING_SYMBOL = "BTC"
EXPIRATION_DATE = "251226"
INTERVAL = "1m"
DEPTH = "20"

async def test_options_ticker(clientAsync):
    """Test options ticker socket"""
    logger.info(f"Starting options ticker test for symbol: {OPTION_SYMBOL}")
    bm = BinanceSocketManager(clientAsync)
    socket = bm.options_ticker_socket(OPTION_SYMBOL)
    async with socket as ts:
        logger.debug("Waiting for ticker message...")
        msg = await ts.recv()
        logger.info(f"Received ticker message: {msg}")
        assert msg['e'] == '24hrTicker'
    logger.info("Options ticker test completed successfully")
    await clientAsync.close_connection()

async def test_options_ticker_by_expiration(clientAsync):
    """Test options ticker by expiration socket"""
    logger.info(f"Starting options ticker by expiration test for {UNDERLYING_SYMBOL}, expiration: {EXPIRATION_DATE}")
    bm = BinanceSocketManager(clientAsync)
    socket = bm.options_ticker_by_expiration_socket(UNDERLYING_SYMBOL, EXPIRATION_DATE)
    async with socket as ts:
        logger.debug("Waiting for ticker by expiration message...")
        msg = await ts.recv()
        logger.info(f"Received {len(msg)} ticker messages")
        assert len(msg) > 0
    logger.info("Options ticker by expiration test completed successfully")
    await clientAsync.close_connection()

async def test_options_recent_trades(clientAsync):
    """Test options recent trades socket"""
    logger.info(f"Starting options recent trades test for {UNDERLYING_SYMBOL}")
    bm = BinanceSocketManager(clientAsync)
    socket = bm.options_recent_trades_socket(UNDERLYING_SYMBOL)
    async with socket as ts:
        logger.debug("Waiting for trade message...")
        msg = await ts.recv()
        logger.info(f"Received trade message: {msg}")
        assert msg['e'] == 'trade'
    logger.info("Options recent trades test completed successfully")
    await clientAsync.close_connection()

async def test_options_kline(clientAsync):
    """Test options kline socket"""
    logger.info(f"Starting options kline test for {OPTION_SYMBOL}, interval: {INTERVAL}")
    bm = BinanceSocketManager(clientAsync)
    socket = bm.options_kline_socket(OPTION_SYMBOL, INTERVAL)
    async with socket as ts:
        logger.debug("Waiting for kline message...")
        msg = await ts.recv()
        logger.info(f"Received kline message: {msg}")
        assert msg['e'] == 'kline'
    logger.info("Options kline test completed successfully")
    await clientAsync.close_connection()

async def test_options_depth(clientAsync):
    """Test options depth socket"""
    logger.info(f"Starting options depth test for {OPTION_SYMBOL}, depth: {DEPTH}")
    bm = BinanceSocketManager(clientAsync)
    socket = bm.options_depth_socket(OPTION_SYMBOL, DEPTH)
    async with socket as ts:
        logger.debug("Waiting for depth message...")
        msg = await ts.recv()
        logger.info(f"Received depth message: {msg}")
        assert msg['e'] == 'depth'
    logger.info("Options depth test completed successfully")
    await clientAsync.close_connection()

async def test_options_multiplex(clientAsync):
    """Test options multiplex socket"""
    streams = [
        f"{OPTION_SYMBOL}@ticker",
        f"{OPTION_SYMBOL}@trade",
    ]
    logger.info(f"Starting options multiplex test with streams: {streams}")
    bm = BinanceSocketManager(clientAsync)
    socket = bm.options_multiplex_socket(streams)
    async with socket as ts:
        logger.debug("Waiting for multiplex message...")
        msg = await ts.recv()
        logger.info(f"Received multiplex message: {msg}")
        assert 'stream' in msg
    logger.info("Options multiplex test completed successfully")
    await clientAsync.close_connection()

async def test_options_open_interest(clientAsync):
    """Test options open interest socket"""
    logger.info(f"Starting options open interest test for {UNDERLYING_SYMBOL}, expiration: {EXPIRATION_DATE}")
    bm = BinanceSocketManager(clientAsync)
    socket = bm.options_open_interest_socket(UNDERLYING_SYMBOL, EXPIRATION_DATE)
    async with socket as ts:
        logger.debug("Waiting for open interest message...")
        msg = await ts.recv()
        logger.info(f"Received open interest message with {len(msg)} items")
        assert len(msg) > 0
    logger.info("Options open interest test completed successfully")
    await clientAsync.close_connection()

async def test_options_mark_price(clientAsync):
    """Test options mark price socket"""
    logger.info(f"Starting options mark price test for {UNDERLYING_SYMBOL}")
    bm = BinanceSocketManager(clientAsync)
    socket = bm.options_mark_price_socket(UNDERLYING_SYMBOL)
    async with socket as ts:
        logger.debug("Waiting for mark price message...")
        msg = await ts.recv()
        logger.info(f"Received mark price message with {len(msg)} items")
        assert len(msg) > 0
    logger.info("Options mark price test completed successfully")
    await clientAsync.close_connection()

async def test_options_index_price(clientAsync):
    """Test options index price socket"""
    symbol = 'ETHUSDT'
    logger.info(f"Starting options index price test for {symbol}")
    bm = BinanceSocketManager(clientAsync)
    socket = bm.options_index_price_socket(symbol)
    async with socket as ts:
        logger.debug("Waiting for index price message...")
        msg = await ts.recv()
        logger.info(f"Received index price message: {msg}")
        assert msg['e'] == 'index'
    logger.info("Options index price test completed successfully")
    await clientAsync.close_connection()

</document_content>
</document>
<document index="76">
<source>tests/test_threaded_socket_manager.py</source>
<document_content>
from binance import ThreadedWebsocketManager
from binance.client import Client
import asyncio
import time
from .conftest import proxies, api_key, api_secret, proxy
import pytest
import sys
import logging

pytestmark = pytest.mark.skipif(
    sys.version_info <= (3, 8),
    reason="These tests require Python 3.8+ for proper websocket proxy support"
)

received_ohlcv = False
received_depth = False

twm: ThreadedWebsocketManager

# Add logger definition before using it
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Get real symbols from Binance API
client = Client(api_key, api_secret, {"proxies": proxies})
exchange_info = client.get_exchange_info()
symbols = [info['symbol'].lower() for info in exchange_info['symbols']]
streams = [f"{symbol}@bookTicker" for symbol in symbols][0:100]  # Take first 800 symbols

def test_threaded_socket_manager():
    logger.debug("Starting test_threaded_socket_manager")
    global twm
    twm = ThreadedWebsocketManager(api_key, api_secret, https_proxy=proxy, testnet=True)

    symbol = "BTCUSDT"

    def handle_socket_message(msg):
        global received_ohlcv, received_depth
        if "e" in msg:
            if msg["e"] == "depthUpdate":
                logger.debug("Received depth update message")
                received_depth = True
            if msg["e"] == "kline":
                logger.debug("Received kline message")
                received_ohlcv = True
        if received_depth and received_ohlcv:
            logger.debug("Received both depth and OHLCV messages, stopping")
            twm.stop()

    try:
        logger.debug("Starting ThreadedWebsocketManager")
        twm.start()
        logger.debug("Starting kline socket for %s", symbol)
        twm.start_kline_socket(callback=handle_socket_message, symbol=symbol)
        logger.debug("Starting depth socket for %s", symbol)
        twm.start_depth_socket(callback=handle_socket_message, symbol=symbol)
        twm.join()
    finally:
        logger.debug("Cleaning up test_threaded_socket_manager")
        twm.stop()
        time.sleep(2)


def test_many_symbols_small_queue():
    logger.debug("Starting test_many_symbols_small_queue with queue size 1")
    twm = ThreadedWebsocketManager(api_key, api_secret, https_proxy=proxy, testnet=True, max_queue_size=1)
    
    error_received = False
    msg_received = False
    
    def handle_message(msg):
        nonlocal error_received, msg_received
        if msg.get("e") == "error":
            error_received = True
            logger.debug("Received WebSocket error: %s", msg.get('m', 'Unknown error'))
            return
        msg_received = True
        logger.debug("Received valid message")
    
    try:
        logger.debug("Starting ThreadedWebsocketManager")
        twm.start()
        logger.debug("Starting multiplex socket with %d streams", len(streams))
        twm.start_multiplex_socket(callback=handle_message, streams=streams)
        logger.debug("Waiting 10 seconds for messages")
        time.sleep(10)
        
        assert msg_received, "Should have received messages"
    finally:
        logger.debug("Cleaning up test_many_symbols_small_queue")
        twm.stop()
        time.sleep(2)


def test_many_symbols_adequate_queue():
    logger.debug("Starting test_many_symbols_adequate_queue with queue size 200")
    twm = ThreadedWebsocketManager(api_key, api_secret, https_proxy=proxy, testnet=True, max_queue_size=200)
    
    messages_received = 0
    error_received = False
    
    def handle_message(msg):
        nonlocal messages_received, error_received
        if msg.get("e") == "error":
            error_received = True
            logger.debug("Received WebSocket error: %s", msg.get('m', 'Unknown error'))
            return
            
        messages_received += 1
        if messages_received % 10 == 0:  # Log every 10th message
            logger.debug("Processed %d messages", messages_received)
    
    try:
        logger.debug("Starting ThreadedWebsocketManager")
        twm.start()
        logger.debug("Starting futures multiplex socket with %d streams", len(streams))
        twm.start_futures_multiplex_socket(callback=handle_message, streams=streams)
        logger.debug("Waiting 10 seconds for messages")
        time.sleep(10)
        
        logger.debug("Test completed. Messages received: %d, Errors: %s", messages_received, error_received)
        assert messages_received > 0, "Should have received some messages"
        assert not error_received, "Should not have received any errors"
    finally:
        logger.debug("Cleaning up test_many_symbols_adequate_queue")
        twm.stop()
        time.sleep(2)


def test_slow_async_callback_no_error():
    logger.debug("Starting test_slow_async_callback_no_error with queue size 400")
    twm = ThreadedWebsocketManager(api_key, api_secret, https_proxy=proxy, testnet=True, max_queue_size=400)
    
    messages_processed = 0
    error_received = False
    
    async def slow_async_callback(msg):
        nonlocal messages_processed, error_received
        if msg.get("e") == "error":
            error_received = True
            logger.debug("Received WebSocket error: %s", msg.get('m', 'Unknown error'))
            return
            
        logger.debug("Processing message with 2 second delay")
        await asyncio.sleep(2)
        messages_processed += 1
        logger.debug("Message processed. Total processed: %d", messages_processed)
    
    try:
        logger.debug("Starting ThreadedWebsocketManager")
        twm.start()
        logger.debug("Starting futures multiplex socket with %d streams", len(streams))
        twm.start_futures_multiplex_socket(callback=slow_async_callback, streams=streams)
        logger.debug("Waiting 10 seconds for messages")
        time.sleep(10)
        
        logger.debug("Test completed. Messages processed: %d, Errors: %s", messages_processed, error_received)
        assert messages_processed > 0, "Should have processed some messages"
        assert not error_received, "Should not have received any errors"
    finally:
        logger.debug("Cleaning up test_slow_async_callback_no_error")
        twm.stop()
        time.sleep(2)


def test_no_internet_connection():
    """Test that socket manager times out when there's no internet connection"""
    logger.debug("Starting test_no_internet_connection")
    invalid_proxy = "http://invalid.proxy:1234"
    logger.debug("Using invalid proxy: %s", invalid_proxy)
    
    with pytest.raises(RuntimeError, match="Binance Socket Manager failed to initialize after 5 seconds"):
        twm = ThreadedWebsocketManager(
            api_key, 
            api_secret, 
            https_proxy=invalid_proxy, 
            testnet=True
        )
        
        try:
            logger.debug("Attempting to start ThreadedWebsocketManager with invalid proxy")
            twm.start()
            logger.debug("Attempting to start kline socket (should fail)")
            twm.start_kline_socket(
                callback=lambda x: print(x), 
                symbol="BTCUSDT"
            )
        finally:
            logger.debug("Cleaning up test_no_internet_connection")
            twm.stop()
            time.sleep(2)

</document_content>
</document>
<document index="77">
<source>tests/test_threaded_stream.py</source>
<document_content>
import pytest
import asyncio

import websockets
from binance.ws.threaded_stream import ThreadedApiManager
from unittest.mock import Mock

# For Python 3.7 compatibility
try:
    from unittest.mock import AsyncMock
except ImportError:
    # Create our own AsyncMock for Python 3.7
    class AsyncMock(Mock):
        async def __call__(self, *args, **kwargs):
            return super(AsyncMock, self).__call__(*args, **kwargs)

        async def __aenter__(self):
            return self

        async def __aexit__(self, *args):
            return None

        async def __aiter__(self):
            return self

        async def __anext__(self):
            raise StopAsyncIteration

@pytest.mark.asyncio
async def test_initialization():
    """Test that manager initializes with correct parameters"""
    manager = ThreadedApiManager(
        api_key="test_key",
        api_secret="test_secret",
        tld="com",
        testnet=True,
        requests_params={"timeout": 10},
        session_params={"trust_env": True},
    )

    assert manager._running is True
    assert manager._socket_running == {}
    assert manager._client_params == {
        "api_key": "test_key",
        "api_secret": "test_secret",
        "requests_params": {"timeout": 10},
        "tld": "com",
        "testnet": True,
        "session_params": {"trust_env": True},
        "https_proxy": None,
    }


@pytest.mark.asyncio
async def test_start_and_stop_socket(manager):
    """Test starting and stopping a socket"""
    socket_name = "test_socket"

    # AsyncMock socket creation
    mock_socket = AsyncMock()
    mock_socket.__aenter__ = AsyncMock(return_value=mock_socket)
    mock_socket.__aexit__ = AsyncMock(return_value=None)

    # Track number of recv calls
    recv_count = 0
    async def controlled_recv():
        nonlocal recv_count
        recv_count += 1
        # If we've stopped the socket or read enough times, simulate connection closing
        if not manager._socket_running.get(socket_name) or recv_count > 2:
            raise websockets.exceptions.ConnectionClosed(None, None)
        await asyncio.sleep(0.1)
        return '{"e": "value"}'

    mock_socket.recv = controlled_recv

    # AsyncMock callback
    callback = AsyncMock()

    # Start socket listener
    manager._socket_running[socket_name] = True
    listener_task = asyncio.create_task(
        manager.start_listener(mock_socket, socket_name, callback)
    )

    # Give some time for the listener to start and receive a message
    await asyncio.sleep(0.2)

    # Stop the socket
    manager.stop_socket(socket_name)

    # Wait for the listener task to complete
    try:
        await asyncio.wait_for(listener_task, timeout=1.0)
    except (asyncio.TimeoutError, websockets.exceptions.ConnectionClosed):
        pass  # These exceptions are expected during shutdown

    assert socket_name not in manager._socket_running


@pytest.mark.asyncio
async def test_socket_listener_timeout(manager):
    """Test socket listener handling timeout"""
    socket_name = "test_socket"

    # AsyncMock socket that times out every time
    mock_socket = AsyncMock()
    mock_socket.__aenter__ = AsyncMock(return_value=mock_socket)
    mock_socket.__aexit__ = AsyncMock(return_value=None)

    async def controlled_recv():
        await asyncio.sleep(0.1)
        raise asyncio.TimeoutError("Simulated Timeout")

    mock_socket.recv = controlled_recv

    callback = AsyncMock()

    # Start socket listener
    manager._socket_running[socket_name] = True
    listener_task = asyncio.create_task(
        manager.start_listener(mock_socket, socket_name, callback)
    )

    # Give some time for a few timeout cycles
    await asyncio.sleep(0.3)

    # Stop the socket
    manager.stop_socket(socket_name)

    # Wait for the listener to finish
    try:
        await asyncio.wait_for(listener_task, timeout=1.0)
    except (asyncio.TimeoutError, websockets.exceptions.ConnectionClosed):
        listener_task.cancel()

    # Callback should not have been called (no successful messages)
    callback.assert_not_called()
    assert socket_name not in manager._socket_running


@pytest.mark.asyncio
async def test_stop_client(manager):
    """Test stopping the client"""
    # AsyncMock AsyncClient
    mock_client = AsyncMock()
    mock_client.close_connection = AsyncMock()
    manager._client = mock_client

    await manager.stop_client()
    mock_client.close_connection.assert_called_once()


@pytest.mark.asyncio
async def test_stop(manager):
    """Test stopping the manager"""
    socket_name = "test_socket"
    manager._socket_running[socket_name] = True

    manager.stop()

    assert manager._running is False
    assert manager._socket_running[socket_name] is False


@pytest.mark.asyncio
async def test_multiple_sockets(manager):
    """Test managing multiple sockets"""
    socket_names = ["socket1", "socket2", "socket3"]

    # Start multiple sockets
    for name in socket_names:
        manager._socket_running[name] = True

    # Stop all sockets
    manager.stop()

    # Verify all sockets are stopped
    for name in socket_names:
        assert manager._socket_running[name] is False


@pytest.mark.asyncio
async def test_stop_client_when_not_initialized(manager):
    """Test stopping client when it hasn't been initialized"""
    manager._client = None
    await manager.stop_client()  # Should not raise any exception


@pytest.mark.asyncio
async def test_stop_when_already_stopped(manager):
    """Test stopping manager when it's already stopped"""
    manager._running = False
    manager.stop()  # Should not raise any exception or change state
    assert manager._running is False

</document_content>
</document>
<document index="78">
<source>tests/test_ws_api.py</source>
<document_content>
import json
import sys
import re
import pytest
import asyncio
from binance import AsyncClient

from binance.exceptions import BinanceAPIException, BinanceWebsocketUnableToConnect
from binance.ws.constants import WSListenerState
from .test_get_order_book import assert_ob
from .conftest import proxy


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_ws_api_public_endpoint(clientAsync):
    """Test normal order book request"""
    order_book = await clientAsync.ws_get_order_book(symbol="BTCUSDT")
    assert_ob(order_book)


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_ws_api_private_endpoint(clientAsync):
    """Test normal order book request"""
    orders = await clientAsync.ws_get_all_orders(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_ws_futures_public_endpoint(futuresClientAsync):
    """Test normal order book request"""
    order_book = await futuresClientAsync.ws_futures_get_order_book(symbol="BTCUSDT")
    assert_ob(order_book)


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_ws_futures_private_endpoint(futuresClientAsync):
    """Test normal order book request"""
    await futuresClientAsync.ws_futures_v2_account_position(symbol="BTCUSDT")


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_ws_get_symbol_ticker(clientAsync):
    """Test symbol ticker request"""
    ticker = await clientAsync.ws_get_symbol_ticker(symbol="BTCUSDT")
    assert "symbol" in ticker
    assert ticker["symbol"] == "BTCUSDT"


@pytest.mark.asyncio
async def test_invalid_request(clientAsync):
    """Test error handling for invalid symbol"""
    with pytest.raises(
        BinanceAPIException,
        match=re.escape(
            "APIError(code=-1100): Illegal characters found in parameter 'symbol'; legal range is '^[A-Z0-9-_.]{1,20}$'."
        ),
    ):
        await clientAsync.ws_get_order_book(symbol="send error")


@pytest.mark.asyncio
async def test_connection_handling(clientAsync):
    """Test connection handling and reconnection"""
    # First request should establish connection
    await clientAsync.ws_get_order_book(symbol="BTCUSDT")
    assert clientAsync.ws_api.ws_state == WSListenerState.STREAMING

    # Force connection close
    await clientAsync.close_connection()
    assert clientAsync.ws_api.ws_state == WSListenerState.EXITING
    assert clientAsync.ws_api.ws is None

    # Next request should reconnect
    order_book = await clientAsync.ws_get_order_book(symbol="LTCUSDT")
    assert_ob(order_book)
    assert clientAsync.ws_api.ws_state == WSListenerState.STREAMING


@pytest.mark.asyncio
async def test_timeout_handling(clientAsync):
    """Test request timeout handling"""
    # Set very short timeout to force timeout error
    original_timeout = clientAsync.ws_api.TIMEOUT
    clientAsync.ws_api.TIMEOUT = 0.0001

    try:
        with pytest.raises(BinanceWebsocketUnableToConnect, match="Request timed out"):
            await clientAsync.ws_get_order_book(symbol="BTCUSDT")
    finally:
        clientAsync.ws_api.TIMEOUT = original_timeout


@pytest.mark.asyncio
async def test_multiple_requests(clientAsync):
    """Test multiple concurrent requests"""
    symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT"]
    tasks = [clientAsync.ws_get_order_book(symbol=symbol) for symbol in symbols]
    results = await asyncio.gather(*tasks)
    assert len(results) == len(symbols)
    for result in results:
        assert_ob(result)


@pytest.mark.asyncio
async def test_testnet_url():
    """Test testnet URL configuration"""
    testnet_client = AsyncClient(testnet=True, https_proxy=proxy)
    try:
        assert testnet_client.ws_api._url == testnet_client.WS_API_TESTNET_URL
        order_book = await testnet_client.ws_get_order_book(symbol="BTCUSDT")
        assert_ob(order_book)
    finally:
        await testnet_client.close_connection()


@pytest.mark.asyncio
async def test_message_handling(clientAsync):
    """Test message handling with various message types"""
    try:
        # Test valid message
        future = asyncio.Future()
        clientAsync.ws_api._responses["123"] = future
        valid_msg = {"id": "123", "status": 200, "result": {"test": "data"}}
        clientAsync.ws_api._handle_message(json.dumps(valid_msg))
        result = await clientAsync.ws_api._responses["123"]
        assert result == valid_msg
    finally:
        await clientAsync.close_connection()

@pytest.mark.asyncio
async def test_message_handling_raise_exception(clientAsync):
    try:
        with pytest.raises(BinanceAPIException):
            future = asyncio.Future()
            clientAsync.ws_api._responses["123"] = future
            valid_msg = {"id": "123", "status": 400, "error": {"code": "0", "msg": "error message"}}
            clientAsync.ws_api._handle_message(json.dumps(valid_msg))
            await future
    finally:
        await clientAsync.close_connection()

@pytest.mark.asyncio
async def test_message_handling_raise_exception_without_id(clientAsync):
    try:
        with pytest.raises(BinanceAPIException):
            future = asyncio.Future()
            clientAsync.ws_api._responses["123"] = future
            valid_msg = {"id": "123", "status": 400, "error": {"code": "0", "msg": "error message"}}
            clientAsync.ws_api._handle_message(json.dumps(valid_msg))
            await future
    finally:
        await clientAsync.close_connection()


@pytest.mark.asyncio
async def test_message_handling_invalid_json(clientAsync):
    try:
        with pytest.raises(json.JSONDecodeError):
            clientAsync.ws_api._handle_message("invalid json")

        with pytest.raises(json.JSONDecodeError):
            clientAsync.ws_api._handle_message("invalid json")
    finally:
        # Ensure cleanup
        await clientAsync.close_connection()


@pytest.mark.asyncio(scope="function")
async def test_connection_failure(clientAsync):
    """Test handling of connection failures"""
    # Set invalid URL
    clientAsync.ws_api._url = "wss://invalid.url"

    with pytest.raises(BinanceWebsocketUnableToConnect, match="Connection failed"):
        await clientAsync.ws_get_order_book(symbol="BTCUSDT")


@pytest.mark.asyncio(scope="function")
async def test_cleanup_on_exit(clientAsync):
    """Test cleanup of resources on exit"""
    # Create some pending requests
    future = asyncio.Future()
    clientAsync.ws_api._responses["test"] = future

    # Close connection
    await clientAsync.close_connection()

    # Check cleanup
    assert "test" not in clientAsync.ws_api._responses
    assert future.exception() is not None


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_ws_queue_overflow(clientAsync):
    """WebSocket API should not overflow queue"""
    #
    original_size = clientAsync.ws_api.max_queue_size
    clientAsync.ws_api.max_queue_size = 1

    try:
        # Request multiple order books concurrently
        symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT"]
        tasks = [clientAsync.ws_get_order_book(symbol=symbol) for symbol in symbols]

        # Execute all requests concurrently and wait for results
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Check that we got valid responses or expected overflow errors
        valid_responses = [r for r in results if not isinstance(r, Exception)]
        assert len(valid_responses) == len(symbols), "Should get at least one valid response"

        for result in valid_responses:
            assert_ob(result)

    finally:
        # Restore original queue size
        clientAsync.ws_api.MAX_QUEUE_SIZE = original_size


@pytest.mark.skipif(sys.version_info < (3, 8), reason="websockets_proxy Python 3.8+")
@pytest.mark.asyncio
async def test_ws_api_with_stream(clientAsync):
    """Test combining WebSocket API requests with stream listening"""
    from binance import BinanceSocketManager

    # Create socket manager and trade socket
    bm = BinanceSocketManager(clientAsync)
    ts = bm.trade_socket("BTCUSDT")

    async with ts:
        # Make WS API request while stream is active
        order_book = await clientAsync.ws_get_order_book(symbol="BTCUSDT")
        assert_ob(order_book)

        # Verify we can still receive stream data
        trade = await ts.recv()
        assert "s" in trade  # Symbol
        assert "p" in trade  # Price
        assert "q" in trade  # Quantity

</document_content>
</document>
<document index="79">
<source>tests/utils.py</source>
<document_content>
def test_multiple_objects(obj_list, assertion_func):
    """
    Generic test function for validating multiple objects

    Args:
        client_response: List or iterator of objects to validate
        assertion_func: Function to use for asserting each object's structure
    """
    assert obj_list is not None, "Response should not be None"

    # Handle both lists and iterators
    objects = list(obj_list)

    # Validate each object
    for obj in objects:
        assertion_func(obj)

</document_content>
</document>
<document index="80">
<source>tox.ini</source>
<document_content>
[tox]
envlist = py38, py39, py310, py311, py312

[testenv]
deps =
  -rtest-requirements.txt
  -rrequirements.txt
passenv =
    PROXY
    TEST_TESTNET
    TEST_API_KEY
    TEST_API_SECRET
    TEST_FUTURES_API_KEY
    TEST_FUTURES_API_SECRET
commands = pytest -n 5 -v tests/ --timeout=90 --doctest-modules --cov binance --cov-report term-missing --cov-report xml --reruns 3 --reruns-delay 30

[pep8]
ignore = E501

</document_content>
</document>
</documents>