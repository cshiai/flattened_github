<documents>
<document index="1">
<source>.github/workflows/clippy.yml</source>
<document_content>
on: push
name: Clippy check
jobs:
  clippy_check:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        rust_channel:
          - stable
          - nightly
    steps:
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy
      - run: rustup --version
      - uses: actions/checkout@v4
      - run: rustup toolchain add --profile=minimal ${{ matrix.rust_channel }}
      - name: Cargo cache
        uses: swatinem/rust-cache@v2
        with:
          cache-on-failure: true
      - name: Install SARIF tools
        run: cargo install clippy-sarif sarif-fmt
      - name: Run clippy
        run: >
          cargo clippy --all-features --all --message-format=json -- -D warnings
          | clippy-sarif
          | tee clippy-results.sarif
          | sarif-fmt
        continue-on-error: true
      - name: Upload analysis results to GitHub
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: clippy-results.sarif
          wait-for-processing: true

</document_content>
</document>
<document index="2">
<source>.github/workflows/onrelease.yml</source>
<document_content>
name: Release a crate
on:
  pull_request:
    types: closed
    branches: [master]

jobs:
  info:
    if: github.event.pull_request.merged
    outputs:
      go: ${{ steps.meta.outputs.is-release }}
      crate: ${{ steps.meta.outputs.crate-names }}
      version: ${{ steps.meta.outputs.version-actual }}
      notes: ${{ steps.meta.outputs.notes }}

    runs-on: ubuntu-latest
    steps:
      - id: meta
        uses: cargo-bins/release-meta@v1
        with:
          event-data: ${{ toJSON(github.event) }}
          extract-notes-under: '### Release notes'

  release:
    needs: info
    if: needs.info.go == 'true'

    strategy:
      fail-fast: false
      matrix:
        include:
          - { o: macos-latest,    t: x86_64-apple-darwin        }
          - { o: macos-latest,    t: aarch64-apple-darwin       }
          - { o: ubuntu-latest,   t: x86_64-unknown-linux-musl  }
          - { o: ubuntu-latest,   t: aarch64-unknown-linux-musl }
          - { o: windows-latest,  t: x86_64-pc-windows-msvc     }
          - { o: windows-latest,  t: aarch64-pc-windows-msvc    }

    name: ${{ matrix.t }}
    runs-on: ${{ matrix.o }}
    steps:
      - run: echo ${{ needs.info.outputs.go }}
      - uses: actions/checkout@v4
      - uses: cargo-bins/release-rust@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          publish-token: ${{ secrets.CRATES_TOKEN }}
          toolchain: stable
          target: ${{ matrix.t }}
          crates: ${{ needs.info.outputs.crate }}
          release-tag: v${{ needs.info.outputs.version }}
          release-notes: ${{ needs.info.outputs.notes }}

</document_content>
</document>
<document index="3">
<source>.github/workflows/release.yml</source>
<document_content>
name: Open a release PR
on:
  workflow_dispatch:
    inputs:
      version:
        description: Version to release
        required: true
        type: string

jobs:
  make-release-pr:
    permissions:
      id-token: write # Enable OIDC
      pull-requests: write
      contents: write
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: chainguard-dev/actions/setup-gitsign@main
      - name: Install cargo-release
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-release

      - uses: cargo-bins/release-pr@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          version: ${{ inputs.version }}
          check-semver: false
          pr-title: "Release <%= crate.name %> <%= version.actual %> (was <%= version.previous %>)"
          pr-release-notes: true


</document_content>
</document>
<document index="4">
<source>.github/workflows/rust.yml</source>
<document_content>
name: Rust

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        rust_channel:
          - stable
          - nightly
    steps:
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy
      - run: rustup --version
        name: Check rustup
      - uses: actions/checkout@v4
      - run: rustup toolchain add --profile=minimal ${{ matrix.rust_channel }}
        name: Install toolchain
      - run: cargo clippy --all-features --all-targets -- -D warnings
        name: Clippy check
      - name: Cargo cache
        uses: swatinem/rust-cache@v2
        with:
          cache-on-failure: true
      - name: Install SARIF tools
        run: cargo install clippy-sarif sarif-fmt
      - name: Run clippy
        run: >
          cargo clippy --all-features --all --message-format=json -- -D warnings
          | clippy-sarif
          | tee clippy-results.sarif
          | sarif-fmt
        continue-on-error: true
      - name: Upload analysis results to GitHub
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: clippy-results.sarif
          wait-for-processing: true
      - name: Build
        run: cargo build --verbose
      - name: Run tests
        run: cargo test --verbose

</document_content>
</document>
<document index="5">
<source>.gitignore</source>
<document_content>
target
Cargo.lock
precommit_venv

*.fmt
*.iml
.idea
.env

release.json
secrets

</document_content>
</document>
<document index="6">
<source>.pre-commit-config.yaml</source>
<document_content>
-   repo: local
    hooks:
      -   id: rust-linting
          name: Rust linting
          description: Run cargo fmt on files included in the commit. rustfmt should be installed before-hand.
          entry: bash -c 'cargo fmt --all --'
          pass_filenames: true
          types: [file, rust]
          language: system
      -   id: rust-clippy
          name: Rust clippy
          description: Run cargo clippy on files included in the commit. clippy should be installed before-hand.
          entry: bash -c 'cargo clippy --all-targets --all-features -- -Dclippy::all'
          pass_filenames: false
          types: [file, rust]
          language: system

</document_content>
</document>
<document index="7">
<source>.requirements-precommit.txt</source>
<document_content>
pre-commit==1.14.4

</document_content>
</document>
<document index="8">
<source>.travis.yml</source>
<document_content>
language: rust
sudo: false
dist: trusty
matrix:
    fast_finish: true
    include:
        - rust: stable

cache:
    apt: true
    directories:
        - target/debug/deps
        - target/debug/build

</document_content>
</document>
<document index="9">
<source>Cargo.toml</source>
<document_content>
[package]
name = "binance-rs-async"
version = "1.3.3"
license = "MIT OR Apache-2.0"
authors = ["Guillaume Balaine igosuki.github@gmail.com"]
edition = "2021"

description = "Async Rust Library for the Binance API"
keywords = ["cryptocurrency", "trading", "binance"]
documentation = "https://docs.rs/crate/binance-rs-async/"
repository = "https://github.com/Igosuki/binance-rs-async"
readme = "README.md"

[lib]
name = "binance"
path = "src/lib.rs"

[features]
rustls-tls = ["tokio-tungstenite/rustls-tls-webpki-roots", "reqwest/rustls-tls"]
native-tls = ["tokio-tungstenite/native-tls", "reqwest/native-tls"]
default = ["native-tls", "futures_api"]
futures_api = []
margin_api = []
savings_api = []
wallet_api = []
all_apis = ["futures_api", "margin_api", "savings_api", "wallet_api"]

[dependencies]
chrono = { version = "0.4", features = ["serde"] }
futures = "0.3"
hex = "0.4"
reqwest = { version = "0.12", features = ["json"], default-features = false }
ring = "0.17"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_qs = "0.13"
serde_repr = "0.1"
thiserror = "1.0"
url = "2.5"
tokio-tungstenite = "0.21"
tokio = { version = "1.37", default-features = false, features = ["net", "sync"] }

[dev-dependencies]
csv = "1.3"
env_logger = "0.11"
tracing = { version = "0.1", features = ["release_max_level_debug", "log"] }
tokio = { version = "1.37", default-features = false, features = ["macros", "rt", "rt-multi-thread", "signal"] }
tokio-test = "0.4"

</document_content>
</document>
<document index="10">
<source>LICENSE</source>
<document_content>
Copyright (c) 2020 Guillaume Balaine (igosuki.github@gmail.com)

Licensed under either of

 * Apache License, Version 2.0, (http://www.apache.org/licenses/LICENSE-2.0)
 * MIT license (http://opensource.org/licenses/MIT)

at your option.

</document_content>
</document>
<document index="11">
<source>Makefile</source>
<document_content>
VENV := precommit_venv
HOOKS := .git/hooks/pre-commit

# PRE-COMMIT HOOKS

$(VENV): .requirements-precommit.txt
	virtualenv -p python3 $(VENV)
	$(VENV)/bin/pip install -r .requirements-precommit.txt

.PHONY: env
env: $(VENV)

.PHONY: clean-env
clean-env:
	rm -rf $(VENV)

## Cargo
CARGO_BIN ?= `which cargo`
TARGET_PATH ?= `pwd`/target/release
BIN_VERSION ?= 0.1.0
BIN_NAME ?= voik
BIN_PATH ?= $(TARGET_PATH)/$(BIN_NAME)

## Testing
FUNZZY_BIN ?= `which funzzy`

PWD ?= `pwd`

HOME ?= `echo $HOME`

$(HOOKS): $(VENV) .pre-commit-config.yaml
	$(VENV)/bin/pre-commit install -f --install-hooks
	@$(CARGO_BIN) fmt --help > /dev/null || rustup component add rustfmt
	@$(CARGO_BIN) clippy --help > /dev/null || rustup component add clippy
	@$(CARGO_BIN) readme --help > /dev/null || cargo install cargo-readme

.PHONY: install-hooks
install-hooks: $(HOOKS)

.PHONY: clean-hooks
clean-hooks:
	rm -rf $(HOOKS)


.PHONY: build
build:
	@$(CARGO_BIN) build

.PHONY: build_all
build_all:
	@$(CARGO_BIN) build --all-features

.PHONY: test
test_all: ## Tests all features
	@$(CARGO_BIN) test --all-features

test: ## Tests all features
	RUST_LOG=info BITCOINS_REPO=$(shell pwd) $(CARGO_BIN) test --all-targets -- --skip coinnect_tests --skip coinbase_tests --nocapture

.PHONY: coverage
coverage: ## Tests all features
	@$(CARGO_BIN) tarpaulin -v

.PHONY: test_watcher ## Starts funzzy, test watcher, to run the tests on every change
test_watcher:
	@$(FUNZZY_BIN)

.PHONY: bench
bench:
	@$(CARGO_BIN) bench

.PHONY: profile
profile:
	@$(CARGO_BIN) flamegraph --dev --bin=trader --features flame_it

.PHONY: lint
lint:
	@$(CARGO_BIN) clippy --all-targets --all-features -Z unstable-options -- -Dclippy::all -Dunused_imports

.PHONY: lintfix
lintfix:
	@$(CARGO_BIN) clippy --fix --all-targets --all-features -Z unstable-options -- -Dclippy::all -Dunused_imports

.PHONY: clean-lint
clean-lint:
	find . -type f -name *.rs.bk -delete

## alias rust-musl-builder-nightly='docker run --cpus=$(nproc) --rm -it --user rust $MUSL_FLAGS -v "$HOME/.cargo/git":/home/rust/.cargo/git -v "$(pwd)/cargo-registry":/home/rust/.cargo/registry -v "$(pwd)/cargo-target":/home/rust/src/target -v "$(pwd)":/home/rust/src ekidd/rust-musl-builder:nightly-2020-06-17'
release:
	$(rust-musl-builder-nightly) cargo build --release --target=x86_64-unknown-linux-gnu

build_test:
	@$(CARGO_BIN) test --message-format=json-diagnostic-rendered-ansi --color=always --no-run --lib $(TEST_NAME) --manifest-path $(MANIFEST_PATH)


</document_content>
</document>
<document index="12">
<source>README.md</source>
<document_content>
# binance-rs-async

Unofficial Rust Library for the [Binance API](https://github.com/binance-exchange/binance-official-api-docs)

This is a fully async api using [tokio](https://tokio.rs/).

## Current state

The current beta aims at implementing every single endpoint on the binance docs. Currently, futures and savings have
been implemented but not thoroughly tested.

## Usage

Add this to your Cargo.toml

```toml
[dependencies]
binance-rs-async = "1.3.3"
```

## Roadmap

- 1.0.0 Completely tested margin sapi endpoints
- 1.0.* Changelog check to detect binance API changes
- 1.1.* Wallet API
- 1.2.* to 1.3.* Continuous updates for wallet and margin APIs
- 1.4.* Complete tested futures (m-coin and usd-m futures)

## Breaking changes
- 1.3.0 introduces optional fields for MarginOrderCancellationResult instead of definitely set fields

## Risk Warning

It is a personal project, use at your own risk. I will not be responsible for your investment losses. Cryptocurrency
investment is subject to high market risk. Nonetheless, this crate is aimed at high performance and production use, I
have been using this to target Binance successfully for several years now.

### Using TLS

By default, the crate uses `native-tls` for tungstenite and reqwest because I believe it's simpler and faster to let the
user switch LibreSSL or OpenSSL versions rather than rebuild the program.

You can however disable default-features and use `rust-tls`, which might be helpful in certain situations such as CI or
dev box.

## Rust >= 1.37

```shell
rustup install stable
```

## Cargo dependencies

```shell
cargo install cargo-semver-checks
```

## Checking documentation and release

```shell
cargo semver-checks check-release --package binance-rs-async --verbose
```

## Contribution

Simply create a pull request. Properly documented code and tests (using binance testnet) are a must.

## Running github actions locally : 

```shell
# Example that runs the make-release-pr workflow 
act -P ubuntu-latest=cimg/rust:1.66.1-node workflow_dispatch -j make-release-pr --eventpath release.json --secret-file=secrets
```

</document_content>
</document>
<document index="13">
<source>docs/margin.md</source>
<document_content>
# Public Rest API for Margin Trade (DRAFT, under construction)
# General API Information
* The base endpoint is: **https://api.binance.com**
* All endpoints return either a JSON object or array.
* Data is returned in **ascending** order. Oldest first, newest last.
* All time and timestamp related fields are in milliseconds.
* HTTP `4XX` return codes are used for for malformed requests;
  the issue is on the sender's side.
* HTTP `429` return code is used when breaking a request rate limit.
* HTTP `418` return code is used when an IP has been auto-banned for continuing to send requests after receiving `429` codes.
* HTTP `5XX` return codes are used for internal errors; the issue is on
  Binance's side.
  It is important to **NOT** treat this as a failure operation; the execution status is
  **UNKNOWN** and could have been a success.
* Any endpoint can return an ERROR; the error payload is as follows:
```javascript
{
  "code": -1121,
  "msg": "Invalid symbol."
}
```

* Specific error codes and messages defined in another document.
* For `GET` endpoints, parameters must be sent as a `query string`.
* For `POST`, `PUT`, and `DELETE` endpoints, the parameters may be sent as a
  `query string` or in the `request body` with content type
  `application/x-www-form-urlencoded`. You may mix parameters between both the
  `query string` and `request body` if you wish to do so.
* Parameters may be sent in any order.
* If a parameter sent in both the `query string` and `request body`, the
  `query string` parameter will be used.


# Endpoint security type
* Each endpoint has a security type that determines the how you will
  interact with it.
* API-keys are passed into the Rest API via the `X-MBX-APIKEY`
  header.
* API-keys and secret-keys **are case sensitive**.
* API-keys can be configured to only access certain types of secure endpoints.
 For example, one API-key could be used for TRADE only, while another API-key
 can access everything except for TRADE routes.
* By default, API-keys can access all secure routes.

Security Type | Description
------------ | ------------
NONE | Endpoint can be accessed freely.
TRADE | Endpoint requires sending a valid API-Key and signature.
USER_DATA | Endpoint requires sending a valid API-Key and signature.
MARGIN | Endpoint requires sending a valid API-Key and signature.
USER_STREAM | Endpoint requires sending a valid API-Key.
MARKET_DATA | Endpoint requires sending a valid API-Key.


* `TRADE` and `USER_DATA` endpoints are `SIGNED` endpoints.

# SIGNED (TRADE„ÄÅUSER_DATA AND MARGIN) Endpoint security
* `SIGNED` endpoints require an additional parameter, `signature`, to be
  sent in the  `query string` or `request body`.
* Endpoints use `HMAC SHA256` signatures. The `HMAC SHA256 signature` is a keyed `HMAC SHA256` operation.
  Use your `secretKey` as the key and `totalParams` as the value for the HMAC operation.
* The `signature` is **not case sensitive**.
* `totalParams` is defined as the `query string` concatenated with the
  `request body`.

## Timing security
* A `SIGNED` endpoint also requires a parameter, `timestamp`, to be sent which
  should be the millisecond timestamp of when the request was created and sent.
* An additional parameter, `recvWindow`, may be sent to specify the number of
  milliseconds after `timestamp` the request is valid for. If `recvWindow`
  is not sent, **it defaults to 5000**.
* The logic is as follows:
  ```javascript
  if (timestamp < (serverTime + 1000) && (serverTime - timestamp) <= recvWindow) {
    // process request
  } else {
    // reject request
  }
  ```

**Serious trading is about timing.** Networks can be unstable and unreliable,
which can lead to requests taking varying amounts of time to reach the
servers. With `recvWindow`, you can specify that the request must be
processed within a certain number of milliseconds or be rejected by the
server.


**It recommended to use a small recvWindow of 5000 or less!**


## SIGNED Endpoint Examples for POST /api/v1/order
Here is a step-by-step example of how to send a vaild signed payload from the
Linux command line using `echo`, `openssl`, and `curl`.

Key | Value
------------ | ------------
apiKey | vmPUZE6mv9SD5VNHk4HlWFsOr6aKE2zvsw0MuIgwCIPy6utIco14y7Ju91duEh8A
secretKey | NhqPtmdSJYdKjVHjA7PZj4Mge3R5YNiP1e3UZjInClVN65XAbvqqM6A7H5fATj0j


Parameter | Value
------------ | ------------
symbol | LTCBTC
side | BUY
type | LIMIT
timeInForce | GTC
quantity | 1
price | 0.1
recvWindow | 5000
timestamp | 1499827319559


### Example 1: As a query string
* **queryString:** symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTC&quantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559
* **HMAC SHA256 signature:**

    ```
    [linux]$ echo -n "symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTC&quantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559" | openssl dgst -sha256 -hmac "NhqPtmdSJYdKjVHjA7PZj4Mge3R5YNiP1e3UZjInClVN65XAbvqqM6A7H5fATj0j"
    (stdin)= c8db56825ae71d6d79447849e617115f4a920fa2acdcab2b053c4b2838bd6b71
    ```


* **curl command:**

    ```
    (HMAC SHA256)
    [linux]$ curl -H "X-MBX-APIKEY: vmPUZE6mv9SD5VNHk4HlWFsOr6aKE2zvsw0MuIgwCIPy6utIco14y7Ju91duEh8A" -X POST 'https://api.binance.com/api/v1/order?symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTC&quantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559&signature=c8db56825ae71d6d79447849e617115f4a920fa2acdcab2b053c4b2838bd6b71'
    ```

### Example 2: As a request body
* **requestBody:** symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTC&quantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559
* **HMAC SHA256 signature:**

    ```
    [linux]$ echo -n "symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTC&quantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559" | openssl dgst -sha256 -hmac "NhqPtmdSJYdKjVHjA7PZj4Mge3R5YNiP1e3UZjInClVN65XAbvqqM6A7H5fATj0j"
    (stdin)= c8db56825ae71d6d79447849e617115f4a920fa2acdcab2b053c4b2838bd6b71
    ```


* **curl command:**

    ```
    (HMAC SHA256)
    [linux]$ curl -H "X-MBX-APIKEY: vmPUZE6mv9SD5VNHk4HlWFsOr6aKE2zvsw0MuIgwCIPy6utIco14y7Ju91duEh8A" -X POST 'https://api.binance.com/api/v1/order' -d 'symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTC&quantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559&signature=c8db56825ae71d6d79447849e617115f4a920fa2acdcab2b053c4b2838bd6b71'
    ```

### Example 3: Mixed query string and request body
* **queryString:** symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTC
* **requestBody:** quantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559
* **HMAC SHA256 signature:**

    ```
    [linux]$ echo -n "symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTCquantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559" | openssl dgst -sha256 -hmac "NhqPtmdSJYdKjVHjA7PZj4Mge3R5YNiP1e3UZjInClVN65XAbvqqM6A7H5fATj0j"
    (stdin)= 0fd168b8ddb4876a0358a8d14d0c9f3da0e9b20c5d52b2a00fcf7d1c602f9a77
    ```


* **curl command:**

    ```
    (HMAC SHA256)
    [linux]$ curl -H "X-MBX-APIKEY: vmPUZE6mv9SD5VNHk4HlWFsOr6aKE2zvsw0MuIgwCIPy6utIco14y7Ju91duEh8A" -X POST 'https://api.binance.com/api/v1/order?symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTC' -d 'quantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559&signature=0fd168b8ddb4876a0358a8d14d0c9f3da0e9b20c5d52b2a00fcf7d1c602f9a77'
    ```

Note that the signature is different in example 3.
There is no & between "GTC" and "quantity=1".



## General endpoints
### Margin account transfer (MARGIN)
```
Post /sapi/v1/margin/transfer 
```
Execute transfer between spot account and margin account.

**Weight:**
1

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
asset | STRING | YES | The asset being transferred, e.g., BTC
amount | DECIMAL | YES | The amount to be transferred
type | INT | YES | 1: transfer from main account to margin account 2: transfer from margin account to main account
recvWindow | LONG | NO
timestamp | LONG | YES


**Response:**
```javascript
{
    //transaction id
    "tranId": 100000001
}
```

### Margin account borrow (MARGIN)
```
Post /sapi/v1/margin/loan 
```
Apply for a loan.

**Weight:**
1

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
asset | STRING | YES | 
amount | DECIMAL | YES | 
recvWindow | LONG | NO
timestamp | LONG | YES

**Response:**
```javascript
{
    //transaction id
    "tranId": 100000001
}
```

### Margin account repay (MARGIN)
```
Post /sapi/v1/margin/repay
```
Repay loan for margin account.

**Weight:**
1

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
asset | STRING | YES | 
amount | DECIMAL | YES | 
recvWindow | LONG | NO
timestamp | LONG | YES

**Response:**
```javascript
{
    //transaction id
    "tranId": 100000001
}
```

### Margin account new order (TRADE)
```
Post  /sapi/v1/margin/order
```
Post a new order for margin account.

**Weight:**
1

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
symbol | STRING | YES |
side |	ENUM |YES |	BUY<br>SELL
type | ENUM | YES	
quantity | DECIMAL |	YES	
price |	DECIMAL | NO	
stopPrice | DECIMAL | NO | Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
newClientOrderId | STRING | NO | A unique id for the order. Automatically generated if not sent.
icebergQty | DECIMAL | NO | Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
newOrderRespType | ENUM | NO | Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
timeInForce | ENUM | NO | GTC,IOC,FOK
recvWindow | LONG | NO
timestamp | LONG | YES

**Response ACK:**
```javascript
{
  "symbol": "BTCUSDT",
  "orderId": 28,
  "clientOrderId": "6gCrw2kRUAF9CvJDGP16IP",
  "transactTime": 1507725176595
}
```
**Response RESULT:**
```javascript
{
  "symbol": "BTCUSDT",
  "orderId": 28,
  "clientOrderId": "6gCrw2kRUAF9CvJDGP16IP",
  "transactTime": 1507725176595,
  "price": "1.00000000",
  "origQty": "10.00000000",
  "executedQty": "10.00000000",
  "cummulativeQuoteQty": "10.00000000",
  "status": "FILLED",
  "timeInForce": "GTC",
  "type": "MARKET",
  "side": "SELL"
}
```
**Response FULL:**
```javascript
{
  "symbol": "BTCUSDT",
  "orderId": 28,
  "clientOrderId": "6gCrw2kRUAF9CvJDGP16IP",
  "transactTime": 1507725176595,
  "price": "1.00000000",
  "origQty": "10.00000000",
  "executedQty": "10.00000000",
  "cummulativeQuoteQty": "10.00000000",
  "status": "FILLED",
  "timeInForce": "GTC",
  "type": "MARKET",
  "side": "SELL",
  "fills": [
    {
      "price": "4000.00000000",
      "qty": "1.00000000",
      "commission": "4.00000000",
      "commissionAsset": "USDT"
    },
    {
      "price": "3999.00000000",
      "qty": "5.00000000",
      "commission": "19.99500000",
      "commissionAsset": "USDT"
    },
    {
      "price": "3998.00000000",
      "qty": "2.00000000",
      "commission": "7.99600000",
      "commissionAsset": "USDT"
    },
    {
      "price": "3997.00000000",
      "qty": "1.00000000",
      "commission": "3.99700000",
      "commissionAsset": "USDT"
    },
    {
      "price": "3995.00000000",
      "qty": "1.00000000",
      "commission": "3.99500000",
      "commissionAsset": "USDT"
    }
  ]
}
```

### Margin account cancel order (TRADE)
```
Delete /sapi/v1/margin/order
```
Cancel an active order for margin account.

**Weight:**
1

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
symbol | STRING | YES |
orderId | LONG | NO | 
origClientOrderId |	STRING | NO	
newClientOrderId |	STRING | NO | Used to uniquely identify this cancel. Automatically generated by default.
recvWindow | LONG | NO
timestamp | LONG | YES

Either orderId or origClientOrderId must be sent.

**Response:**
```javascript
{
  "symbol": "LTCBTC",
  "orderId": 28,
  "origClientOrderId": "myOrder1",
  "clientOrderId": "cancelMyOrder1",
  "transactTime": 1507725176595,
  "price": "1.00000000",
  "origQty": "10.00000000",
  "executedQty": "8.00000000",
  "cummulativeQuoteQty": "8.00000000",
  "status": "CANCELED",
  "timeInForce": "GTC",
  "type": "LIMIT",
  "side": "SELL"
}
```

### Query loan record (USER_DATA)
```
Get /sapi/v1/margin/loan
```

**Weight:**
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
asset |	STRING | YES	
txId | LONG | NO | the tranId in POST /sapi/v1/margin/loan
startTime |	LONG |	NO	
endTime | LONG | NO	
current | LONG | NO | Currently querying page. Start from 1. Default:1
size |	LONG | NO |	Default:10 Max:100
recvWindow | LONG | NO
timestamp | LONG | YES

txId or startTime must be sent. txId takes precedence.

**Response:**
```javascript
{
  "rows": [
    {
      "asset": "BNB",
      "principal": "0.84624403",
      "timestamp": 1555056425000,
      //one of PENDING (pending to execution), CONFIRMED (successfully loaned), FAILED (execution failed, nothing happened to your account);
      "status": "CONFIRMED"
    }
  ],
  "total": 1
}
```

### Query repay record (USER_DATA)
```
Get /sapi/v1/margin/repay
```

**Weight:**
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
asset | STRING |	YES	
txId | LONG | NO | return of /sapi/v1/margin/repay 
startTime | LONG | NO	
endTime | LONG | NO	
current | LONG | NO	| Currently querying page. Start from 1. Default:1
size | LONG | NO | Default:10 Max:100
recvWindow | LONG | NO
timestamp | LONG | YES

txId or startTime must be sent. txId takes precedence.


**Response:**
```javascript
{
     "rows": [
         {
             //Total amount repaid
             "amount": "14.00000000",
             "asset": "BNB",
             //Interest repaid
             "interest": "0.01866667",
             //Principal repaid
             "principal": "13.98133333",
             //one of PENDING (pending to execution), CONFIRMED (successfully loaned), FAILED (execution failed, nothing happened to your account);
             "status": "CONFIRMED",
             "timestamp": 1563438204000,
             "txId": 2970933056
         }
     ],
     "total": 1
}
```

### Query margin account details (USER_DATA)
```
Get /sapi/v1/margin/account
```

**Weight:**
5

**Parameters:**

None

**Response:**
```javascript
{
      "borrowEnabled": true,
      "marginLevel": "11.64405625",
      "totalAssetOfBtc": "6.82728457",
      "totalLiabilityOfBtc": "0.58633215",
      "totalNetAssetOfBtc": "6.24095242",
      "tradeEnabled": true,
      "transferEnabled": true,
      "userAssets": [
          {
              "asset": "BTC",
              "borrowed": "0.00000000",
              "free": "0.00499500",
              "interest": "0.00000000",
              "locked": "0.00000000",
              "netAsset": "0.00499500"
          },
          {
              "asset": "BNB",
              "borrowed": "201.66666672",
              "free": "2346.50000000",
              "interest": "0.00000000",
              "locked": "0.00000000",
              "netAsset": "2144.83333328"
          },
          {
              "asset": "ETH",
              "borrowed": "0.00000000",
              "free": "0.00000000",
              "interest": "0.00000000",
              "locked": "0.00000000",
              "netAsset": "0.00000000"
          },
          {
              "asset": "USDT",
              "borrowed": "0.00000000",
              "free": "0.00000000",
              "interest": "0.00000000",
              "locked": "0.00000000",
              "netAsset": "0.00000000"
          }
      ]
}
```


### Query margin asset (MARKET_DATA)

```
Get /sapi/v1/margin/asset 
```

**Weight:**
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
asset | STRING | YES |

**Response:**
```javascript
{
      "assetFullName": "Binance Coin",
      "assetName": "BNB",
      "isBorrowable": false,
      "isMortgageable": true,
      "userMinBorrow": "0.00000000",
      "userMinRepay": "0.00000000"
}
```

### Query margin pair (MARKET_DATA)
```
Get /sapi/v1/margin/pair 
```

**Weight:**
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
symbol | STRING | YES |

**Response:**
```javascript
{
   "id":323355778339572400,
   "symbol":"BTCUSDT",
   "base":"BTC",
   "quote":"USDT",
   "isMarginTrade":true,
   "isBuyAllowed":true,
   "isSellAllowed":true
}
```

### Get all margin assets (MARKET_DATA)

```
Get /sapi/v1/margin/allAssets
```

**Weight:**
5

**Parameters:**

None

**Response:**

```javascript
  [
      {
          "assetFullName": "USD coin",
          "assetName": "USDC",
          "isBorrowable": true,
          "isMortgageable": true,
          "userMinBorrow": "0.00000000",
          "userMinRepay": "0.00000000"
      },
      {
          "assetFullName": "BNB-coin",
          "assetName": "BNB",
          "isBorrowable": true,
          "isMortgageable": true,
          "userMinBorrow": "1.00000000",
          "userMinRepay": "0.00000000"
      },
      {
          "assetFullName": "Tether",
          "assetName": "USDT",
          "isBorrowable": true,
          "isMortgageable": true,
          "userMinBorrow": "1.00000000",
          "userMinRepay": "0.00000000"
      },
      {
          "assetFullName": "etherum",
          "assetName": "ETH",
          "isBorrowable": true,
          "isMortgageable": true,
          "userMinBorrow": "0.00000000",
          "userMinRepay": "0.00000000"
      },
      {
          "assetFullName": "Bitcoin",
          "assetName": "BTC",
          "isBorrowable": true,
          "isMortgageable": true,
          "userMinBorrow": "0.00000000",
          "userMinRepay": "0.00000000"
      }
  ]
```

### Get all margin pairs (MARKET_DATA)
```
Get /sapi/v1/margin/allPairs 
```

**Weight:**
5

**Parameters:**

None

**Response:**

```javascript
[
	{
		"base": "BNB",
  		"id": 351637150141315861,
  		"isBuyAllowed": True,
  		"isMarginTrade": True,
  		"isSellAllowed": True,
  		"quote": "BTC",
  		"symbol": "BNBBTC"
  	},
 	{
 		"base": "TRX",
  		"id": 351637923235429141,
  		"isBuyAllowed": True,
  		"isMarginTrade": True,
  		"isSellAllowed": True,
  		"quote": "BTC",
  		"symbol": "TRXBTC"
  	},
 	{
 		"base": "XRP",
  		"id": 351638112213990165,
  		"isBuyAllowed": True,
  		"isMarginTrade": True,
  		"isSellAllowed": True,
  		"quote": "BTC",
  		"symbol": "XRPBTC"
  	},
 	{
 		"base": "ETH",
  		"id": 351638524530850581,
  		"isBuyAllowed": True,
  		"isMarginTrade": True,
  		"isSellAllowed": True,
  		"quote": "BTC",
  		"symbol": "ETHBTC"
  	},
 	{
 		"base": "BNB",
  		"id": 376870400832855109,
  		"isBuyAllowed": True,
  		"isMarginTrade": True,
  		"isSellAllowed": True,
  		"quote": "USDT",
  		"symbol": "BNBUSDT"
  },
]
```

### Query margin priceIndex (MARKET_DATA)
```
Get /sapi/v1/margin/priceIndex 
```

**Weight:**
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
symbol | STRING | YES |

**Response:**
```javascript
{
   "calcTime": 1562046418000,
   "price": "0.00333930",
   "symbol": "BNBBTC"
}
```

### Get transfer history (USER_DATA)
```
Get /sapi/v1/margin/transfer
```

**Weight:**s
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
asset | STRING | No
type | STRING | YES | Tranfer Type: ROLL_IN, ROLL_OUT
startTime | LONG |	NO	
endTime | LONG | NO	
current | LONG | NO | Currently querying page. Start from 1. Default:1
size |	LONG | NO |	Default:10 Max:100
recvWindow | LONG | NO | The value cannot be greater than ```60000```
timestamp | LONG | YES


**Response:**

```javascript
{
	"rows": [
  	{
  		"amount: "0.10000000",
   		"asset": "BNB",
   		"status": "CONFIRMED",
   		"timestamp": 1566898617,
   		"txId": 5240372201,
   		"type": "ROLL_IN"
  	},
  	{
  		"amount": "5.00000000",
   		"asset": "USDT",
   		"status": "CONFIRMED",
   		"timestamp": 1566888436,
   		"txId": 5239810406,
   		"type": "ROLL_OUT"
  	},
  	{
  		"amount": "1.00000000",
   		"asset": "EOS,
   		"status": "CONFIRMED",
   		"timestamp": 1566888403,
   		"txId": 5239808703,
   		"type": "ROLL_IN"
  	}
 	"total": 3
} 
```

### Get interest history (USER_DATA)
```
Get /sapi/v1/margin/interestHistory
```

**Weight:**s
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
asset | STRING | No
startTime | LONG |	NO	
endTime | LONG | NO	
current | LONG | NO | Currently querying page. Start from 1. Default:1
size |	LONG | NO |	Default:10 Max:100
recvWindow | LONG | NO | The value cannot be greater than ```60000```
timestamp | LONG | YES


**Response:**

```javascript
  {
      "rows": [
          {
              "asset": "BNB",
              "interest": "0.02414667",
              "interestAccuredTime": 1566813600,
              "interestRate": "0.01600000",
              "principal": "36.22000000",
              "type": "ON_BORROW"
          },
          {
              "asset": "BNB",
              "interest": "0.02019334",
              "interestAccuredTime": 1566813600,
              "interestRate": "0.01600000",
              "principal": "30.29000000",
              "type": "ON_BORROW"
          },
          {
              "asset": "BNB",
              "interest": "0.02098667",
              "interestAccuredTime": 1566813600,
              "interestRate": "0.01600000",
              "principal": "31.48000000",
              "type": "ON_BORROW"
          },
          {
              "asset": "BNB",
              "interest": "0.02483334",
              "interestAccuredTime": 1566806400,
              "interestRate": "0.01600000",
              "principal": "37.25000000",
              "type": "ON_BORROW"
          },
          {
              "asset": "BNB",
              "interest": "0.02165334",
              "interestAccuredTime": 1566806400,
              "interestRate": "0.01600000",
              "principal": "32.48000000",
              "type": "ON_BORROW"
          }
      ],
      "total": 5
  }
```

### Get force liquidation record (USER_DATA)
```
Get /sapi/v1/margin/forceLiquidationRec
```

**Weight:**s
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
startTime | LONG |	NO	
endTime | LONG | NO	
current | LONG | NO | Currently querying page. Start from 1. Default:1
size |	LONG | NO |	Default:10 Max:100
recvWindow | LONG | NO | The value cannot be greater than ```60000```
timestamp | LONG | YES


**Response:**

```javascript
  {
      "rows": [
          {
              "avgPrice": "0.00388359",
              "executedQty": "31.39000000",
              "orderId": 180015097,
              "price": "0.00388110",
              "qty": "31.39000000",
              "side": "SELL",
              "symbol": "BNBBTC",
              "timeInForce": "GTC",
              "updatedTime": 1558941374745
          }
      ],
      "total": 1
  }
```



### Query margin account's order (USER_DATA)

```
Get /sapi/v1/margin/order 
```

**Weight:**
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
symbol | STRING | YES |
orderId | STRING | NO |	
origClientOrderId | STRING | NO	|
recvWindow | LONG | NO
timestamp | LONG | YES

Notes:

* Either orderId or origClientOrderId must be sent.
* For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.

**Response:**
```javascript
{
   "clientOrderId": "ZwfQzuDIGpceVhKW5DvCmO",
   "cummulativeQuoteQty": "0.00000000",
   "executedQty": "0.00000000",
   "icebergQty": "0.00000000",
   "isWorking": true,
   "orderId": 213205622,
   "origQty": "0.30000000",
   "price": "0.00493630",
   "side": "SELL",
   "status": "NEW",
   "stopPrice": "0.00000000",
   "symbol": "BNBBTC",
   "time": 1562133008725,
   "timeInForce": "GTC",
   "type": "LIMIT",
   "updateTime": 1562133008725
}
```

### Query margin account's open order (USER_DATA)
```
Get  /sapi/v1/margin/openOrders 
```

**Weight:**
10

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
symbol | STRING | NO |
recvWindow | LONG | NO
timestamp | LONG | YES

* If the symbol is not sent, orders for all symbols will be returned in an array.
* When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange.

**Response:**
```javascript
[
   {
       "clientOrderId": "qhcZw71gAkCCTv0t0k8LUK",
       "cummulativeQuoteQty": "0.00000000",
       "executedQty": "0.00000000",
       "icebergQty": "0.00000000",
       "isWorking": true,
       "orderId": 211842552,
       "origQty": "0.30000000",
       "price": "0.00475010",
       "side": "SELL",
       "status": "NEW",
       "stopPrice": "0.00000000",
       "symbol": "BNBBTC",
       "time": 1562040170089,
       "timeInForce": "GTC",
       "type": "LIMIT",
       "updateTime": 1562040170089
      }
]
```


### Query margin account's all order (USER_DATA)
```
Get /sapi/v1/margin/allOrders 
```

**Weight:**
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
symbol | STRING | YES |
orderId | LONG | NO	
startTime |	LONG | NO	
endTime | LONG | NO	
limit |	INT | NO | Default 500; max 1000.
recvWindow | LONG | NO
timestamp | LONG | YES

Notes:

* If orderId is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
* For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.

**Response:**
```javascript
[
      {
          "id": 43123876,
          "price": "0.00395740",
          "qty": "4.06000000",
          "quoteQty": "0.01606704",
          "symbol": "BNBBTC",
          "time": 1556089977693
      },
      {
          "id": 43123877,
          "price": "0.00395740",
          "qty": "0.77000000",
          "quoteQty": "0.00304719",
          "symbol": "BNBBTC",
          "time": 1556089977693
      },
      {
          "id": 43253549,
          "price": "0.00428930",
          "qty": "23.30000000",
          "quoteQty": "0.09994069",
          "symbol": "BNBBTC",
          "time": 1556163963504
      }
]
```

### Query margin account's trade list (USER_DATA)
```
Get  /sapi/v1/margin/myTrades 
```

**Weight:**
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
symbol | STRING | YES |
startTime |	LONG | NO	
endTime | LONG | NO	
fromId | LONG | NO | TradeId to fetch from. Default gets most recent trades.
limit |	INT | NO | Default 500; max 1000.
recvWindow | LONG | NO
timestamp | LONG | YES

Notes:
* If fromId is set, it will get orders >= that fromId. Otherwise most recent orders are returned.


**Response:**
```javascript
[{
	"commission": "0.00006000",
	"commissionAsset": "BTC",
	"id": 34,
	"isBestMatch": true,
	"isBuyer": false,
	"isMaker": false,
	"orderId": 39324,
	"price": "0.02000000",
	"qty": "3.00000000",
	"symbol": "BNBBTC",
	"time": 1561973357171
},{
	"commission": "0.00002950",
	"commissionAsset": "BTC",
	"id": 32,
	"isBestMatch": true,
	"isBuyer": false,
	"isMaker": true,
	"orderId": 39319,
	"price": "0.00590000",
	"qty": "5.00000000",
	"symbol": "BNBBTC",
	"time": 1561964645345
}]
```

### Query max borrow (USER_DATA)
```
Get /sapi/v1/margin/maxBorrowable 
```

**Weight:**
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
asset | STRING | YES |
recvWindow | LONG | NO
timestamp | LONG | YES

**Response:**
```javascript
{
    "amount": "1.69248805"
}
```

### Query max transfer-out amount (USER_DATA)
```
Get /sapi/v1/margin/maxTransferable 
```

**Weight:**
5

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
asset | STRING | YES |
recvWindow | LONG | NO
timestamp | LONG | YES

**Response:**
```javascript
 {
      "amount": "3.59498107"
 }
```

### Start user data stream for margin account (USER_STREAM)
```
POST  /sapi/v1/userDataStream
```

**Weight:**
1

**Parameters:**

NONE

**Response:**
```javascript
{"listenKey":  "T3ee22BIYuWqmvne0HNq2A2WsFlEtLhvWCtItw6ffhhdmjifQ2tRbuKkTHhr"}
```

### Delete user data stream for margin account  (USER_STREAM)
```
DELETE  /sapi/v1/userDataStream
```

**Weight:**
1

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
listenKey | STRING | YES |

**Response:**
```javascript
{}
```

## Ping user data stream for margin account  (USER_STREAM)
```
PUT  /sapi/v1/userDataStream
```

**Weight:**
1

**Parameters:**

Name | Type | Mandatory | Description
------------ | ------------ | ------------ | ------------
listenKey | STRING | YES |

**Response:**
```javascript
{}
```

</document_content>
</document>
<document index="14">
<source>examples/README.md</source>
<document_content>
# Usage

## Binance Endpoints

cargo run --release --example "binance_endpoints"

## Binance Websockets

cargo run --release --example "binance_websockets"

## Binance Websockets - Save all trades to file

cargo run --release --example "binance_save_all_trades"

</document_content>
</document>
<document index="15">
<source>examples/binance_endpoints.rs</source>
<document_content>
#[macro_use]
extern crate tracing;

use binance::account::*;
use binance::api::*;
use binance::config::Config;
use binance::errors::Error as BinanceLibError;
use binance::general::*;
use binance::market::*;
use binance::rest_model::{OrderSide, OrderType, SymbolPrice, TimeInForce};
use env_logger::Builder;

#[tokio::main]
async fn main() {
    Builder::new().parse_default_env().init();
    info!("running general endpoints");
    general().await;
    info!("running market endpoints");
    market_data().await;
    info!("running account (private) endpoints");
    account().await;
}

async fn general() {
    let general: General = Binance::new(None, None);

    let ping = general.ping().await;
    match ping {
        Ok(answer) => info!("{:?}", answer),
        Err(err) => {
            match err {
                BinanceLibError::BinanceError { response } => match response.code {
                    -1000_i32 => error!("An unknown error occured while processing the request"),
                    _ => error!("Non-catched code {}: {}", response.code, response.msg),
                },
                _ => error!("Other errors: {}.", err),
            };
        }
    }

    let result = general.get_server_time().await;
    match result {
        Ok(answer) => info!("Server Time: {}", answer.server_time),
        Err(e) => error!("Error: {e}"),
    }

    let result = general.exchange_info().await;
    match result {
        Ok(answer) => info!("Exchange information: {:?}", answer),
        Err(e) => error!("Error: {e}"),
    }
}

async fn account() {
    let market: Market = Binance::new(None, None);
    let account: Account = Binance::new_with_env(&Config::testnet());
    let symbol = "BTCUSDT";
    let SymbolPrice { price, .. } = market.get_price(symbol).await.unwrap();
    match account.get_account().await {
        Ok(answer) => info!("{:?}", answer.balances),
        Err(e) => error!("Error: {e}"),
    }

    match account.get_open_orders(symbol).await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    let limit_buy = OrderRequest {
        symbol: symbol.to_string(),
        quantity: Some(0.001),
        price: Some(price),
        order_type: OrderType::Limit,
        side: OrderSide::Buy,
        time_in_force: Some(TimeInForce::FOK),
        ..OrderRequest::default()
    };
    match account.place_order(limit_buy).await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    let market_buy = OrderRequest {
        symbol: symbol.to_string(),
        quantity: Some(0.001),
        order_type: OrderType::Market,
        side: OrderSide::Buy,
        ..OrderRequest::default()
    };
    match account.place_order(market_buy).await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    let limit_sell = OrderRequest {
        symbol: symbol.to_string(),
        quantity: Some(0.001),
        price: Some(price),
        order_type: OrderType::Limit,
        side: OrderSide::Sell,
        time_in_force: Some(TimeInForce::FOK),
        ..OrderRequest::default()
    };
    match account.place_order(limit_sell).await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    let market_sell = OrderRequest {
        symbol: symbol.to_string(),
        quantity: Some(0.001),
        order_type: OrderType::Market,
        side: OrderSide::Sell,
        ..OrderRequest::default()
    };
    match account.place_order(market_sell).await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    let order_id = 1_957_528;
    let order_status = OrderStatusRequest {
        symbol: symbol.to_string(),
        order_id: Some(order_id),
        ..OrderStatusRequest::default()
    };

    match account.order_status(order_status).await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    let order_cancellation = OrderCancellation {
        symbol: symbol.to_string(),
        order_id: Some(order_id),
        ..OrderCancellation::default()
    };

    match account.cancel_order(order_cancellation).await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    match account.get_balance("BTC").await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    match account.trade_history(symbol).await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }
}

async fn market_data() {
    let market: Market = Binance::new(None, None);

    // Order book
    match market.get_depth("BNBETH").await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    // Latest price for ALL symbols
    match market.get_all_prices().await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    // Latest price for ONE symbol
    match market.get_price("KNCETH").await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    // Current average price for ONE symbol
    match market.get_average_price("KNCETH").await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    // Best price/qty on the order book for ALL symbols
    match market.get_all_book_tickers().await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    // Best price/qty on the order book for ONE symbol
    match market.get_book_ticker("BNBETH").await {
        Ok(answer) => info!("Bid Price: {}, Ask Price: {}", answer.bid_price, answer.ask_price),
        Err(e) => error!("Error: {e}"),
    }

    // 24hr ticker price change statistics
    match market.get_24h_price_stats("BNBETH").await {
        Ok(answer) => info!(
            "Open Price: {}, Higher Price: {}, Lower Price: {:?}",
            answer.open_price, answer.high_price, answer.low_price
        ),
        Err(e) => error!("Error: {e}"),
    }

    // last 10 5min klines (candlesticks) for a symbol:
    match market.get_klines("BNBETH", "5m", 10, None, None).await {
        Ok(answer) => info!("{:?}", answer),
        Err(e) => error!("Error: {e}"),
    }

    // 10 latest (aggregated) trades
    match market.get_agg_trades("BNBETH", None, None, None, Some(10)).await {
        Ok(trades) => {
            let trade = &trades[0]; // You need to iterate over them
            println!(
                "{} BNB Qty: {}, Price: {}",
                if trade.maker { "SELL" } else { "BUY" },
                trade.qty,
                trade.price
            )
        }
        Err(e) => println!("Error: {e}"),
    }
}

</document_content>
</document>
<document index="16">
<source>examples/binance_futures.rs</source>
<document_content>
#[cfg(feature = "futures_api")]
#[macro_use]
extern crate tracing;

use env_logger::Builder;

#[tokio::main]
async fn main() {
    Builder::new().parse_default_env().init();
    #[cfg(feature = "futures_api")]
    general().await;
    #[cfg(feature = "futures_api")]
    market_data().await;
    #[cfg(feature = "futures_api")]
    account().await;
}

#[cfg(feature = "futures_api")]
async fn general() {
    use binance::api::*;
    use binance::errors::Error as BinanceLibError;
    use binance::futures::general::*;

    let general: FuturesGeneral = Binance::new(None, None);

    match general.ping().await {
        Ok(answer) => info!("Ping : {:?}", answer),
        Err(err) => {
            match err {
                BinanceLibError::BinanceError { response } => match response.code {
                    -1000_i32 => error!("An unknown error occured while processing the request"),
                    _ => error!("Uncaught code {}: {}", response.code, response.msg),
                },
                BinanceLibError::Msg(msg) => error!("Binancelib error msg: {}", msg),
                _ => error!("Other errors: {:?}.", err),
            };
        }
    }

    match general.get_server_time().await {
        Ok(answer) => info!("Server Time: {}", answer.server_time),
        Err(e) => error!("Error: {:?}", e),
    }

    match general.exchange_info().await {
        Ok(answer) => info!("Exchange information: {:?}", answer),
        Err(e) => error!("Error: {:?}", e),
    }

    match general.get_symbol_info("btcusdt").await {
        Ok(answer) => info!("Symbol information: {:?}", answer),
        Err(e) => error!("Error: {:?}", e),
    }
}

#[cfg(feature = "futures_api")]
async fn market_data() {
    use binance::api::*;
    use binance::futures::market::*;
    use binance::futures::rest_model::*;

    let market: FuturesMarket = Binance::new(None, None);

    match market.get_depth("btcusdt").await {
        Ok(answer) => info!("Depth update ID: {:?}", answer.last_update_id),
        Err(e) => error!("Error: {:?}", e),
    }

    match market.get_trades("btcusdt").await {
        Ok(Trades::AllTrades(answer)) => info!("First trade: {:?}", answer[0]),
        Err(e) => error!("Error: {:?}", e),
    }

    match market.get_agg_trades("btcusdt", None, None, None, 500u16).await {
        Ok(AggTrades::AllAggTrades(answer)) => info!("First aggregated trade: {:?}", answer[0]),
        Err(e) => error!("Error: {:?}", e),
    }

    match market.get_klines("btcusdt", "5m", 10u16, None, None).await {
        Ok(KlineSummaries::AllKlineSummaries(answer)) => info!("First kline: {:?}", answer[0]),
        Err(e) => error!("Error: {:?}", e),
    }

    match market.get_24h_price_stats("btcusdt").await {
        Ok(answer) => info!("24hr price stats: {:?}", answer),
        Err(e) => error!("Error: {:?}", e),
    }

    match market.get_price("btcusdt").await {
        Ok(answer) => info!("Price: {:?}", answer),
        Err(e) => error!("Error: {:?}", e),
    }

    match market.get_all_book_tickers().await {
        Ok(BookTickers::AllBookTickers(answer)) => info!("First book ticker: {:?}", answer[0]),
        Err(e) => error!("Error: {:?}", e),
    }

    match market.get_book_ticker("btcusdt").await {
        Ok(answer) => info!("Book ticker: {:?}", answer),
        Err(e) => error!("Error: {:?}", e),
    }

    match market.get_mark_prices(Some("btcusdt".into())).await {
        Ok(answer) => info!("First mark Prices: {:?}", answer[0]),
        Err(e) => info!("Error: {:?}", e),
    }

    match market.open_interest("btcusdt").await {
        Ok(answer) => info!("Open interest: {:?}", answer),
        Err(e) => error!("Error: {:?}", e),
    }

    match market.get_funding_rate("BTCUSDT", None, None, 10u16).await {
        Ok(answer) => info!("Funding: {:?}", answer),
        Err(e) => error!("Error: {:?}", e),
    }
}

#[cfg(feature = "futures_api")]
async fn account() {
    use binance::{api::Binance, config::Config, futures::account::FuturesAccount};
    let api_key = Some("".into());
    let secret_key = Some("".into());

    let account = FuturesAccount::new_with_config(api_key, secret_key, &Config::testnet());

    match account.account_information().await {
        Ok(answer) => info!("Account Info: {:?}", answer),
        Err(e) => error!("Error: {:?}", e),
    }
}

</document_content>
</document>
<document index="17">
<source>examples/binance_margin.rs</source>
<document_content>
#[macro_use]
extern crate tracing;

use env_logger::Builder;

#[tokio::main]
async fn main() {
    Builder::new().parse_default_env().init();
    info!("running margin endpoints");
    #[cfg(feature = "margin_api")]
    margin_query().await;
    //#[cfg(feature = "margin_api")]
    //margin_post().await;
}

#[cfg(feature = "margin_api")]
async fn margin_query() {
    use binance::api::*;
    use binance::bool_to_string_some;
    use binance::config::Config;
    use binance::margin::Margin;
    use binance::rest_model::*;
    use chrono::{Duration, Utc};
    use std::ops::Sub;

    eprintln!("----------- Margin GET queries ----------");
    let margin: Margin = Binance::new_with_env(&Config::default());
    let yesterday = Utc::now().sub(Duration::days(1));
    let yesterday_millis = yesterday.timestamp_millis() as u64;
    let interest_rate_history = margin
        .interest_rate_history(InterestRateHistoryQuery {
            asset: "BTC".to_string(),
            vip_level: Some(1),
            ..InterestRateHistoryQuery::default()
        })
        .await
        .unwrap();
    eprintln!("interest_rate_history = {interest_rate_history:?}");
    let interest_rate_history = margin
        .interest_rate_history(InterestRateHistoryQuery {
            asset: "LTC".to_string(),
            ..InterestRateHistoryQuery::default()
        })
        .await
        .unwrap();
    eprintln!("interest_rate_history = {interest_rate_history:?}");
    let records_query = RecordsQuery {
        asset: "BTC".to_string(),
        transfer_type: Some(TransferType::RollIn),
        start_time: Some(yesterday_millis),
        ..RecordsQuery::default()
    };
    let loans = margin.loans(records_query).await;
    eprintln!("loans = {loans:?}");
    let records_query = RecordsQuery {
        asset: "BTC".to_string(),
        transfer_type: Some(TransferType::RollIn),
        start_time: Some(yesterday_millis),
        ..RecordsQuery::default()
    };
    let repays = margin.repays(records_query).await;
    eprintln!("repays = {repays:?}");
    let details = margin.details().await;
    eprintln!("details = {details:?}");
    let isolated_details = margin.isolated_details(None).await;
    eprintln!("isolated_details = {isolated_details:?}");
    let isolated_pair = margin.isolated_pair("BTCUSDT").await;
    eprintln!("isolated_pair = {isolated_pair:?}");
    let isolated_account_limit = margin.isolated_account_limit().await;
    eprintln!("isolated_pair = {isolated_account_limit:?}");
    let all_pairs = margin.all_pairs().await;
    eprintln!("all_pairs = {all_pairs:?}");
    let bnb_burn_status = margin.bnb_burn_status().await;
    eprintln!("bnb_burn_status = {bnb_burn_status:?}");
    let asset = margin.asset("BTC").await;
    eprintln!("asset = {asset:?}");
    let pair = margin.pair("BTCUSDT").await;
    eprintln!("pair = {pair:?}");
    let all_assets = margin.all_assets().await;
    eprintln!("all_assets = {all_assets:?}");
    let all_isolated_pairs = margin.all_isolated_pairs().await;
    eprintln!("all_isolated_pairs = {all_isolated_pairs:?}");
    let price_index = margin.price_index("BTCUSDT").await;
    eprintln!("price_index = {price_index:?}");
    let records_query = RecordsQuery {
        asset: "BTC".to_string(),
        transfer_type: Some(TransferType::RollIn),
        ..RecordsQuery::default()
    };
    let transfers = margin.transfers(records_query).await;
    eprintln!("transfers = {transfers:?}");
    let records_query = IsolatedTransfersQuery {
        symbol: "BTC".to_string(),
        ..IsolatedTransfersQuery::default()
    };
    let isolated_transfers = margin.isolated_transfers(records_query).await;
    eprintln!("isolated_transfers = {isolated_transfers:?}");
    let records_query = RecordsQuery {
        asset: "BTC".to_string(),
        transfer_type: Some(TransferType::RollIn),
        ..RecordsQuery::default()
    };
    let interests = margin.interests(records_query).await;
    eprintln!("interests = {interests:?}");
    let records_query = RecordsQuery {
        asset: "BTC".to_string(),
        transfer_type: Some(TransferType::RollIn),
        ..RecordsQuery::default()
    };
    let forced_liquidations = margin.forced_liquidations(records_query).await;
    eprintln!("forced_liquidations = {forced_liquidations:?}");
    let records_query = MarginOrderQuery {
        symbol: "BTCUSDT".to_string(),
        order_id: Some("1".to_string()),
        orig_client_order_id: Some("my_id".to_string()),
        is_isolated: None,
    };
    let order = margin.order(records_query).await;
    eprintln!("order = {order:?}");
    let open_orders = margin.open_orders("BTCUSDT", None).await;
    eprintln!("open_orders = {open_orders:?}");
    let records_query = MarginOrdersQuery {
        symbol: "BTCUSDT".to_string(),
        ..MarginOrdersQuery::default()
    };
    let orders = margin.orders(records_query).await;
    eprintln!("orders = {orders:?}");
    let records_query = MarginOwnTradesQuery {
        symbol: "BTCUSDT".to_string(),
        ..MarginOwnTradesQuery::default()
    };
    let trades = margin.trades(records_query).await;
    eprintln!("trades = {trades:?}");
    let records_query = MarginOCOOrderQuery {
        symbol: Some("BTCUSDT".to_string()),
        is_isolated: bool_to_string_some(true),
        orig_client_order_id: Some("id".to_string()),
        ..MarginOCOOrderQuery::default()
    };
    let oco_order = margin.oco_order(records_query).await;
    eprintln!("oco_order = {oco_order:?}");
    let records_query = OCORecordsQuery {
        symbol: Some("BTCUSDT".to_string()),
        is_isolated: bool_to_string_some(true),
        ..OCORecordsQuery::default()
    };
    let all_oco_orders = margin.all_oco_orders(records_query).await;
    eprintln!("all_oco_orders = {all_oco_orders:?}");
    let max_borrowable = margin.max_borrowable("BTC", None).await;
    eprintln!("max_borrowable = {max_borrowable:?}");
    let max_transferable = margin.max_transferable("BTC", None).await;
    eprintln!("max_transferable = {max_transferable:?}");
}

#[allow(dead_code)]
#[cfg(feature = "margin_api")]
async fn margin_post() {
    use binance::api::*;
    use binance::config::Config;
    use binance::margin::Margin;
    use binance::rest_model::*;

    eprintln!("----------- Margin POST queries ----------");
    let margin: Margin = Binance::new_with_env(&Config::testnet());

    let transfer = margin
        .transfer("BTC", 0.001, MarginTransferType::FromMainToMargin)
        .await;
    eprintln!("transfer = {transfer:?}");
    let isolated_transfer = margin
        .isolated_transfer(
            "BTC",
            "ETH",
            0.001,
            IsolatedMarginTransferType::Spot,
            IsolatedMarginTransferType::IsolatedMargin,
        )
        .await;
    eprintln!("isolated_transfer = {isolated_transfer:?}");
    let loan = margin.loan("BTC", 0.001).await;
    eprintln!("loan = {loan:?}");
    let loan_with_isolation = margin
        .loan_with_isolation("BTC", 0.001, Some(true), Some("BNB".to_string()))
        .await;
    eprintln!("loan_with_isolation = {loan_with_isolation:?}");
    let repay = margin.repay("BTC", 0.001).await;
    eprintln!("repay = {repay:?}");
    let repay_with_isolation = margin
        .repay_with_isolation("BTCUSDT", 0.001, Some(true), Some("BNB".to_string()))
        .await;
    eprintln!("repay_with_isolation = {repay_with_isolation:?}");
    let margin_order = MarginOrder {
        symbol: "BTCUSDT".to_string(),
        side: OrderSide::Sell,
        order_type: OrderType::Limit,
        quantity: Some(0.001),
        quote_order_qty: None,
        price: Some(10.0),
        stop_price: Some(10.0),
        new_client_order_id: Some("my_id".to_string()),
        iceberg_qty: Some(10.0),
        new_order_resp_type: OrderResponse::Ack,
        time_in_force: Some(TimeInForce::FOK),
        side_effect_type: SideEffectType::NoSideEffect,
        is_isolated: None,
    };
    let new_order = margin.new_order(margin_order).await;
    eprintln!("new_order = {new_order:?}");

    let cancel_trade = margin
        .cancel_trade("BTCUSDT", 1_u64, "my_id".to_string(), "my_next_id".to_string(), None)
        .await;
    eprintln!("cancel_trade = {cancel_trade:?}");
    let cancel_oco_order = margin
        .cancel_oco_order("BTCUSDT", 1_u64, "my_id".to_string(), "my_next_id".to_string(), None)
        .await;
    eprintln!("cancel_oco_order = {cancel_oco_order:?}");
    let cancel_all_orders = margin.cancel_all_orders("BTCUSDT", None).await;
    eprintln!("cancel_all_orders = {cancel_all_orders:?}");
    let disable_isolated = margin.disable_isolated("BTCUSDT".to_string()).await;
    eprintln!("disable_isolated = {disable_isolated:?}");
    let enable_isolated = margin.enable_isolated("BTCUSDT".to_string()).await;
    eprintln!("enable_isolated = {enable_isolated:?}");
    let toggle_bnb_burn = margin.toggle_bnb_burn(BnbBurnQuery::default()).await;
    eprintln!("toggle_bnb_burn = {toggle_bnb_burn:?}");
}

</document_content>
</document>
<document index="18">
<source>examples/binance_save_all_trades.rs</source>
<document_content>
use csv::Writer;
use std::error::Error;
use std::fs::File;
use std::sync::atomic::AtomicBool;

use binance::websockets::*;
use binance::ws_model::WebsocketEvent;

#[tokio::main]
async fn main() { save_all_trades_websocket().await; }

async fn save_all_trades_websocket() {
    struct WebSocketHandler {
        wrt: Writer<File>,
    }

    impl WebSocketHandler {
        pub fn new(local_wrt: Writer<File>) -> Self { WebSocketHandler { wrt: local_wrt } }

        // serialize DayTickerEvent as CSV records
        pub fn write_to_file(&mut self, events: Vec<WebsocketEvent>) -> Result<(), Box<dyn Error>> {
            for event in events {
                self.wrt.serialize(event)?;
            }
            Ok(())
        }
    }

    let keep_running = AtomicBool::new(true); // Used to control the event loop
    let file_path = std::path::Path::new("test.csv");
    let local_wrt = csv::Writer::from_path(file_path).unwrap();

    let mut web_socket_handler = WebSocketHandler::new(local_wrt);
    let agg_trade: String = "!ticker@arr".to_string();
    let mut web_socket: WebSockets<'_, Vec<WebsocketEvent>> = WebSockets::new(|events: Vec<WebsocketEvent>| {
        // You can break the event_loop if some condition is met be setting keep_running to false
        // keep_running.store(false, Ordering::Relaxed);
        if let Err(error) = web_socket_handler.write_to_file(events) {
            println!("{error}");
        }
        Ok(())
    });

    web_socket.connect(&agg_trade).await.unwrap(); // check error
    if let Err(e) = web_socket.event_loop(&keep_running).await {
        println!("Error: {e}");
    }
}

</document_content>
</document>
<document index="19">
<source>examples/binance_websockets.rs</source>
<document_content>
#[macro_use]
extern crate tokio;

use binance::api::*;
use binance::userstream::*;
use binance::websockets::*;
use binance::ws_model::{CombinedStreamEvent, WebsocketEvent, WebsocketEventUntag};
use futures::future::BoxFuture;
use futures::stream::StreamExt;
use serde_json::from_str;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::RwLock;
use tokio::sync::mpsc::UnboundedSender;
use tokio_tungstenite::tungstenite::Message;

#[tokio::main]
async fn main() {
    let (logger_tx, mut logger_rx) = tokio::sync::mpsc::unbounded_channel::<WebsocketEvent>();
    let (close_tx, mut close_rx) = tokio::sync::mpsc::unbounded_channel::<bool>();
    let wait_loop = tokio::spawn(async move {
        'hello: loop {
            select! {
                event = logger_rx.recv() => println!("{event:?}"),
                _ = close_rx.recv() => break 'hello
            }
        }
    });
    // private api
    //user_stream().await;
    //user_stream_websocket().await;
    // public api
    let streams: Vec<BoxFuture<'static, ()>> = vec![
        Box::pin(market_websocket(logger_tx.clone())),
        Box::pin(kline_websocket(logger_tx.clone())),
        Box::pin(all_trades_websocket(logger_tx.clone())),
        Box::pin(last_price(logger_tx.clone())),
        Box::pin(book_ticker(logger_tx.clone())),
        Box::pin(combined_orderbook(logger_tx.clone())),
        Box::pin(custom_event_loop(logger_tx.clone())),
        Box::pin(mark_price_websocket(logger_tx)),
    ];

    for stream in streams {
        tokio::spawn(stream);
    }

    select! {
        _ = wait_loop => { println!("Finished!") }
        _ = tokio::signal::ctrl_c() => {
            println!("Closing websocket stream...");
            close_tx.send(true).unwrap();
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        }
    }
}

#[allow(dead_code)]
async fn user_stream() {
    let api_key_user = Some("YOUR_API_KEY".into());
    let user_stream: UserStream = Binance::new(api_key_user.clone(), None);

    if let Ok(answer) = user_stream.start().await {
        println!("Data Stream Started ...");
        let listen_key = answer.listen_key;

        match user_stream.keep_alive(&listen_key).await {
            Ok(msg) => println!("Keepalive user data stream: {msg:?}"),
            Err(e) => println!("Error: {e}"),
        }

        match user_stream.close(&listen_key).await {
            Ok(msg) => println!("Close user data stream: {msg:?}"),
            Err(e) => println!("Error: {e}"),
        }
    } else {
        println!("Not able to start an User Stream (Check your API_KEY)");
    }
}

#[allow(dead_code)]
async fn user_stream_websocket() {
    let keep_running = AtomicBool::new(true); // Used to control the event loop
    let api_key_user = Some("YOUR_KEY".into());
    let user_stream: UserStream = Binance::new(api_key_user, None);

    if let Ok(answer) = user_stream.start().await {
        let listen_key = answer.listen_key;

        let mut web_socket: WebSockets<'_, WebsocketEvent> = WebSockets::new(|event: WebsocketEvent| {
            if let WebsocketEvent::OrderUpdate(trade) = event {
                println!(
                    "Symbol: {}, Side: {:?}, Price: {}, Execution Type: {:?}",
                    trade.symbol, trade.side, trade.price, trade.execution_type
                );
            };

            Ok(())
        });

        web_socket.connect(&listen_key).await.unwrap(); // check error
        if let Err(e) = web_socket.event_loop(&keep_running).await {
            println!("Error: {e}");
        }
        user_stream.close(&listen_key).await.unwrap();
        web_socket.disconnect().await.unwrap();
        println!("Userstrem closed and disconnected");
    } else {
        println!("Not able to start an User Stream (Check your API_KEY)");
    }
}

#[allow(dead_code)]
async fn market_websocket(logger_tx: UnboundedSender<WebsocketEvent>) {
    let keep_running = AtomicBool::new(true); // Used to control the event loop
    let agg_trade: String = agg_trade_stream("ethbtc");
    let mut web_socket: WebSockets<'_, WebsocketEvent> = WebSockets::new(|event: WebsocketEvent| {
        logger_tx.send(event.clone()).unwrap();
        match event {
            WebsocketEvent::Trade(trade) => {
                println!("Symbol: {}, price: {}, qty: {}", trade.symbol, trade.price, trade.qty);
            }
            WebsocketEvent::DepthOrderBook(depth_order_book) => {
                println!(
                    "Symbol: {}, Bids: {:?}, Ask: {:?}",
                    depth_order_book.symbol, depth_order_book.bids, depth_order_book.asks
                );
            }
            _ => (),
        };

        Ok(())
    });

    web_socket.connect(&agg_trade).await.unwrap(); // check error
    if let Err(e) = web_socket.event_loop(&keep_running).await {
        println!("Error: {e}");
    }
    web_socket.disconnect().await.unwrap();
    println!("disconnected");
}

#[allow(dead_code)]
async fn all_trades_websocket(logger_tx: UnboundedSender<WebsocketEvent>) {
    let keep_running = AtomicBool::new(true); // Used to control the event loop
    let agg_trade = all_ticker_stream();
    // NB: you may not ask for both arrays type streams and object type streams at the same time, this holds true in binance connections anyways
    // You cannot connect to multiple things for a single socket
    let mut web_socket: WebSockets<'_, Vec<WebsocketEvent>> = WebSockets::new(|events: Vec<WebsocketEvent>| {
        for tick_events in events {
            logger_tx.send(tick_events.clone()).unwrap();
            if let WebsocketEvent::DayTicker(tick_event) = tick_events {
                println!(
                    "Symbol: {}, price: {}, qty: {}",
                    tick_event.symbol, tick_event.best_bid, tick_event.best_bid_qty
                );
            }
        }

        Ok(())
    });

    web_socket.connect(agg_trade).await.unwrap(); // check error
    if let Err(e) = web_socket.event_loop(&keep_running).await {
        println!("Error: {e}");
    }
    web_socket.disconnect().await.unwrap();
    println!("disconnected");
}

#[allow(dead_code)]
async fn kline_websocket(logger_tx: UnboundedSender<WebsocketEvent>) {
    let keep_running = AtomicBool::new(true);
    let kline = kline_stream("ethbtc", "1m");
    let mut web_socket: WebSockets<'_, WebsocketEvent> = WebSockets::new(|event: WebsocketEvent| {
        logger_tx.send(event.clone()).unwrap();
        if let WebsocketEvent::Kline(kline_event) = event {
            println!(
                "Symbol: {}, high: {}, low: {}",
                kline_event.kline.symbol, kline_event.kline.low, kline_event.kline.high
            );
        }

        Ok(())
    });

    web_socket.connect(&kline).await.unwrap(); // check error
    if let Err(e) = web_socket.event_loop(&keep_running).await {
        println!("Error: {e}");
    }
    web_socket.disconnect().await.unwrap();
    println!("disconnected");
}

#[allow(dead_code)]
async fn mark_price_websocket(logger_tx: UnboundedSender<WebsocketEvent>) {
    let keep_running = AtomicBool::new(true);
    let mark_price = mark_price_stream("btcusdt", 1);
    let mut web_socket: WebSockets<'_, WebsocketEvent> = WebSockets::new(|event: WebsocketEvent| {
        logger_tx.send(event.clone()).unwrap();
        if let WebsocketEvent::MarkPriceUpdate(mark_price_event) = event {
            println!(
                "Symbol: {}, mark price: {}",
                mark_price_event.symbol, mark_price_event.mark_price
            );
        }

        Ok(())
    });

    if let Err(e) = web_socket.connect_futures(&mark_price).await {
        println!("Connection error: {e}");
    }

    if let Err(e) = web_socket.event_loop(&keep_running).await {
        println!("Error: {e}");
    }
    web_socket.disconnect().await.unwrap();
    println!("disconnected");
}

#[allow(dead_code)]
async fn last_price(logger_tx: UnboundedSender<WebsocketEvent>) {
    let keep_running = AtomicBool::new(true);
    let all_ticker = all_ticker_stream();
    let btcusdt: RwLock<f32> = RwLock::new("0".parse().unwrap());

    let mut web_socket: WebSockets<'_, Vec<WebsocketEvent>> = WebSockets::new(|events: Vec<WebsocketEvent>| {
        for tick_events in events {
            logger_tx.send(tick_events.clone()).unwrap();
            if let WebsocketEvent::DayTicker(tick_event) = tick_events {
                if tick_event.symbol == "BTCUSDT" {
                    let mut btcusdt = btcusdt.write().unwrap();
                    *btcusdt = tick_event.average_price.parse::<f32>().unwrap();
                    let btcusdt_close: f32 = tick_event.current_close.parse().unwrap();
                    println!("{btcusdt} - {btcusdt_close}");

                    if btcusdt_close as i32 == 7000 {
                        // Break the event loop
                        keep_running.store(false, Ordering::Relaxed);
                    }
                }
            }
        }

        Ok(())
    });

    web_socket.connect(all_ticker).await.unwrap(); // check error
    if let Err(e) = web_socket.event_loop(&keep_running).await {
        println!("Error: {e}");
    }
    web_socket.disconnect().await.unwrap();
    println!("disconnected");
}

#[allow(dead_code)]
async fn book_ticker(logger_tx: UnboundedSender<WebsocketEvent>) {
    let keep_running = AtomicBool::new(true);
    let book_ticker: String = book_ticker_stream("btcusdt");

    let mut web_socket: WebSockets<'_, WebsocketEventUntag> = WebSockets::new(|events: WebsocketEventUntag| {
        if let WebsocketEventUntag::WebsocketEvent(we) = &events {
            logger_tx.send(we.clone()).unwrap();
        }
        if let WebsocketEventUntag::BookTicker(tick_event) = events {
            println!("{tick_event:?}")
        }
        Ok(())
    });

    web_socket.connect(&book_ticker).await.unwrap(); // check error
    if let Err(e) = web_socket.event_loop(&keep_running).await {
        println!("Error: {e}");
    }
    web_socket.disconnect().await.unwrap();
    println!("disconnected");
}

#[allow(dead_code)]
async fn combined_orderbook(logger_tx: UnboundedSender<WebsocketEvent>) {
    let keep_running = AtomicBool::new(true);
    let streams: Vec<String> = vec!["btcusdt", "ethusdt"]
        .into_iter()
        .map(|symbol| partial_book_depth_stream(symbol, 5, 1000))
        .collect();
    let mut web_socket: WebSockets<'_, CombinedStreamEvent<_>> =
        WebSockets::new(|event: CombinedStreamEvent<WebsocketEventUntag>| {
            if let WebsocketEventUntag::WebsocketEvent(we) = &event.data {
                logger_tx.send(we.clone()).unwrap();
            }
            let data = event.data;
            if let WebsocketEventUntag::Orderbook(orderbook) = data {
                println!("{orderbook:?}")
            }
            Ok(())
        });

    web_socket.connect_multiple(streams).await.unwrap(); // check error
    if let Err(e) = web_socket.event_loop(&keep_running).await {
        println!("Error: {e}");
    }
    web_socket.disconnect().await.unwrap();
    println!("disconnected");
}

#[allow(dead_code)]
async fn custom_event_loop(logger_tx: UnboundedSender<WebsocketEvent>) {
    let streams: Vec<String> = vec!["btcusdt", "ethusdt"]
        .into_iter()
        .map(|symbol| partial_book_depth_stream(symbol, 5, 1000))
        .collect();
    let mut web_socket: WebSockets<'_, CombinedStreamEvent<_>> =
        WebSockets::new(|event: CombinedStreamEvent<WebsocketEventUntag>| {
            if let WebsocketEventUntag::WebsocketEvent(we) = &event.data {
                logger_tx.send(we.clone()).unwrap();
            }
            let data = event.data;
            if let WebsocketEventUntag::Orderbook(orderbook) = data {
                println!("{orderbook:?}")
            }
            Ok(())
        });
    web_socket.connect_multiple(streams).await.unwrap(); // check error
    loop {
        if let Some((ref mut socket, _)) = web_socket.socket {
            if let Ok(message) = socket.next().await.unwrap() {
                match message {
                    Message::Text(msg) => {
                        if msg.is_empty() {
                            continue;
                        }
                        let event: CombinedStreamEvent<WebsocketEventUntag> = from_str(msg.as_str()).unwrap();
                        eprintln!("event = {event:?}");
                    }
                    Message::Ping(_) | Message::Pong(_) | Message::Binary(_) | Message::Frame(_) => {}
                    Message::Close(e) => {
                        eprintln!("closed stream = {e:?}");
                        break;
                    }
                }
            }
        }
    }
}

</document_content>
</document>
<document index="20">
<source>renovate.json</source>
<document_content>
{
  "extends": [
    "config:base"
  ],
  "enabled": true,
  "enabledManagers": [
    "cargo",
    "docker-compose",
    "dockerfile",
    "github-actions"
  ],
  "labels": [
    "dependencies"
  ],
  "packageRules": [
    {
      "matchDepTypes": [
        "optionalDependencies"
      ],
      "addLabels": [
        "optional"
      ]
    }
  ]
}

</document_content>
</document>
<document index="21">
<source>rustfmt.toml</source>
<document_content>
# Enable unstable features on stable and beta channels (unstable features are available by default on nightly).
# https://github.com/rust-lang/rustfmt/blob/master/Configurations.md#unstable_features
unstable_features = true

# Put single-expression functions on a single line
# Note: Unstable
# https://github.com/rust-lang/rustfmt/blob/master/Configurations.md#fn_single_line
fn_single_line = true

# Force multiline closure and match arm bodies to be wrapped in a block
# https://github.com/rust-lang/rustfmt/blob/master/Configurations.md#force_multiline_blocks
force_multiline_blocks = false

# Indent style of imports
# Note: Unstable
# https://github.com/rust-lang/rustfmt/blob/master/Configurations.md#imports_indent
imports_indent = "Visual"

# Maximum width of each line.
# Default: 100
# https://github.com/rust-lang/rustfmt/blob/master/Configurations.md#max_width
max_width = 120

comment_width = 100

# When structs, slices, arrays, and block/array-like macros are used as the last argument in an expression list,
# allow them to overflow (like blocks/closures) instead of being indented on a new line.
# Note: Unstable
# https://github.com/rust-lang/rustfmt/blob/master/Configurations.md#overflow_delimited_expr
overflow_delimited_expr = true

# Use field initialize shorthand if possible.
# https://github.com/rust-lang/rustfmt/blob/master/Configurations.md#use_field_init_shorthand
use_field_init_shorthand = true

</document_content>
</document>
<document index="22">
<source>src/account.rs</source>
<document_content>
use crate::client::*;
use crate::errors::*;
use crate::rest_model::*;
use crate::util::*;

static API_V3_ACCOUNT: &str = "/api/v3/account";
static API_V3_OPEN_ORDERS: &str = "/api/v3/openOrders";
static API_V3_ALL_ORDERS: &str = "/api/v3/allOrders";
static API_V3_MYTRADES: &str = "/api/v3/myTrades";
static API_V3_ORDER: &str = "/api/v3/order";
static API_V3_CANCEL_REPLACE: &str = "/api/v3/order/cancelReplace";
/// Endpoint for test orders.
/// Orders issued to this endpoint are validated, but not sent into the matching engine.
static API_V3_ORDER_TEST: &str = "/api/v3/order/test";

/// Account API access, full example provided in examples/binance_endpoints.rs
#[derive(Clone)]
pub struct Account {
    pub client: Client,
    pub recv_window: u64,
}

/// Order Request
/// perform an order for the account
#[derive(Default, Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrderRequest {
    pub symbol: String,
    pub side: OrderSide,
    #[serde(rename = "type")]
    pub order_type: OrderType,
    pub time_in_force: Option<TimeInForce>,
    pub quantity: Option<f64>,
    pub quote_order_qty: Option<f64>,
    pub price: Option<f64>,
    /// A unique id for the order, automatically generated if not sent.
    pub new_client_order_id: Option<String>,
    /// Used with stop loss, stop loss limit, take profit and take profit limit order types.
    pub stop_price: Option<f64>,
    /// Used with limit, stop loss limit and take profit limit to create an iceberg order.
    pub iceberg_qty: Option<f64>,
    /// Set the response json, market and limit default to full others to ack.
    pub new_order_resp_type: Option<OrderResponse>,
    /// Cannot be greater than 60000
    pub recv_window: Option<u64>,
}

impl OrderRequest {
    fn valid(&self) -> Result<()> {
        if self.iceberg_qty.is_some() && self.time_in_force != Some(TimeInForce::GTC) {
            return Err(Error::InvalidOrderError {
                msg: "Time in force has to be GTC for iceberg orders".to_string(),
            });
        }
        Ok(())
    }
}

/// Order Cancellation Request
/// perform an order cancellation for the account
/// only works if the parameters match an active order
/// either order_id (binance side id) or orig_client_order_id (id originally given by the client) must be set
#[derive(Default, Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrderCancellation {
    pub symbol: String,
    pub order_id: Option<u64>,
    pub orig_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default.
    pub new_client_order_id: Option<String>,
    /// Cannot be greater than 60000
    pub recv_window: Option<u64>,
}

/// Order Cancellation and Replace Request
/// Cancels an existing order and places a new order on the same symbol.
#[derive(Default, Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct CancelReplaceRequest {
    pub symbol: String,
    pub side: OrderSide,
    #[serde(rename = "type")]
    pub order_type: OrderType,
    pub cancel_replace_mode: CancelReplaceMode,
    pub time_in_force: Option<TimeInForce>,
    pub quantity: Option<f64>,
    pub quote_order_qty: Option<f64>,
    pub price: Option<f64>,
    pub cancel_new_client_order_id: Option<String>,
    pub cancel_orig_client_order_id: Option<String>,
    pub cancel_order_id: Option<u64>,
    pub new_client_order_id: Option<String>,
    pub stop_price: Option<f64>,
    pub iceberg_qty: Option<f64>,
    pub new_order_resp_type: Option<OrderResponse>,
    /// Cannot be greater than 60000
    pub recv_window: Option<u64>,
}

impl CancelReplaceRequest {
    pub fn valid(&self) -> Result<()> {
        if self.iceberg_qty.is_some() && self.time_in_force != Some(TimeInForce::GTC) {
            return Err(Error::InvalidOrderError {
                msg: "Time in force has to be GTC for iceberg orders".to_string(),
            });
        }
        Ok(())
    }
}

/// Order Status Request
/// perform an order status request for the account
#[derive(Default, Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrderStatusRequest {
    pub symbol: String,
    pub order_id: Option<u64>,
    pub orig_client_order_id: Option<String>,
    /// Cannot be greater than 60000
    pub recv_window: Option<u64>,
}

/// Order Status Request
/// perform a query on all orders for the account
#[derive(Default, Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrdersQuery {
    pub symbol: String,
    pub order_id: Option<u64>,
    pub start_time: Option<u64>,
    pub end_time: Option<u64>,
    /// Default 500 max 1000
    pub limit: Option<u32>,
    /// Cannot be greater than 60000
    pub recv_window: Option<u64>,
}

impl Account {
    /// General account information
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let account = tokio_test::block_on(account.get_account());
    /// assert!(account.is_ok(), "{:?}", account);
    /// ```
    pub async fn get_account(&self) -> Result<AccountInformation> {
        // TODO: should parameters be Option<>?
        let request = build_signed_request([("", "")], self.recv_window)?;
        self.client.get_signed(API_V3_ACCOUNT, &request).await
    }

    /// Account balance for a single asset
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let balance = tokio_test::block_on(account.get_balance("BTC"));
    /// assert!(balance.is_ok(), "{:?}", balance);
    /// ```
    pub async fn get_balance<S>(&self, asset: S) -> Result<Balance>
    where
        S: Into<String>,
    {
        match self.get_account().await {
            Ok(account) => {
                let cmp_asset = asset.into();
                for balance in account.balances {
                    if balance.asset == cmp_asset {
                        return Ok(balance);
                    }
                }
                Err(Error::Msg("Asset not found".to_string()))
            }
            Err(e) => Err(e),
        }
    }

    /// All currently open orders for a single symbol
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let orders = tokio_test::block_on(account.get_open_orders("BTCUSDT"));
    /// assert!(orders.is_ok(), "{:?}", orders);
    /// ```
    pub async fn get_open_orders<S>(&self, symbol: S) -> Result<Vec<Order>>
    where
        S: AsRef<str>,
    {
        let parameters = [("symbol", symbol.as_ref())];
        let request = build_signed_request(parameters, self.recv_window)?;
        self.client.get_signed(API_V3_OPEN_ORDERS, &request).await
    }

    /// All orders for the account
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let query = OrdersQuery {
    ///     symbol: "BTCUSDT".to_string(),
    ///     order_id: None,
    ///     start_time: None,
    ///     end_time: None,
    ///     limit: None,
    ///     recv_window: None,
    /// };
    /// let orders = tokio_test::block_on(account.get_all_orders(query));
    /// assert!(orders.is_ok(), "{:?}", orders);
    /// ```
    pub async fn get_all_orders(&self, query: OrdersQuery) -> Result<Vec<Order>> {
        let recv_window = query.recv_window.unwrap_or(self.recv_window);
        let request = build_signed_request_p(query, recv_window)?;
        self.client.get_signed(API_V3_ALL_ORDERS, &request).await
    }

    /// All currently open orders for the account
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let orders = tokio_test::block_on(account.get_all_open_orders());
    /// assert!(orders.is_ok(), "{:?}", orders);
    /// ```
    pub async fn get_all_open_orders(&self) -> Result<Vec<Order>> {
        let request = build_signed_request([("", "")], self.recv_window)?;
        self.client.get_signed(API_V3_OPEN_ORDERS, &request).await
    }

    /// Cancels all currently open orders of specified symbol for the account
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let canceled_orders = tokio_test::block_on(account.cancel_all_open_orders("ETHBTC"));
    /// assert!(canceled_orders.is_ok(), "{:?}", canceled_orders);
    /// ```
    pub async fn cancel_all_open_orders<S>(&self, symbol: S) -> Result<Vec<Order>>
    where
        S: AsRef<str>,
    {
        let params = [("symbol", symbol.as_ref())];
        let request = build_signed_request(params, self.recv_window)?;
        self.client.delete_signed(API_V3_OPEN_ORDERS, &request).await
    }

    /// Check an order's status
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let query = OrderStatusRequest {
    ///     symbol: "BTCUSDT".to_string(),
    ///     order_id: Some(1),
    ///     orig_client_order_id: Some("my_id".to_string()),
    ///     recv_window: None
    /// };
    /// let order = tokio_test::block_on(account.order_status(query));
    /// assert!(order.is_ok(), "{:?}", order);
    /// ```
    pub async fn order_status(&self, osr: OrderStatusRequest) -> Result<Order> {
        let recv_window = osr.recv_window.unwrap_or(self.recv_window);
        let request = build_signed_request_p(osr, recv_window)?;
        self.client.get_signed(API_V3_ORDER, &request).await
    }

    /// Place a test status order
    ///
    /// This order is sandboxed: it is validated, but not sent to the matching engine.
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let query = OrderStatusRequest {
    ///     symbol: "BTCUSDT".to_string(),
    ///     order_id: Some(1),
    ///     orig_client_order_id: Some("my_id".to_string()),
    ///     recv_window: None
    /// };
    /// let resp = tokio_test::block_on(account.test_order_status(query));
    /// assert!(resp.is_ok(), "{:?}", resp);
    /// ```
    pub async fn test_order_status(&self, osr: OrderStatusRequest) -> Result<TestResponse> {
        let recv_window = osr.recv_window.unwrap_or(self.recv_window);
        let request = build_signed_request_p(osr, recv_window)?;
        self.client.get_signed(API_V3_ORDER_TEST, &request).await
    }

    /// Place an order
    /// Returns the Transaction if Ok
    /// This methods validates the order request before sending, making sure it complies with Binance rules
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*, rest_model::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let limit_buy = OrderRequest {
    ///         symbol: "BTCUSDT".to_string(),
    ///         quantity: Some(10.0),
    ///         price: Some(0.014000),
    ///         order_type: OrderType::Limit,
    ///         side: OrderSide::Buy,
    ///         time_in_force: Some(TimeInForce::FOK),
    ///         ..OrderRequest::default()
    ///     };
    /// let transaction = tokio_test::block_on(account.place_order(limit_buy));
    /// assert!(transaction.is_ok(), "{:?}", transaction);
    /// ```
    pub async fn place_order(&self, order: OrderRequest) -> Result<Transaction> {
        order.valid()?;
        let recv_window = order.recv_window.unwrap_or(self.recv_window);
        let request = build_signed_request_p(order, recv_window)?;
        self.client.post_signed(API_V3_ORDER, &request).await
    }

    /// Place a test order
    ///
    /// Despite being a test, this order is still validated before calls
    /// This order is sandboxed: it is validated, but not sent to the matching engine.
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*, rest_model::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let limit_buy = OrderRequest {
    ///         symbol: "BTCUSDT".to_string(),
    ///         quantity: Some(10.0),
    ///         price: Some(0.014000),
    ///         order_type: OrderType::Limit,
    ///         side: OrderSide::Buy,
    ///         time_in_force: Some(TimeInForce::FOK),
    ///         ..OrderRequest::default()
    ///     };
    /// let resp = tokio_test::block_on(account.place_test_order(limit_buy));
    /// assert!(resp.is_ok(), "{:?}", resp);
    /// ```
    pub async fn place_test_order(&self, order: OrderRequest) -> Result<TestResponse> {
        order.valid()?;
        let recv_window = order.recv_window.unwrap_or(self.recv_window);
        let request = build_signed_request_p(order, recv_window)?;
        self.client.post_signed(API_V3_ORDER_TEST, &request).await
    }

    /// Place a cancellation order
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let query = OrderCancellation {
    ///     symbol: "BTCUSDT".to_string(),
    ///     order_id: Some(1),
    ///     orig_client_order_id: Some("my_id".to_string()),
    ///     new_client_order_id: None,
    ///     recv_window: None
    /// };
    /// let canceled = tokio_test::block_on(account.cancel_order(query));
    /// assert!(canceled.is_ok(), "{:?}", canceled);
    /// ```
    pub async fn cancel_order(&self, o: OrderCancellation) -> Result<OrderCanceled> {
        let recv_window = o.recv_window.unwrap_or(self.recv_window);
        let request = build_signed_request_p(o, recv_window)?;
        self.client.delete_signed(API_V3_ORDER, &request).await
    }

    pub async fn cancel_replace_order(&self, order: CancelReplaceRequest) -> Result<OrderCanceledReplaced> {
        order.valid()?;
        let recv_window = order.recv_window.unwrap_or(self.recv_window);
        let request = build_signed_request_p(order, recv_window)?;
        self.client.post_signed(API_V3_CANCEL_REPLACE, &request).await
    }

    /// Place a test cancel order
    ///
    /// This order is sandboxed: it is validated, but not sent to the matching engine.
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let query = OrderCancellation {
    ///     symbol: "BTCUSDT".to_string(),
    ///     order_id: Some(1),
    ///     orig_client_order_id: Some("my_id".to_string()),
    ///     new_client_order_id: None,
    ///     recv_window: None
    /// };
    /// let response = tokio_test::block_on(account.test_cancel_order(query));
    /// assert!(response.is_ok(), "{:?}", response);
    /// ```
    pub async fn test_cancel_order(&self, o: OrderCancellation) -> Result<TestResponse> {
        let recv_window = o.recv_window.unwrap_or(self.recv_window);
        let request = build_signed_request_p(o, recv_window)?;
        self.client.delete_signed(API_V3_ORDER_TEST, &request).await
    }

    /// Trade history
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, account::*, config::*};
    /// let account: Account = Binance::new_with_env(&Config::testnet());
    /// let trade_history = tokio_test::block_on(account.trade_history("BTCUSDT"));
    /// assert!(trade_history.is_ok(), "{:?}", trade_history);
    /// ```
    pub async fn trade_history<S>(&self, symbol: S) -> Result<Vec<TradeHistory>>
    where
        S: AsRef<str>,
    {
        let parameters = [("symbol", symbol.as_ref())];
        let request = build_signed_request(parameters, self.recv_window)?;
        self.client.get_signed(API_V3_MYTRADES, &request).await
    }
}

</document_content>
</document>
<document index="23">
<source>src/api.rs</source>
<document_content>
use crate::account::*;
use crate::client::*;
use crate::config::Config;
use crate::general::*;
use crate::market::*;
use crate::userstream::*;

pub trait Binance: Sized {
    fn new(api_key: Option<String>, secret_key: Option<String>) -> Self {
        Self::new_with_config(api_key, secret_key, &Config::default())
    }

    /// Create a binance API using environment variables for credentials
    /// BINANCE_API_KEY=$YOUR_API_KEY
    /// BINANCE_API_SECRET_KEY=$YOUR_SECRET_KEY
    fn new_with_env(config: &Config) -> Self {
        let api_key = std::env::var("BINANCE_API_KEY").ok();
        let secret = std::env::var("BINANCE_API_SECRET_KEY").ok();
        Self::new_with_config(api_key, secret, config)
    }

    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> Self;
}

impl Binance for General {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> General {
        General {
            client: Client::new(api_key, secret_key, config.rest_api_endpoint.clone(), config.timeout),
        }
    }
}

impl Binance for Account {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> Account {
        Account {
            client: Client::new(api_key, secret_key, config.rest_api_endpoint.clone(), config.timeout),
            recv_window: config.recv_window,
        }
    }
}

#[cfg(feature = "savings_api")]
impl Binance for crate::savings::Savings {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> Self {
        Self {
            client: Client::new(api_key, secret_key, config.rest_api_endpoint.clone(), config.timeout),
            recv_window: config.recv_window,
        }
    }
}

impl Binance for Market {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> Market {
        Market {
            client: Client::new(api_key, secret_key, config.rest_api_endpoint.clone(), config.timeout),
            recv_window: config.recv_window,
        }
    }
}

impl Binance for UserStream {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> UserStream {
        UserStream {
            client: Client::new(api_key, secret_key, config.rest_api_endpoint.clone(), config.timeout),
            recv_window: config.recv_window,
        }
    }
}

#[cfg(feature = "futures_api")]
impl Binance for crate::futures::general::FuturesGeneral {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> Self {
        Self {
            client: Client::new(
                api_key,
                secret_key,
                config.futures_rest_api_endpoint.clone(),
                config.timeout,
            ),
        }
    }
}

#[cfg(feature = "futures_api")]
impl Binance for crate::futures::market::FuturesMarket {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> Self {
        Self {
            client: Client::new(
                api_key,
                secret_key,
                config.futures_rest_api_endpoint.clone(),
                config.timeout,
            ),
            recv_window: config.recv_window,
        }
    }
}

#[cfg(feature = "futures_api")]
impl Binance for crate::futures::account::FuturesAccount {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> Self {
        Self {
            client: Client::new(
                api_key,
                secret_key,
                config.futures_rest_api_endpoint.clone(),
                config.timeout,
            ),
            recv_window: config.recv_window,
        }
    }
}

#[cfg(feature = "futures_api")]
impl Binance for crate::futures::userstream::UserStream {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> Self {
        Self {
            client: Client::new(
                api_key,
                secret_key,
                config.futures_rest_api_endpoint.clone(),
                config.timeout,
            ),
            recv_window: config.recv_window,
        }
    }
}

#[cfg(feature = "margin_api")]
impl Binance for crate::margin::Margin {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> Self {
        Self {
            client: Client::new(api_key, secret_key, config.rest_api_endpoint.clone(), config.timeout),
            recv_window: config.recv_window,
        }
    }
}

#[cfg(feature = "wallet_api")]
impl Binance for crate::wallet::Wallet {
    fn new_with_config(api_key: Option<String>, secret_key: Option<String>, config: &Config) -> Self {
        Self {
            client: Client::new(api_key, secret_key, config.rest_api_endpoint.clone(), config.timeout),
            recv_window: config.recv_window,
            binance_us_api: config.binance_us_api,
        }
    }
}

</document_content>
</document>
<document index="24">
<source>src/client.rs</source>
<document_content>
use std::time::Duration;

use hex::encode as hex_encode;
use reqwest::header::{HeaderMap, HeaderName, HeaderValue, CONTENT_TYPE, USER_AGENT};
use reqwest::Response;
use reqwest::StatusCode;
use ring::hmac;
use serde::de;
use serde::de::DeserializeOwned;

use crate::errors::error_messages;
use crate::errors::*;
use crate::util::{build_request_p, build_signed_request_p};

#[derive(Clone)]
pub struct Client {
    api_key: String,
    secret_key: String,
    inner: reqwest::Client,
    host: String,
}

impl Client {
    /// Returns a client based on the specified host and credentials
    /// Credentials do not need to be specified when using public endpoints
    /// Host is mandatory
    pub fn new(api_key: Option<String>, secret_key: Option<String>, host: String, timeout: Option<u64>) -> Self {
        let mut builder: reqwest::ClientBuilder = reqwest::ClientBuilder::new();
        if let Some(timeout_secs) = timeout {
            builder = builder.timeout(Duration::from_secs(timeout_secs))
        }
        Client {
            // Does it ever make sense for api_key and secret_key to be ""?
            api_key: api_key.unwrap_or_else(|| "".into()),
            secret_key: secret_key.unwrap_or_else(|| "".into()),
            inner: builder.build().unwrap(),
            host,
        }
    }

    pub async fn get_signed<T: DeserializeOwned>(&self, endpoint: &str, request: &str) -> Result<T> {
        let url = self.sign_request(endpoint, request);
        let response = self.inner.get(&url).headers(self.build_headers(true)?).send().await?;

        self.handler(response).await
    }

    pub async fn get_signed_d<T: de::DeserializeOwned>(&self, endpoint: &str, request: &str) -> Result<T> {
        self.get_signed(endpoint, request).await
    }

    pub async fn get_signed_p<T: de::DeserializeOwned, P: serde::Serialize>(
        &self,
        endpoint: &str,
        payload: Option<P>,
        recv_window: u64,
    ) -> Result<T> {
        let req = build_signed_request_p(payload, recv_window)?;
        self.get_signed(endpoint, &req).await
    }

    pub async fn post_signed<T: DeserializeOwned>(&self, endpoint: &str, request: &str) -> Result<T> {
        let url = self.sign_request(endpoint, request);
        let response = self.inner.post(&url).headers(self.build_headers(true)?).send().await?;

        self.handler(response).await
    }

    pub async fn post_signed_d<T: de::DeserializeOwned>(&self, endpoint: &str, request: &str) -> Result<T> {
        self.post_signed(endpoint, request).await
    }

    pub async fn post_signed_p<T: de::DeserializeOwned, P: serde::Serialize>(
        &self,
        endpoint: &str,
        payload: P,
        recv_window: u64,
    ) -> Result<T> {
        let request = build_signed_request_p(payload, recv_window)?;
        self.post_signed(endpoint, &request).await
    }

    pub async fn delete_signed_p<T: de::DeserializeOwned, P: serde::Serialize>(
        &self,
        endpoint: &str,
        payload: P,
        recv_window: u64,
    ) -> Result<T> {
        let request = build_signed_request_p(payload, recv_window)?;
        self.delete_signed(endpoint, &request).await
    }

    pub async fn delete_signed<T: DeserializeOwned>(&self, endpoint: &str, request: &str) -> Result<T> {
        let url = self.sign_request(endpoint, request);
        let response = self
            .inner
            .delete(&url)
            .headers(self.build_headers(true)?)
            .send()
            .await?;

        self.handler(response).await
    }

    pub async fn get<T: DeserializeOwned>(&self, endpoint: &str, request: Option<&str>) -> Result<T> {
        let url = request
            .map(|r| format!("{}{}?{}", self.host, endpoint, r))
            .unwrap_or_else(|| format!("{}{}", self.host, endpoint));

        let response = self.inner.get(&url).send().await?;

        self.handler(response).await
    }

    pub async fn get_p<T: DeserializeOwned>(&self, endpoint: &str, request: Option<&str>) -> Result<T> {
        self.get(endpoint, request).await
    }

    pub async fn get_d<T: DeserializeOwned, S: serde::Serialize>(
        &self,
        endpoint: &str,
        payload: Option<S>,
    ) -> Result<T> {
        let req = if let Some(p) = payload {
            Some(build_request_p(p)?)
        } else {
            None
        };
        self.get_p(endpoint, req.as_deref()).await
    }

    pub async fn post<T: DeserializeOwned>(&self, endpoint: &str, symbol: Option<&str>) -> Result<T> {
        let url = symbol
            .map(|s| format!("{}{}?symbol={}", self.host, endpoint, s))
            .unwrap_or_else(|| format!("{}{}", self.host, endpoint));

        let response = self.inner.post(url).headers(self.build_headers(false)?).send().await?;

        self.handler(response).await
    }

    pub async fn put<T: DeserializeOwned>(&self, endpoint: &str, listen_key: &str, symbol: Option<&str>) -> Result<T> {
        let data = symbol
            .map(|s| format!("listenKey={listen_key}&symbol={s}"))
            .unwrap_or_else(|| format!("listenKey={listen_key}"));
        let headers = self.build_headers(false)?;
        let url = format!("{}{}?{}", self.host, endpoint, data);
        let response = self.inner.put(&url).headers(headers).send().await?;

        self.handler(response).await
    }

    pub async fn delete<T: DeserializeOwned>(
        &self,
        endpoint: &str,
        listen_key: &str,
        symbol: Option<&str>,
    ) -> Result<T> {
        let data = symbol
            .map(|s| format!("listenKey={listen_key}&symbol={s}"))
            .unwrap_or_else(|| format!("listenKey={listen_key}"));
        let url = format!("{}{}?{}", self.host, endpoint, data);
        let response = self
            .inner
            .delete(url)
            .headers(self.build_headers(false)?)
            .send()
            .await?;

        self.handler(response).await
    }

    // Request must be signed
    fn sign_request(&self, endpoint: &str, request: &str) -> String {
        let signed_key = hmac::Key::new(hmac::HMAC_SHA256, self.secret_key.as_bytes());
        let signature = hex_encode(hmac::sign(&signed_key, request.as_bytes()).as_ref());
        let url = format!("{}{}?{}&signature={}", self.host, endpoint, request, signature);

        url
    }

    fn build_headers(&self, content_type: bool) -> Result<HeaderMap> {
        let header = IntoIterator::into_iter([
            // Always include user agent
            Some((USER_AGENT, HeaderValue::from_static("binance-rs"))),
            // Always include API key
            Some((
                HeaderName::from_static("x-mbx-apikey"),
                HeaderValue::from_str(&self.api_key)?,
            )),
            // Include content type if needed
            if content_type {
                Some((
                    CONTENT_TYPE,
                    HeaderValue::from_static("application/x-www-form-urlencoded"),
                ))
            } else {
                None
            },
        ])
        .flatten()
        .collect();

        Ok(header)
    }

    async fn handler<T: de::DeserializeOwned>(&self, response: Response) -> Result<T> {
        match response.status() {
            StatusCode::OK => Ok(response.json().await?),
            StatusCode::INTERNAL_SERVER_ERROR => Err(Error::InternalServerError),
            StatusCode::SERVICE_UNAVAILABLE => Err(Error::ServiceUnavailable),
            StatusCode::UNAUTHORIZED => Err(Error::Unauthorized),
            StatusCode::BAD_REQUEST => {
                let error: BinanceContentError = response.json().await?;
                Err(handle_content_error(error))
            }
            s => Err(Error::Msg(format!("Received response: {s:?}"))),
        }
    }
}

fn handle_content_error(error: BinanceContentError) -> crate::errors::Error {
    match (error.code, error.msg.as_ref()) {
        (-1013, error_messages::INVALID_PRICE) => Error::InvalidPrice,
        (-1125, msg) => Error::InvalidListenKey(msg.to_string()),
        _ => Error::BinanceError { response: error },
    }
}

</document_content>
</document>
<document index="25">
<source>src/config.rs</source>
<document_content>
pub static DATA_REST_ENDPOINT: &str = "https://api.binance.com";

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Config {
    pub rest_api_endpoint: String,
    pub ws_endpoint: String,

    pub futures_rest_api_endpoint: String,
    pub futures_ws_endpoint: String,

    pub recv_window: u64,

    pub binance_us_api: bool,

    pub timeout: Option<u64>,
}

impl Config {
    /// Configure binance with all testnet endpoints
    /// # Examples
    /// ```
    /// use binance::config::Config;
    /// let config = Config::testnet();
    /// ```
    pub fn testnet() -> Config {
        Config::default()
            .set_rest_api_endpoint("https://testnet.binance.vision")
            .set_ws_endpoint("wss://testnet.binance.vision")
            .set_futures_rest_api_endpoint("https://testnet.binancefuture.com")
            .set_futures_ws_endpoint("wss://fstream.binancefuture.com")
    }

    /// Sets the rest api endpoint. Defaults to <https://api.binance.com>.
    ///
    /// # Arguments
    ///
    /// * `rest_api_endpoint`:
    ///
    /// returns: Config
    ///
    /// # Examples
    ///
    /// ```
    /// use binance::config::Config;
    /// let config = Config::default();
    /// config.set_rest_api_endpoint("http://myendpoint:8080");
    /// ```
    pub fn set_rest_api_endpoint<T: Into<String>>(mut self, rest_api_endpoint: T) -> Self {
        self.rest_api_endpoint = rest_api_endpoint.into();
        self
    }

    /// Sets the websocket endpoint. Defaults to "wss://stream.binance.com:9443".
    ///
    /// # Arguments
    ///
    /// * `ws_endpoint`:
    ///
    /// returns: Config
    ///
    /// # Examples
    ///
    /// ```
    /// use binance::config::Config;
    /// let config = Config::default();
    /// config.set_ws_endpoint("ws://myendpoint:8080");
    /// ```
    pub fn set_ws_endpoint<T: Into<String>>(mut self, ws_endpoint: T) -> Self {
        self.ws_endpoint = ws_endpoint.into();
        self
    }

    /// Sets the futures rest api endpoint. Defaults to <https://fapi.binance.com>.
    ///
    /// # Arguments
    ///
    /// * `futures_rest_api_endpoint`:
    ///
    /// returns: Config
    ///
    /// # Examples
    ///
    /// ```
    /// use binance::config::Config;
    /// let config = Config::default();
    /// config.set_futures_rest_api_endpoint("http://myendpoint:8080");
    /// ```
    pub fn set_futures_rest_api_endpoint<T: Into<String>>(mut self, futures_rest_api_endpoint: T) -> Self {
        self.futures_rest_api_endpoint = futures_rest_api_endpoint.into();
        self
    }

    /// Sets the futures websocket endpoint. Defaults to "wss://fstream.binance.com".
    ///
    /// # Arguments
    ///
    /// * `futures_ws_endpoint`:
    ///
    /// returns: Config
    ///
    /// # Examples
    ///
    /// ```
    /// use binance::config::Config;
    /// let config = Config::default();
    /// config.set_futures_ws_endpoint("ws://myendpoint:8080");
    /// ```
    pub fn set_futures_ws_endpoint<T: Into<String>>(mut self, futures_ws_endpoint: T) -> Self {
        self.futures_ws_endpoint = futures_ws_endpoint.into();
        self
    }

    /// Sets the 'receive window'. The receive window is the number of milliseconds after timestamp
    /// the request is valid for.
    ///
    /// # Arguments
    ///
    /// * `recv_window`: The receive window, in milliseconds. Defaults to 5000.
    ///
    /// returns: Config
    ///
    /// # Examples
    ///
    /// ```
    /// use binance::config::Config;
    /// let config = Config::default();
    /// config.set_recv_window(300);
    /// ```
    pub fn set_recv_window(mut self, recv_window: u64) -> Self {
        self.recv_window = recv_window;
        self
    }

    /// Sets the client timeout
    ///
    /// # Arguments
    ///
    /// * `timeout`: The timeout, in seconds
    ///
    /// returns: Config
    ///
    /// # Examples
    ///
    /// ```
    /// use binance::config::Config;
    /// let config = Config::default();
    /// config.set_timeout(3);
    /// ```
    pub fn set_timeout(mut self, timeout: u64) -> Self {
        self.timeout = Some(timeout);
        self
    }
}

impl Default for Config {
    /// Configure binance with default production endpoints
    /// # Examples
    /// ```
    /// use binance::config::Config;
    /// let config = Config::default();
    /// ```
    fn default() -> Config {
        Config {
            rest_api_endpoint: "https://api.binance.com".into(),
            ws_endpoint: "wss://stream.binance.com:9443".into(),

            futures_rest_api_endpoint: "https://fapi.binance.com".into(),
            futures_ws_endpoint: "wss://fstream.binance.com".into(),

            recv_window: 5000,
            binance_us_api: false,

            timeout: None,
        }
    }
}

</document_content>
</document>
<document index="26">
<source>src/errors.rs</source>
<document_content>
use serde_json::Value;
use std::collections::HashMap;
use thiserror::Error;

#[derive(Debug, Deserialize, Error)]
#[error("code: {code}, msg: {msg}")]
pub struct BinanceContentError {
    pub code: i32,
    pub msg: String,

    #[serde(flatten)]
    extra: HashMap<String, Value>,
}

/// First errors are technical errors
/// All unhandled binance content errors are BinanceError
/// The rest are binance content errors that are properly handled
/// Unhandled binance errors are Msg
#[derive(Error, Debug)]
pub enum Error {
    #[error(transparent)]
    ReqError(#[from] reqwest::Error),
    #[error(transparent)]
    InvalidHeaderError(#[from] reqwest::header::InvalidHeaderValue),
    #[error(transparent)]
    IoError(#[from] std::io::Error),
    #[error(transparent)]
    ParseFloatError(#[from] std::num::ParseFloatError),
    #[error(transparent)]
    UrlParserError(#[from] url::ParseError),
    #[error(transparent)]
    Json(#[from] serde_json::Error),
    #[error(transparent)]
    Qs(#[from] serde_qs::Error),
    #[error(transparent)]
    Tungstenite(#[from] tokio_tungstenite::tungstenite::Error),
    #[error(transparent)]
    TimestampError(#[from] std::time::SystemTimeError),
    #[error(transparent)]
    UTF8Err(#[from] std::str::Utf8Error),
    #[error("{response}")]
    BinanceError {
        #[from]
        response: BinanceContentError,
    },
    #[error("invalid listen key : {0}")]
    InvalidListenKey(String),
    #[error("unknown symbol {0}")]
    UnknownSymbol(String),
    #[error("{msg}")]
    InvalidOrderError { msg: String },
    #[error("invalid price")]
    InvalidPrice,
    #[error("invalid period {0}")]
    InvalidPeriod(String),
    #[error("internal server error")]
    InternalServerError,
    #[error("service unavailable")]
    ServiceUnavailable,
    #[error("Unauthorized")]
    Unauthorized,
    #[error("{0}")]
    Msg(String),
}

/// Custom error messages
pub mod error_messages {
    pub const INVALID_PRICE: &str = "Invalid price.";
}

pub type Result<T> = core::result::Result<T, Error>;

</document_content>
</document>
<document index="27">
<source>src/futures/account.rs</source>
<document_content>
use std::collections::BTreeMap;

use super::rest_model::{AccountBalance, AccountInformation, CanceledOrder, ChangeLeverageResponse, Order, OrderType,
                        Position, PositionSide, Transaction, WorkingType};
use crate::account::OrderCancellation;
use crate::client::Client;
use crate::errors::*;
use crate::rest_model::{OrderSide, TimeInForce};
use crate::rest_model::{PairAndWindowQuery, PairQuery};
use crate::util::*;
use serde::Serializer;
use std::fmt;

#[derive(Clone)]
pub struct FuturesAccount {
    pub client: Client,
    pub recv_window: u64,
}

/// Serialize bool as str
fn serialize_as_str<S, T>(t: &T, serializer: S) -> std::result::Result<S::Ok, S::Error>
where
    S: Serializer,
    T: fmt::Display,
{
    serializer.collect_str(t)
}

/// Serialize opt bool as str
fn serialize_opt_as_uppercase<S, T>(t: &Option<T>, serializer: S) -> std::result::Result<S::Ok, S::Error>
where
    S: Serializer,
    T: ToString,
{
    match *t {
        Some(ref v) => serializer.serialize_some(&v.to_string().to_uppercase()),
        None => serializer.serialize_none(),
    }
}

#[derive(Serialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct GetOrderRequest {
    pub symbol: String,
    #[serde(rename = "orderId")]
    pub order_id: Option<String>,
    #[serde(rename = "origClientOrderId")]
    pub orig_client_order_id: Option<String>,
}

#[derive(Serialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct OrderRequest {
    pub symbol: String,
    pub side: OrderSide,
    pub position_side: Option<PositionSide>,
    #[serde(rename = "type")]
    pub order_type: OrderType,
    pub time_in_force: Option<TimeInForce>,
    #[serde(rename = "quantity")]
    pub quantity: Option<f64>,
    pub reduce_only: Option<bool>,
    pub price: Option<f64>,
    pub stop_price: Option<f64>,
    pub close_position: Option<bool>,
    pub activation_price: Option<f64>,
    pub callback_rate: Option<f64>,
    pub working_type: Option<WorkingType>,
    #[serde(serialize_with = "serialize_opt_as_uppercase")]
    pub price_protect: Option<bool>,
    pub new_client_order_id: Option<String>,
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct ChangePositionModeRequest {
    #[serde(serialize_with = "serialize_as_str")]
    pub dual_side_position: bool,
}

impl FuturesAccount {
    /// Get an order
    pub async fn get_order(&self, order: Option<GetOrderRequest>) -> Result<Transaction> {
        self.client
            .get_signed_p("/fapi/v1/order", order, self.recv_window)
            .await
    }

    /// Place an order
    pub async fn place_order(&self, order: OrderRequest) -> Result<Transaction> {
        self.client
            .post_signed_p("/fapi/v1/order", order, self.recv_window)
            .await
    }

    /// Get currently open orders
    pub async fn get_open_orders(&self, symbol: impl Into<String>) -> Result<Vec<Order>> {
        let payload = build_signed_request_p(PairQuery { symbol: symbol.into() }, self.recv_window)?;
        self.client.get_signed("/fapi/v1/openOrders", &payload).await
    }

    /// Place a test order    
    pub async fn place_order_test(&self, order: OrderRequest) -> Result<Transaction> {
        self.client
            .post_signed_p("/fapi/v1/order/test", order, self.recv_window)
            .await
    }

    /// Place a limit buy order
    pub async fn limit_buy(
        &self,
        symbol: impl Into<String>,
        qty: impl Into<f64>,
        price: f64,
        time_in_force: TimeInForce,
    ) -> Result<Transaction> {
        let order = OrderRequest {
            symbol: symbol.into(),
            side: OrderSide::Buy,
            position_side: None,
            order_type: OrderType::Limit,
            time_in_force: Some(time_in_force),
            quantity: Some(qty.into()),
            reduce_only: None,
            price: Some(price),
            stop_price: None,
            close_position: None,
            activation_price: None,
            callback_rate: None,
            working_type: None,
            price_protect: None,
            new_client_order_id: None,
        };
        self.place_order(order).await
    }

    /// Place a limit sell order
    pub async fn limit_sell(
        &self,
        symbol: impl Into<String>,
        qty: impl Into<f64>,
        price: f64,
        time_in_force: TimeInForce,
    ) -> Result<Transaction> {
        let order = OrderRequest {
            symbol: symbol.into(),
            side: OrderSide::Sell,
            position_side: None,
            order_type: OrderType::Limit,
            time_in_force: Some(time_in_force),
            quantity: Some(qty.into()),
            reduce_only: None,
            price: Some(price),
            stop_price: None,
            close_position: None,
            activation_price: None,
            callback_rate: None,
            working_type: None,
            price_protect: None,
            new_client_order_id: None,
        };
        self.place_order(order).await
    }

    /// Place a Market buy order
    pub async fn market_buy<S, F>(&self, symbol: S, qty: F) -> Result<Transaction>
    where
        S: Into<String>,
        F: Into<f64>,
    {
        let order = OrderRequest {
            symbol: symbol.into(),
            side: OrderSide::Buy,
            position_side: None,
            order_type: OrderType::Market,
            time_in_force: None,
            quantity: Some(qty.into()),
            reduce_only: None,
            price: None,
            stop_price: None,
            close_position: None,
            activation_price: None,
            callback_rate: None,
            working_type: None,
            price_protect: None,
            new_client_order_id: None,
        };
        self.place_order(order).await
    }

    /// Place a Market sell order
    pub async fn market_sell<S, F>(&self, symbol: S, qty: F) -> Result<Transaction>
    where
        S: Into<String>,
        F: Into<f64>,
    {
        let order: OrderRequest = OrderRequest {
            symbol: symbol.into(),
            side: OrderSide::Sell,
            position_side: None,
            order_type: OrderType::Market,
            time_in_force: None,
            quantity: Some(qty.into()),
            reduce_only: None,
            price: None,
            stop_price: None,
            close_position: None,
            activation_price: None,
            callback_rate: None,
            working_type: None,
            price_protect: None,
            new_client_order_id: None,
        };
        self.place_order(order).await
    }

    /// Place a cancellation order
    pub async fn cancel_order(&self, o: OrderCancellation) -> Result<CanceledOrder> {
        let recv_window = o.recv_window.unwrap_or(self.recv_window);
        self.client.delete_signed_p("/fapi/v1/order", &o, recv_window).await
    }

    /// Get current position risk for the symbol
    pub async fn position_information<S>(&self, symbol: S) -> Result<Vec<Position>>
    where
        S: Into<String>,
    {
        self.client
            .get_signed_p(
                "/fapi/v2/positionRisk",
                Some(PairAndWindowQuery {
                    symbol: symbol.into(),
                    recv_window: self.recv_window,
                }),
                self.recv_window,
            )
            .await
    }

    /// Return general [`AccountInformation`]
    pub async fn account_information(&self) -> Result<AccountInformation> {
        // needs to be changed to smth better later
        let payload = build_signed_request(BTreeMap::<String, String>::new(), self.recv_window)?;
        self.client.get_signed_d("/fapi/v2/account", &payload).await
    }

    /// Return account's [`AccountBalance`]
    pub async fn account_balance(&self) -> Result<Vec<AccountBalance>> {
        let parameters = BTreeMap::<String, String>::new();
        let request = build_signed_request(parameters, self.recv_window)?;
        self.client.get_signed_d("/fapi/v2/balance", request.as_str()).await
    }

    /// Change the initial leverage for the symbol
    pub async fn change_initial_leverage<S>(&self, symbol: S, leverage: u8) -> Result<ChangeLeverageResponse>
    where
        S: Into<String>,
    {
        let mut parameters: BTreeMap<String, String> = BTreeMap::new();
        parameters.insert("symbol".into(), symbol.into());
        parameters.insert("leverage".into(), leverage.to_string());

        let request = build_signed_request(parameters, self.recv_window)?;
        self.client.post_signed_d("/fapi/v1/leverage", request.as_str()).await
    }

    /// Change the dual position side
    pub async fn change_position_mode(&self, dual_side_position: bool) -> Result<()> {
        self.client
            .post_signed_p::<(), _>(
                "/fapi/v1/positionSide/dual",
                ChangePositionModeRequest { dual_side_position },
                self.recv_window,
            )
            .await?;
        Ok(())
    }

    /// Cancel all open orders on this symbol
    pub async fn cancel_all_open_orders<S>(&self, symbol: S) -> Result<()>
    where
        S: Into<String>,
    {
        self.client
            .delete_signed_p::<(), _>(
                "/fapi/v1/allOpenOrders",
                PairQuery { symbol: symbol.into() },
                self.recv_window,
            )
            .await?;
        Ok(())
    }
}

</document_content>
</document>
<document index="28">
<source>src/futures/general.rs</source>
<document_content>
use crate::client::*;
use crate::errors::*;
use crate::futures::rest_model::*;
use crate::rest_model::ServerTime;

#[derive(Clone)]
pub struct FuturesGeneral {
    pub client: Client,
}

impl FuturesGeneral {
    /// Test connectivity
    pub async fn ping(&self) -> Result<String> {
        self.client.get::<()>("/fapi/v1/ping", None).await?;
        Ok("pong".into())
    }

    /// Check server time
    pub async fn get_server_time(&self) -> Result<ServerTime> { self.client.get_p("/fapi/v1/time", None).await }

    /// Obtain exchange information
    /// - Current exchange trading rules and symbol information
    pub async fn exchange_info(&self) -> Result<ExchangeInformation> {
        self.client.get_p("/fapi/v1/exchangeInfo", None).await
    }

    /// Get Symbol information
    pub async fn get_symbol_info<S>(&self, symbol: S) -> Result<Symbol>
    where
        S: Into<String>,
    {
        let symbol_string = symbol.into();
        let upper_symbol = symbol_string.to_uppercase();
        match self.exchange_info().await {
            Ok(info) => {
                for item in info.symbols {
                    if item.symbol == upper_symbol {
                        return Ok(item);
                    }
                }
                Err(Error::UnknownSymbol(symbol_string.clone()))
            }
            Err(e) => Err(e),
        }
    }
}

</document_content>
</document>
<document index="29">
<source>src/futures/market.rs</source>
<document_content>
use crate::client::*;
use crate::errors::*;
use crate::futures::rest_model::*;
use crate::rest_model::{BookTickers, KlineSummaries, KlineSummary, PairAndWindowQuery, PairQuery, SymbolPrice, Tickers};
use crate::util::*;
use serde_json::Value;

//TODO : Validate intervals and start/end times in history queries
//TODO : find out the repartition of kline/candlestick columns in the future kline rows
//TODO : make limit optional where applicable

#[derive(Clone)]
pub struct FuturesMarket {
    pub client: Client,
    pub recv_window: u64,
}

impl FuturesMarket {
    /// Order book (Default 100; max 1000)
    pub async fn get_depth<S>(&self, symbol: S) -> Result<OrderBook>
    where
        S: Into<String>,
    {
        self.client
            .get_d("/fapi/v1/depth", Some(PairQuery { symbol: symbol.into() }))
            .await
    }

    /// Get trades for a pair
    pub async fn get_trades<S>(&self, symbol: S) -> Result<Trades>
    where
        S: Into<String>,
    {
        self.client
            .get_d("/fapi/v1/trades", Some(PairQuery { symbol: symbol.into() }))
            .await
    }

    /// Get historical trades
    pub async fn get_historical_trades<S1, S2, S3>(&self, symbol: S1, from_id: S2, limit: S3) -> Result<Trades>
    where
        S1: Into<String>,
        S2: Into<Option<u64>>,
        S3: Into<u16>,
    {
        self.client
            .get_signed_p(
                "/fapi/v1/historicalTrades",
                Some(HistoryQuery {
                    start_time: None,
                    end_time: None,
                    from_id: from_id.into(),
                    limit: limit.into(),
                    symbol: symbol.into(),
                    interval: None,
                    period: None,
                }),
                self.recv_window,
            )
            .await
    }

    /// Get aggregated trades
    pub async fn get_agg_trades<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        from_id: S2,
        start_time: S3,
        end_time: S4,
        limit: S5,
    ) -> Result<AggTrades>
    where
        S1: Into<String>,
        S2: Into<Option<u64>>,
        S3: Into<Option<u64>>,
        S4: Into<Option<u64>>,
        S5: Into<u16>,
    {
        self.client
            .get_signed_p(
                "/fapi/v1/aggTrades",
                Some(HistoryQuery {
                    start_time: start_time.into(),
                    end_time: end_time.into(),
                    from_id: from_id.into(),
                    limit: limit.into(),
                    symbol: symbol.into(),
                    interval: None,
                    period: None,
                }),
                self.recv_window,
            )
            .await
    }

    /// Get funding rate history
    pub async fn get_funding_rate<S1, S3, S4, S5>(
        &self,
        symbol: S1,
        start_time: S3,
        end_time: S4,
        limit: S5,
    ) -> Result<Vec<FundingRate>>
    where
        S1: Into<String>,
        S3: Into<Option<u64>>,
        S4: Into<Option<u64>>,
        S5: Into<u16>,
    {
        self.client
            .get_signed_p(
                "/fapi/v1/fundingRate",
                Some(HistoryQuery {
                    start_time: start_time.into(),
                    end_time: end_time.into(),
                    limit: limit.into(),
                    symbol: symbol.into(),
                    from_id: None,
                    interval: None,
                    period: None,
                }),
                self.recv_window,
            )
            .await
    }

    /// Get open interest history
    pub async fn get_open_interest_history<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        period: S2,
        start_time: S3,
        end_time: S4,
        limit: S5,
    ) -> Result<Vec<OpenInterestHistory>>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<Option<u64>>,
        S4: Into<Option<u64>>,
        S5: Into<u16>,
    {
        let query = HistoryQuery {
            start_time: start_time.into(),
            end_time: end_time.into(),
            limit: limit.into(),
            symbol: symbol.into(),
            period: Some(period.into()),
            from_id: None,
            interval: None,
        };
        query.validate()?;
        self.client
            .get_signed_p("/futures/data/openInterestHist", Some(query), self.recv_window)
            .await
    }

    /// Get Top Trader Account Long/Short Ratio
    pub async fn get_trader_account_long_short_ratio<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        period: S2,
        start_time: S3,
        end_time: S4,
        limit: S5,
    ) -> Result<Vec<LongShortRatio>>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<Option<u64>>,
        S4: Into<Option<u64>>,
        S5: Into<u16>,
    {
        let query = HistoryQuery {
            start_time: start_time.into(),
            end_time: end_time.into(),
            limit: limit.into(),
            symbol: symbol.into(),
            period: Some(period.into()),
            from_id: None,
            interval: None,
        };
        query.validate()?;
        self.client
            .get_signed_p("/futures/data/topLongShortAccountRatio", Some(query), self.recv_window)
            .await
    }

    /// Get Top Trader Position Long/Short Ratio
    pub async fn get_trader_position_long_short_ratio<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        period: S2,
        start_time: S3,
        end_time: S4,
        limit: S5,
    ) -> Result<Vec<LongShortRatio>>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<Option<u64>>,
        S4: Into<Option<u64>>,
        S5: Into<u16>,
    {
        let query = HistoryQuery {
            start_time: start_time.into(),
            end_time: end_time.into(),
            limit: limit.into(),
            symbol: symbol.into(),
            period: Some(period.into()),
            from_id: None,
            interval: None,
        };
        query.validate()?;
        self.client
            .get_signed_p("/futures/data/topLongShortPositionRatio", Some(query), self.recv_window)
            .await
    }

    /// Get Long/Short Ratio
    pub async fn get_long_short_ratio<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        period: S2,
        start_time: S3,
        end_time: S4,
        limit: S5,
    ) -> Result<Vec<LongShortRatio>>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<Option<u64>>,
        S4: Into<Option<u64>>,
        S5: Into<u16>,
    {
        let query = HistoryQuery {
            start_time: start_time.into(),
            end_time: end_time.into(),
            limit: limit.into(),
            symbol: symbol.into(),
            period: Some(period.into()),
            from_id: None,
            interval: None,
        };
        query.validate()?;
        self.client
            .get_signed_p(
                "/futures/data/globalLongShortAccountRatio",
                Some(query),
                self.recv_window,
            )
            .await
    }

    /// Get Taker Long/Short Ratio
    pub async fn get_taker_long_short_ratio<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        period: S2,
        start_time: S3,
        end_time: S4,
        limit: S5,
    ) -> Result<Vec<LongShortRatio>>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<Option<u64>>,
        S4: Into<Option<u64>>,
        S5: Into<u16>,
    {
        let query = HistoryQuery {
            start_time: start_time.into(),
            end_time: end_time.into(),
            limit: limit.into(),
            symbol: symbol.into(),
            period: Some(period.into()),
            from_id: None,
            interval: None,
        };
        query.validate()?;
        self.client
            .get_signed_p("/futures/data/takerlongshortRatio", Some(query), self.recv_window)
            .await
    }

    /// Returns up to 'limit' klines for given symbol and interval ("1m", "5m", ...)
    /// https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#klinecandlestick-data
    pub async fn get_klines<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        interval: S2,
        limit: S3,
        start_time: S4,
        end_time: S5,
    ) -> Result<KlineSummaries>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<u16>,
        S4: Into<Option<u64>>,
        S5: Into<Option<u64>>,
    {
        let query = HistoryQuery {
            start_time: start_time.into(),
            end_time: end_time.into(),
            limit: limit.into(),
            symbol: symbol.into(),
            interval: Some(interval.into()),
            from_id: None,
            period: None,
        };
        let data: Vec<Vec<Value>> = self.client.get_d("/fapi/v1/klines", Some(query)).await?;

        let klines = KlineSummaries::AllKlineSummaries(
            data.iter()
                .map(|row| KlineSummary {
                    open_time: to_i64(&row[0]),
                    open: to_f64(&row[1]),
                    high: to_f64(&row[2]),
                    low: to_f64(&row[3]),
                    close: to_f64(&row[4]),
                    volume: to_f64(&row[5]),
                    close_time: to_i64(&row[6]),
                    quote_asset_volume: to_f64(&row[7]),
                    number_of_trades: to_i64(&row[8]),
                    taker_buy_base_asset_volume: to_f64(&row[9]),
                    taker_buy_quote_asset_volume: to_f64(&row[10]),
                })
                .collect(),
        );
        Ok(klines)
    }

    /// Returns up to 'limit' blvt klines for given symbol and interval ("1m", "5m", ...)
    /// Note that the symbol is not the traditional pair but rather {symbol}{UP|DOWN}
    /// https://binance-docs.github.io/apidocs/futures/en/#blvt-nav-kline-candlestick-streams
    /// As the vector fields are undocumented on binance futures you are un your own, follow
    /// KlineSummary for an example
    pub async fn get_blvt_klines_v<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        interval: S2,
        limit: S3,
        start_time: S4,
        end_time: S5,
    ) -> Result<Vec<Vec<Value>>>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<u16>,
        S4: Into<Option<u64>>,
        S5: Into<Option<u64>>,
    {
        let query = HistoryQuery {
            start_time: start_time.into(),
            end_time: end_time.into(),
            limit: limit.into(),
            symbol: symbol.into(),
            interval: Some(interval.into()),
            from_id: None,
            period: None,
        };
        let klines = self.client.get_d("/fapi/v1/lvtKlines", Some(query)).await?;

        Ok(klines)
    }

    /// Returns up to 'limit' mark price klines for given symbol and interval ("1m", "5m", ...)
    /// https://binance-docs.github.io/apidocs/futures/en/#mark-price-kline-candlestick-data
    /// As the vector fields are undocumented on binance futures you are un your own, follow
    /// KlineSummary for an example
    pub async fn get_mark_price_klines_v<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        interval: S2,
        limit: S3,
        start_time: S4,
        end_time: S5,
    ) -> Result<Vec<Vec<Value>>>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<u16>,
        S4: Into<Option<u64>>,
        S5: Into<Option<u64>>,
    {
        let query = HistoryQuery {
            start_time: start_time.into(),
            end_time: end_time.into(),
            limit: limit.into(),
            symbol: symbol.into(),
            interval: Some(interval.into()),
            from_id: None,
            period: None,
        };
        let klines = self.client.get_d("/fapi/v1/markPriceKlines", Some(query)).await?;

        Ok(klines)
    }

    /// Returns up to 'limit' index price klines for given symbol and interval ("1m", "5m", ...)
    /// https://binance-docs.github.io/apidocs/futures/en/#index-price-kline-candlestick-data
    /// As the vector fields are undocumented on binance futures you are un your own, follow
    /// KlineSummary for an example
    pub async fn get_index_price_klines_v<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        interval: S2,
        limit: S3,
        start_time: S4,
        end_time: S5,
    ) -> Result<Vec<Vec<Value>>>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<u16>,
        S4: Into<Option<u64>>,
        S5: Into<Option<u64>>,
    {
        let query = IndexQuery {
            start_time: start_time.into(),
            end_time: end_time.into(),
            limit: limit.into(),
            pair: symbol.into(),
            interval: Some(interval.into()),
        };

        let klines = self.client.get_d("/fapi/v1/indexPriceKlines", Some(query)).await?;

        Ok(klines)
    }

    /// Returns up to 'limit' continuous contract klines for given symbol and interval ("1m", "5m", ...)
    /// https://binance-docs.github.io/apidocs/futures/en/#continuous-contract-kline-candlestick-data
    /// As the vector fields are undocumented on binance futures you are un your own, follow
    /// KlineSummary for an example
    pub async fn get_continuous_contract_klines_v<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        interval: S2,
        limit: S3,
        start_time: S4,
        end_time: S5,
    ) -> Result<Vec<Vec<Value>>>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<u16>,
        S4: Into<Option<u64>>,
        S5: Into<Option<u64>>,
    {
        let query = HistoryQuery {
            start_time: start_time.into(),
            end_time: end_time.into(),
            limit: limit.into(),
            symbol: symbol.into(),
            interval: Some(interval.into()),
            from_id: None,
            period: None,
        };
        let klines = self.client.get_d("/fapi/v1/continuousKlines", Some(query)).await?;

        Ok(klines)
    }

    /// https://binance-docs.github.io/apidocs/futures/en/#notional-and-leverage-brackets-user_data
    pub async fn get_notional_leverage_brackets<S>(&self, symbol: S) -> Result<Vec<SymbolBrackets>>
    where
        S: Into<String>,
    {
        let p = PairAndWindowQuery {
            symbol: symbol.into(),
            recv_window: self.recv_window,
        };
        self.client
            .get_signed_p("/fapi/v1/leverageBracket", Some(p), self.recv_window)
            .await
    }

    /// https://binance-docs.github.io/apidocs/futures/en/#composite-index-symbol-information
    /// Only for composite symbols (ex: DEFIUSDT)
    pub async fn get_index_info<S>(&self, symbol: Option<S>) -> Result<PriceStats>
    where
        S: Into<String>,
    {
        let p = symbol.map(|s| PairQuery { symbol: s.into() });
        self.client.get_d("/fapi/v1/indexInfo", p).await
    }

    /// 24hr ticker price change statistics
    pub async fn get_24h_price_stats<S>(&self, symbol: S) -> Result<PriceStats>
    where
        S: Into<String>,
    {
        self.client
            .get_d("/fapi/v1/ticker/24hr", Some(PairQuery { symbol: symbol.into() }))
            .await
    }

    /// 24hr ticker price change statistics for all symbols
    pub async fn get_all_24h_price_stats(&self) -> Result<Vec<PriceStats>> {
        self.client.get_p("/fapi/v1/ticker/24hr", None).await
    }

    /// Latest price for ONE symbol.
    pub async fn get_price<S>(&self, symbol: S) -> Result<SymbolPrice>
    where
        S: Into<String>,
    {
        self.client
            .get_d("/fapi/v2/ticker/price", Some(PairQuery { symbol: symbol.into() }))
            .await
    }

    /// Symbols order book ticker
    /// -> Best price/qty on the order book for ALL symbols.
    pub async fn get_all_book_tickers(&self) -> Result<BookTickers> {
        self.client.get_p("/fapi/v1/ticker/bookTicker", None).await
    }

    // -> Best price/qty on the order book for ONE symbol
    pub async fn get_book_ticker<S>(&self, symbol: S) -> Result<Tickers>
    where
        S: Into<String>,
    {
        self.client
            .get_d("/fapi/v1/ticker/bookTicker", Some(PairQuery { symbol: symbol.into() }))
            .await
    }

    pub async fn get_mark_prices(&self, symbol: Option<String>) -> Result<Vec<MarkPrice>> {
        if let Some(symbol) = symbol {
            Ok(vec![
                self.client
                    .get_d::<MarkPrice, PairQuery>("/fapi/v1/premiumIndex", Some(PairQuery { symbol }))
                    .await?,
            ])
        } else {
            self.client.get_p("/fapi/v1/premiumIndex", None).await
        }
    }

    pub async fn get_all_liquidation_orders(&self) -> Result<LiquidationOrders> {
        self.client.get_p("/fapi/v1/allForceOrders", None).await
    }

    pub async fn open_interest<S>(&self, symbol: S) -> Result<OpenInterest>
    where
        S: Into<String>,
    {
        self.client
            .get_d("/fapi/v1/openInterest", Some(PairQuery { symbol: symbol.into() }))
            .await
    }
}

</document_content>
</document>
<document index="30">
<source>src/futures/mod.rs</source>
<document_content>
pub mod account;
pub mod general;
pub mod market;
pub mod rest_model;
pub mod userstream;
pub mod websockets;
pub mod ws_model;

</document_content>
</document>
<document index="31">
<source>src/futures/rest_model.rs</source>
<document_content>
use crate::rest_model::{string_or_bool, string_or_float_opt};
pub use crate::rest_model::{string_or_float, string_or_u64, Asks, Bids, BookTickers, KlineSummaries, KlineSummary,
                            OrderSide, OrderStatus, RateLimit, ServerTime, SymbolPrice, SymbolStatus, Tickers,
                            TimeInForce};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ExchangeInformation {
    pub timezone: String,
    pub server_time: u64,
    pub futures_type: String,
    pub rate_limits: Vec<RateLimit>,
    pub exchange_filters: Vec<Filters>,
    pub assets: Vec<AssetDetail>,
    pub symbols: Vec<Symbol>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AssetDetail {
    pub asset: String,
    pub margin_available: bool,
    #[serde(with = "string_or_float")]
    pub auto_asset_exchange: f64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Symbol {
    pub symbol: String,
    pub pair: String,
    pub contract_type: ContractType,
    pub delivery_date: u64,
    pub onboard_date: u64,
    pub status: SymbolStatus,
    #[serde(with = "string_or_float")]
    pub maint_margin_percent: f64,
    #[serde(with = "string_or_float")]
    pub required_margin_percent: f64,
    pub base_asset: String,
    pub quote_asset: String,
    pub price_precision: u16,
    pub quantity_precision: u16,
    pub base_asset_precision: u64,
    pub quote_precision: u64,
    pub underlying_type: String,
    pub underlying_sub_type: Vec<String>,
    pub settle_plan: u64,
    #[serde(with = "string_or_float")]
    pub trigger_protect: f64,
    pub filters: Vec<Filters>,
    pub order_types: Vec<OrderType>,
    pub time_in_force: Vec<TimeInForce>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ContractType {
    Perpetual,
    CurrentMonth,
    NextMonth,
    CurrentQuarter,
    NextQuarter,
    #[serde(rename = "CURRENT_QUARTER DELIVERING")]
    CurrentQuarterDelivery,
    PerpetualDelivering,
    #[serde(rename = "")]
    Empty,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum OrderType {
    Limit,
    Market,
    Stop,
    StopMarket,
    TakeProfit,
    TakeProfitMarket,
    TrailingStopMarket,
}

/// By default, use market orders
impl Default for OrderType {
    fn default() -> Self { Self::Market }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum PositionSide {
    Both,
    Long,
    Short,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum WorkingType {
    MarkPrice,
    ContractPrice,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(rename_all = "lowercase")]
pub enum MarginType {
    Isolated,
    Cross,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(tag = "filterType")]
pub enum Filters {
    #[serde(rename = "PRICE_FILTER")]
    #[serde(rename_all = "camelCase")]
    PriceFilter {
        #[serde(with = "string_or_float")]
        min_price: f64,
        #[serde(with = "string_or_float")]
        max_price: f64,
        #[serde(with = "string_or_float")]
        tick_size: f64,
    },
    #[serde(rename = "LOT_SIZE")]
    #[serde(rename_all = "camelCase")]
    LotSize {
        #[serde(with = "string_or_float")]
        min_qty: f64,
        #[serde(with = "string_or_float")]
        max_qty: f64,
        #[serde(with = "string_or_float")]
        step_size: f64,
    },
    #[serde(rename = "MARKET_LOT_SIZE")]
    #[serde(rename_all = "camelCase")]
    MarketLotSize {
        min_qty: String,
        max_qty: String,
        step_size: String,
    },
    #[serde(rename = "MAX_NUM_ORDERS")]
    #[serde(rename_all = "camelCase")]
    MaxNumOrders { limit: u16 },
    #[serde(rename = "MAX_NUM_ALGO_ORDERS")]
    #[serde(rename_all = "camelCase")]
    MaxNumAlgoOrders { limit: u16 },
    #[serde(rename = "MIN_NOTIONAL")]
    #[serde(rename_all = "camelCase")]
    MinNotional {
        #[serde(with = "string_or_float")]
        notional: f64,
    },
    #[serde(rename = "PERCENT_PRICE")]
    #[serde(rename_all = "camelCase")]
    PercentPrice {
        #[serde(with = "string_or_float")]
        multiplier_up: f64,
        #[serde(with = "string_or_float")]
        multiplier_down: f64,
        #[serde(with = "string_or_float")]
        multiplier_decimal: f64,
    },
    #[serde(other)]
    Others,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrderBook {
    pub last_update_id: u64,
    // Undocumented
    #[serde(rename = "E")]
    pub event_time: u64,
    // Undocumented
    #[serde(rename = "T")]
    pub trade_order_time: u64,
    pub bids: Vec<Bids>,
    pub asks: Vec<Asks>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct PriceStats {
    pub symbol: String,
    pub price_change: String,
    pub price_change_percent: String,
    pub weighted_avg_price: String,
    #[serde(with = "string_or_float")]
    pub last_price: f64,
    #[serde(with = "string_or_float")]
    pub open_price: f64,
    #[serde(with = "string_or_float")]
    pub high_price: f64,
    #[serde(with = "string_or_float")]
    pub low_price: f64,
    #[serde(with = "string_or_float")]
    pub volume: f64,
    #[serde(with = "string_or_float")]
    pub quote_volume: f64,
    #[serde(with = "string_or_float")]
    pub last_qty: f64,
    pub open_time: u64,
    pub close_time: u64,
    pub first_id: u64,
    pub last_id: u64,
    pub count: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum Trades {
    AllTrades(Vec<Trade>),
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Trade {
    pub id: u64,
    pub is_buyer_maker: bool,
    #[serde(with = "string_or_float")]
    pub price: f64,
    #[serde(with = "string_or_float")]
    pub qty: f64,
    #[serde(with = "string_or_float")]
    pub quote_qty: f64,
    pub time: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum AggTrades {
    AllAggTrades(Vec<AggTrade>),
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AggTrade {
    #[serde(rename = "T")]
    pub time: u64,
    #[serde(rename = "a")]
    pub agg_id: u64,
    #[serde(rename = "f")]
    pub first_id: u64,
    #[serde(rename = "l")]
    pub last_id: u64,
    #[serde(rename = "m")]
    pub maker: bool,
    #[serde(rename = "p", with = "string_or_float")]
    pub price: f64,
    #[serde(rename = "q", with = "string_or_float")]
    pub qty: f64,
}

// #[derive(Debug, Serialize, Deserialize, Clone)]
// #[serde(untagged)]
// pub enum MarkPrices {
//     AllMarkPrices(Vec<MarkPrice>),
// }

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct MarkPrice {
    pub symbol: String,
    #[serde(with = "string_or_float")]
    pub mark_price: f64,
    #[serde(with = "string_or_float")]
    pub index_price: f64,
    #[serde(with = "string_or_float")]
    pub estimated_settle_price: f64,
    #[serde(with = "string_or_float")]
    pub last_funding_rate: f64,
    pub next_funding_time: u64,
    #[serde(with = "string_or_float")]
    pub interest_rate: f64,
    pub time: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum LiquidationOrders {
    AllLiquidationOrders(Vec<LiquidationOrder>),
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct LiquidationOrder {
    #[serde(with = "string_or_float")]
    pub average_price: f64,
    #[serde(with = "string_or_float")]
    pub executed_qty: f64,
    #[serde(with = "string_or_float")]
    pub orig_qty: f64,
    #[serde(with = "string_or_float")]
    pub price: f64,
    pub side: String,
    pub status: String,
    pub symbol: String,
    pub time: u64,
    pub time_in_force: String,
    pub r#type: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OpenInterest {
    #[serde(with = "string_or_float")]
    pub open_interest: f64,
    pub symbol: String,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Order {
    pub client_order_id: String,
    #[serde(with = "string_or_float")]
    pub cum_quote: f64,
    #[serde(with = "string_or_float")]
    pub executed_qty: f64,
    pub order_id: u64,
    #[serde(with = "string_or_float")]
    pub avg_price: f64,
    #[serde(with = "string_or_float")]
    pub orig_qty: f64,
    #[serde(with = "string_or_float")]
    pub price: f64,
    pub side: OrderSide,
    pub reduce_only: bool,
    pub position_side: PositionSide,
    pub status: OrderStatus,
    #[serde(with = "string_or_float", default = "default_stop_price")]
    pub stop_price: f64,
    pub close_position: bool,
    pub symbol: String,
    pub time_in_force: TimeInForce,
    #[serde(rename = "type")]
    pub order_type: OrderType,
    pub orig_type: OrderType,
    #[serde(with = "string_or_float", default = "default_activation_price")]
    pub activate_price: f64,
    #[serde(with = "string_or_float", default = "default_price_rate")]
    pub price_rate: f64,
    pub update_time: u64,
    pub working_type: WorkingType,
    pub price_protect: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Transaction {
    pub client_order_id: String,
    #[serde(with = "string_or_float")]
    pub cum_qty: f64,
    #[serde(with = "string_or_float")]
    pub cum_quote: f64,
    #[serde(with = "string_or_float")]
    pub executed_qty: f64,
    pub order_id: u64,
    #[serde(with = "string_or_float")]
    pub avg_price: f64,
    #[serde(with = "string_or_float")]
    pub orig_qty: f64,
    pub reduce_only: bool,
    pub side: OrderSide,
    pub position_side: PositionSide,
    pub status: OrderStatus,
    #[serde(with = "string_or_float")]
    pub stop_price: f64,
    pub close_position: bool,
    pub symbol: String,
    pub time_in_force: TimeInForce,
    #[serde(rename = "type")]
    pub type_name: OrderType,
    pub orig_type: OrderType,
    #[serde(default)]
    #[serde(with = "string_or_float_opt")]
    pub activate_price: Option<f64>,
    #[serde(default)]
    #[serde(with = "string_or_float_opt")]
    pub price_rate: Option<f64>,
    pub update_time: u64,
    pub working_type: WorkingType,
    price_protect: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct CanceledOrder {
    pub client_order_id: String,
    #[serde(with = "string_or_float")]
    pub cum_qty: f64,
    #[serde(with = "string_or_float")]
    pub cum_quote: f64,
    #[serde(with = "string_or_float")]
    pub executed_qty: f64,
    pub order_id: u64,
    #[serde(with = "string_or_float")]
    pub orig_qty: f64,
    pub orig_type: String,
    #[serde(with = "string_or_float")]
    pub price: f64,
    pub reduce_only: bool,
    pub side: String,
    pub position_side: String,
    pub status: String,
    #[serde(with = "string_or_float")]
    pub stop_price: f64,
    pub close_position: bool,
    pub symbol: String,
    pub time_in_force: String,
    #[serde(rename = "type")]
    pub type_name: String,
    #[serde(default)]
    #[serde(with = "string_or_float_opt")]
    pub activate_price: Option<f64>,
    #[serde(default)]
    #[serde(with = "string_or_float_opt")]
    pub price_rate: Option<f64>,
    pub update_time: u64,
    pub working_type: String,
    price_protect: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Position {
    #[serde(with = "string_or_float")]
    pub entry_price: f64,
    pub margin_type: MarginType,
    #[serde(with = "string_or_bool")]
    pub is_auto_add_margin: bool,
    #[serde(with = "string_or_float")]
    pub isolated_margin: f64,
    #[serde(with = "string_or_u64")]
    pub leverage: u64,
    #[serde(with = "string_or_float")]
    pub liquidation_price: f64,
    #[serde(with = "string_or_float")]
    pub mark_price: f64,
    #[serde(with = "string_or_float")]
    pub max_notional_value: f64,
    #[serde(with = "string_or_float", rename = "positionAmt")]
    pub position_amount: f64,
    pub symbol: String,
    #[serde(with = "string_or_float", rename = "unRealizedProfit")]
    pub unrealized_profit: f64,
    pub position_side: PositionSide,
    pub update_time: u64,
    #[serde(with = "string_or_float")]
    pub notional: f64,
    #[serde(with = "string_or_float")]
    pub isolated_wallet: f64,
}

// https://binance-docs.github.io/apidocs/futures/en/#account-information-v2-user_data
// it has differences from Position returned by positionRisk endpoint
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AccountPosition {
    pub symbol: String,
    #[serde(with = "string_or_float")]
    pub initial_margin: f64,
    #[serde(with = "string_or_float", rename = "maintMargin")]
    pub maintenance_margin: f64,
    #[serde(with = "string_or_float")]
    pub unrealized_profit: f64,
    #[serde(with = "string_or_float")]
    pub position_initial_margin: f64,
    #[serde(with = "string_or_float")]
    pub open_order_initial_margin: f64,
    #[serde(with = "string_or_u64")]
    pub leverage: u64,
    pub isolated: bool,
    #[serde(with = "string_or_float")]
    pub entry_price: f64,
    #[serde(with = "string_or_float")]
    pub max_notional: f64,
    #[serde(with = "string_or_float")]
    pub bid_notional: f64,
    #[serde(with = "string_or_float")]
    pub ask_notional: f64,
    pub position_side: PositionSide,
    #[serde(with = "string_or_float", rename = "positionAmt")]
    pub position_amount: f64,
    pub update_time: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AccountAsset {
    pub asset: String,
    #[serde(with = "string_or_float")]
    pub wallet_balance: f64,
    #[serde(with = "string_or_float")]
    pub unrealized_profit: f64,
    #[serde(with = "string_or_float")]
    pub margin_balance: f64,
    #[serde(with = "string_or_float")]
    pub maint_margin: f64,
    #[serde(with = "string_or_float")]
    pub initial_margin: f64,
    #[serde(with = "string_or_float")]
    pub position_initial_margin: f64,
    #[serde(with = "string_or_float")]
    pub open_order_initial_margin: f64,
    #[serde(with = "string_or_float")]
    pub cross_wallet_balance: f64,
    #[serde(with = "string_or_float", rename = "crossUnPnl")]
    pub cross_unrealized_pnl: f64,
    #[serde(with = "string_or_float")]
    pub available_balance: f64,
    #[serde(with = "string_or_float")]
    pub max_withdraw_amount: f64,
    pub margin_available: bool,
    pub update_time: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AccountInformation {
    pub fee_tier: u64,
    pub can_trade: bool,
    pub can_deposit: bool,
    pub can_withdraw: bool,
    pub update_time: u64,
    pub multi_assets_margin: bool,
    #[serde(with = "string_or_float")]
    pub total_initial_margin: f64,
    #[serde(with = "string_or_float", rename = "totalMaintMargin")]
    pub total_maintenance_margin: f64,
    #[serde(with = "string_or_float")]
    pub total_wallet_balance: f64,
    #[serde(with = "string_or_float")]
    pub total_unrealized_profit: f64,
    #[serde(with = "string_or_float")]
    pub total_margin_balance: f64,
    #[serde(with = "string_or_float")]
    pub total_position_initial_margin: f64,
    #[serde(with = "string_or_float")]
    pub total_open_order_initial_margin: f64,
    #[serde(with = "string_or_float")]
    pub total_cross_wallet_balance: f64,
    #[serde(with = "string_or_float", rename = "totalCrossUnPnl")]
    pub total_cross_unrealized_pnl: f64,
    #[serde(with = "string_or_float")]
    pub available_balance: f64,
    #[serde(with = "string_or_float")]
    pub max_withdraw_amount: f64,
    pub assets: Vec<AccountAsset>,
    pub positions: Vec<AccountPosition>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AccountBalance {
    pub account_alias: String,
    pub asset: String,
    #[serde(with = "string_or_float")]
    pub balance: f64,
    #[serde(with = "string_or_float")]
    pub cross_wallet_balance: f64,
    #[serde(with = "string_or_float", rename = "crossUnPnl")]
    pub cross_unrealized_pnl: f64,
    #[serde(with = "string_or_float")]
    pub available_balance: f64,
    #[serde(with = "string_or_float")]
    pub max_withdraw_amount: f64,
    pub margin_available: bool,
    pub update_time: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ChangeLeverageResponse {
    pub leverage: u8,
    #[serde(with = "string_or_float")]
    pub max_notional_value: f64,
    pub symbol: String,
}

fn default_stop_price() -> f64 { 0.0 }
fn default_activation_price() -> f64 { 0.0 }
fn default_price_rate() -> f64 { 0.0 }

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct HistoryQuery {
    pub start_time: Option<u64>,
    pub end_time: Option<u64>,
    pub from_id: Option<u64>,
    pub limit: u16,
    pub symbol: String,
    pub interval: Option<String>,
    pub period: Option<String>,
}

impl HistoryQuery {
    pub fn validate(&self) -> crate::errors::Result<()> {
        if let Some(period) = &self.period {
            if !PERIODS.contains(&period.as_str()) {
                return Err(crate::errors::Error::InvalidPeriod(period.clone()));
            }
        }
        Ok(())
    }
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct IndexQuery {
    pub start_time: Option<u64>,
    pub end_time: Option<u64>,
    pub limit: u16,
    pub pair: String,
    pub interval: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct FundingRate {
    pub symbol: String,
    pub funding_time: u64,
    #[serde(with = "string_or_float")]
    pub funding_rate: f64,
}

pub static PERIODS: &[&str] = &["5m", "15m", "30m", "1h", "2h", "4h", "6h", "12h", "1d"];

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct OpenInterestHistory {
    pub symbol: String,
    #[serde(with = "string_or_float")]
    pub sum_open_interest: f64,
    #[serde(with = "string_or_float")]
    pub sum_open_interest_value: f64,
    pub timestamp: u64,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LongShortRatio {
    pub symbol: String,
    #[serde(with = "string_or_float")]
    pub long_account: f64,
    #[serde(with = "string_or_float")]
    pub long_short_ratio: f64,
    #[serde(with = "string_or_float")]
    pub short_account: f64,
    pub timestamp: u64,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LeverageBracket {
    pub bracket: u8,
    pub initial_leverage: u8,
    pub notional_cap: u64,
    pub notional_floor: u64,
    pub maint_margin_ratio: f64,
    pub cum: f64,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SymbolBrackets {
    pub symbol: String,
    pub notional_coef: Option<f64>,
    pub brackets: Vec<LeverageBracket>,
}

</document_content>
</document>
<document index="32">
<source>src/futures/userstream.rs</source>
<document_content>
use crate::client::*;
use crate::errors::*;
use crate::rest_model::*;

static USER_DATA_STREAM: &str = "/fapi/v1/listenKey";

#[derive(Clone)]
pub struct UserStream {
    pub client: Client,
    pub recv_window: u64,
}

impl UserStream {
    /// Get a listen key for the stream
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, futures::userstream::*, config::*};
    /// let userstream: UserStream = Binance::new_with_env(&Config::testnet());
    /// let start = tokio_test::block_on(userstream.start());
    /// assert!(start.is_ok(), "{:?}", start);
    /// assert!(start.unwrap().listen_key.len() > 0)
    /// ```
    pub async fn start(&self) -> Result<UserDataStream> { self.client.post(USER_DATA_STREAM, None).await }

    /// Keep the connection alive, as the listen key becomes invalid after 60mn
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, futures::userstream::*, config::*};
    /// let userstream: UserStream = Binance::new_with_env(&Config::testnet());
    /// let start = tokio_test::block_on(userstream.start());
    /// assert!(start.is_ok(), "{:?}", start);
    /// let keep_alive = tokio_test::block_on(userstream.keep_alive(&start.unwrap().listen_key));
    /// assert!(keep_alive.is_ok())
    /// ```
    pub async fn keep_alive(&self, listen_key: &str) -> Result<Success> {
        self.client.put(USER_DATA_STREAM, listen_key, None).await
    }

    /// Invalidate the listen key
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, futures::userstream::*, config::*};
    /// let userstream: UserStream = Binance::new_with_env(&Config::testnet());
    /// let start = tokio_test::block_on(userstream.start());
    /// assert!(start.is_ok(), "{:?}", start);
    /// let close = tokio_test::block_on(userstream.close(&start.unwrap().listen_key));
    /// assert!(close.is_ok())
    /// ```
    pub async fn close(&self, listen_key: &str) -> Result<Success> {
        self.client.delete(USER_DATA_STREAM, listen_key, None).await
    }
}

</document_content>
</document>
<document index="33">
<source>src/futures/websockets.rs</source>
<document_content>
use std::sync::atomic::{AtomicBool, Ordering};

use futures::StreamExt;
use serde_json::from_str;
use tokio::net::TcpStream;
use tokio_tungstenite::tungstenite::handshake::client::Response;
use tokio_tungstenite::tungstenite::Message;
use tokio_tungstenite::WebSocketStream;
use tokio_tungstenite::{connect_async, MaybeTlsStream};
use url::Url;

use crate::config::Config;
use crate::errors::*;

pub static STREAM_ENDPOINT: &str = "stream";
pub static WS_ENDPOINT: &str = "ws";
pub static OUTBOUND_ACCOUNT_INFO: &str = "outboundAccountInfo";
pub static OUTBOUND_ACCOUNT_POSITION: &str = "outboundAccountPosition";
pub static EXECUTION_REPORT: &str = "executionReport";
pub static KLINE: &str = "kline";
pub static AGGREGATED_TRADE: &str = "aggTrade";
pub static DEPTH_ORDERBOOK: &str = "depthUpdate";
pub static PARTIAL_ORDERBOOK: &str = "lastUpdateId";
pub static DAYTICKER: &str = "24hrTicker";

pub fn all_ticker_stream() -> &'static str { "!ticker@arr" }

pub fn ticker_stream(symbol: &str) -> String { format!("{symbol}@ticker") }

pub fn agg_trade_stream(symbol: &str) -> String { format!("{symbol}@aggTrade") }

pub fn trade_stream(symbol: &str) -> String { format!("{symbol}@trade") }

pub fn kline_stream(symbol: &str, interval: &str) -> String { format!("{symbol}@kline_{interval}") }

pub fn book_ticker_stream(symbol: &str) -> String { format!("{symbol}@bookTicker") }

pub fn all_book_ticker_stream() -> &'static str { "!bookTicker" }

pub fn all_mini_ticker_stream() -> &'static str { "!miniTicker@arr" }

pub fn mini_ticker_stream(symbol: &str) -> String { format!("{symbol}@miniTicker") }

/// # Arguments
///
/// * `symbol`: the market symbol
/// * `levels`: 5, 10 or 20
/// * `update_speed`: 1000 or 100
pub fn partial_book_depth_stream(symbol: &str, levels: u16, update_speed: u16) -> String {
    format!("{symbol}@depth{levels}@{update_speed}ms")
}

/// # Arguments
///
/// * `symbol`: the market symbol
/// * `update_speed`: 1000 or 100
pub fn diff_book_depth_stream(symbol: &str, update_speed: u16) -> String { format!("{symbol}@depth@{update_speed}ms") }

fn combined_stream(streams: Vec<String>) -> String { streams.join("/") }

pub struct WebSockets<'a, WE> {
    pub socket: Option<(WebSocketStream<MaybeTlsStream<TcpStream>>, Response)>,
    handler: Box<dyn FnMut(WE) -> Result<()> + 'a + Send>,
    conf: Config,
}

impl<'a, WE: serde::de::DeserializeOwned> WebSockets<'a, WE> {
    /// New websocket holder with default configuration
    /// # Examples
    /// see examples/binance_websockets.rs
    pub fn new<Callback>(handler: Callback) -> WebSockets<'a, WE>
    where
        Callback: FnMut(WE) -> Result<()> + 'a + Send,
    {
        Self::new_with_options(handler, Config::default())
    }

    /// New websocket holder with provided configuration
    /// # Examples
    /// see examples/binance_websockets.rs
    pub fn new_with_options<Callback>(handler: Callback, conf: Config) -> WebSockets<'a, WE>
    where
        Callback: FnMut(WE) -> Result<()> + 'a + Send,
    {
        WebSockets {
            socket: None,
            handler: Box::new(handler),
            conf,
        }
    }

    /// Connect to multiple websocket endpoints
    /// N.B: WE has to be CombinedStreamEvent
    pub async fn connect_multiple(&mut self, endpoints: Vec<String>) -> Result<()> {
        let mut url = Url::parse(&self.conf.futures_ws_endpoint)?;
        url.path_segments_mut()
            .map_err(|_| Error::UrlParserError(url::ParseError::RelativeUrlWithoutBase))?
            .push(STREAM_ENDPOINT);
        url.set_query(Some(&format!("streams={}", combined_stream(endpoints))));

        self.handle_connect(url).await
    }

    /// Connect to a websocket endpoint
    pub async fn connect(&mut self, endpoint: &str) -> Result<()> {
        let wss: String = format!("{}/{}/{}", self.conf.futures_ws_endpoint, WS_ENDPOINT, endpoint);
        let url = Url::parse(&wss)?;

        self.handle_connect(url).await
    }

    async fn handle_connect(&mut self, url: Url) -> Result<()> {
        match connect_async(url).await {
            Ok(answer) => {
                self.socket = Some(answer);
                Ok(())
            }
            Err(e) => Err(Error::Msg(format!("Error during handshake {e}"))),
        }
    }

    /// Disconnect from the endpoint
    pub async fn disconnect(&mut self) -> Result<()> {
        if let Some(ref mut socket) = self.socket {
            socket.0.close(None).await?;
            Ok(())
        } else {
            Err(Error::Msg("Not able to close the connection".to_string()))
        }
    }

    pub fn socket(&self) -> &Option<(WebSocketStream<MaybeTlsStream<TcpStream>>, Response)> { &self.socket }

    pub async fn event_loop(&mut self, running: &AtomicBool) -> Result<()> {
        while running.load(Ordering::Relaxed) {
            if let Some((ref mut socket, _)) = self.socket {
                // TODO: return error instead of panic?
                let message = socket.next().await.unwrap()?;

                match message {
                    Message::Text(msg) => {
                        if msg.is_empty() {
                            return Ok(());
                        }
                        let event: WE = from_str(msg.as_str())?;
                        (self.handler)(event)?;
                    }
                    Message::Ping(_) | Message::Pong(_) | Message::Binary(_) | Message::Frame(_) => {}
                    Message::Close(e) => {
                        return Err(Error::Msg(format!("Disconnected {e:?}")));
                    }
                }
            }
        }
        Ok(())
    }
}

</document_content>
</document>
<document index="34">
<source>src/futures/ws_model.rs</source>
<document_content>
use crate::futures::rest_model::{MarginType, OrderType, PositionSide, WorkingType};
use crate::rest_model::{string_or_float, string_or_float_opt, ExecutionType, OrderSide, OrderStatus, TimeInForce};

#[derive(Debug, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE", tag = "e")]
pub enum WebsocketEvent {
    AccountUpdate(Box<AccountUpdate>),
    OrderTradeUpdate(Box<OrderTradeUpdate>),
}

#[derive(Debug, Deserialize)]
pub struct AccountUpdate {
    #[serde(rename = "E")]
    pub event_time: u64,
    #[serde(rename = "T")]
    pub transaction_time: u64,
    #[serde(rename = "a")]
    pub account: Account,
}

#[derive(Debug, Deserialize)]
pub struct Account {
    #[serde(rename = "m")]
    pub reason_type: ReasonType,
    #[serde(rename = "B")]
    pub balances: Vec<Balance>,
    #[serde(rename = "P")]
    pub positions: Vec<Position>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ReasonType {
    Deposit,
    Withdraw,
    Order,
    FundingFee,
    WithdrawReject,
    Adjustment,
    InsuranceClear,
    AdminDeposit,
    AdminWithdraw,
    MarginTransfer,
    MarginTypeChange,
    AssetTransfer,
    OptionsPremiumFee,
    OptionsSettleProfit,
    AutoExchange,
    CoinSwapDeposit,
    CoinSwapWithdraw,
}

#[derive(Debug, Deserialize)]
pub struct Balance {
    #[serde(rename = "a")]
    pub asset: String,
    #[serde(rename = "wb", with = "string_or_float")]
    pub wallet_balance: f64,
    #[serde(rename = "cw", with = "string_or_float")]
    pub cross_wallet_balance: f64,
    #[serde(rename = "bc", with = "string_or_float")]
    pub balance_change: f64,
}

#[derive(Debug, Deserialize)]
pub struct Position {
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "pa", with = "string_or_float")]
    pub position_amount: f64,
    #[serde(rename = "ep", with = "string_or_float")]
    pub entry_price: f64,
    #[serde(rename = "bep", with = "string_or_float")]
    pub breakeven_price: f64,
    #[serde(rename = "cr", with = "string_or_float")]
    pub accumulated_realized: f64,
    #[serde(rename = "up", with = "string_or_float")]
    pub unrealized_profit: f64,
    #[serde(rename = "mt")]
    pub margin_type: MarginType,
    #[serde(rename = "iw", with = "string_or_float")]
    pub isolated_wallet: f64,
    #[serde(rename = "ps")]
    pub position_side: PositionSide,
}

#[derive(Clone, Debug, Deserialize)]
pub struct OrderTradeUpdate {
    #[serde(rename = "E")]
    pub event_time: u64,
    #[serde(rename = "T")]
    pub transaction_time: u64,
    #[serde(rename = "o")]
    pub order: Order,
}

#[derive(Clone, Debug, Deserialize)]
pub struct Order {
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "c")]
    pub client_order_id: String,
    #[serde(rename = "S")]
    pub side: OrderSide,
    #[serde(rename = "o")]
    pub order_type: OrderType,
    #[serde(rename = "f")]
    pub time_in_force: TimeInForce,
    #[serde(rename = "q", with = "string_or_float")]
    pub quantity: f64,
    #[serde(rename = "p", with = "string_or_float")]
    pub price: f64,
    #[serde(rename = "ap", with = "string_or_float")]
    pub average_price: f64,
    #[serde(rename = "sp", with = "string_or_float")]
    pub stop_price: f64,
    #[serde(rename = "x")]
    pub execution_type: ExecutionType,
    #[serde(rename = "X")]
    pub order_status: OrderStatus,
    #[serde(rename = "i")]
    pub order_id: u64,
    #[serde(rename = "l", with = "string_or_float")]
    pub order_last_filled_quantity: f64,
    #[serde(rename = "z", with = "string_or_float")]
    pub order_filled_accumulated_quantity: f64,
    #[serde(rename = "L", with = "string_or_float")]
    pub last_filled_price: f64,
    #[serde(default, rename = "n", with = "string_or_float_opt")]
    pub commission: Option<f64>,
    #[serde(rename = "N")]
    pub commission_asset: Option<String>,
    #[serde(rename = "T")]
    pub order_trade_time: u64,
    #[serde(rename = "t")]
    pub trade_id: u64,
    #[serde(rename = "b", with = "string_or_float")]
    pub bid_notional: f64,
    #[serde(rename = "a", with = "string_or_float")]
    pub ask_notional: f64,
    #[serde(rename = "m")]
    pub is_maker: bool,
    #[serde(rename = "R")]
    pub is_reduce: bool,
    #[serde(rename = "wt")]
    pub working_type: WorkingType,
    #[serde(rename = "ot")]
    pub original_order_type: OrderType,
    #[serde(rename = "ps")]
    pub position_side: PositionSide,
    #[serde(rename = "cp")]
    pub close_position: bool,
    #[serde(default, rename = "AP", with = "string_or_float_opt")]
    pub activation_price: Option<f64>,
    #[serde(default, rename = "cr", with = "string_or_float_opt")]
    pub callback_rate: Option<f64>,
    #[serde(rename = "pP")]
    pub price_protect: bool,
    #[serde(rename = "rp", with = "string_or_float")]
    pub realized_profit: f64,
    #[serde(rename = "V")]
    pub stp_mode: SelfTradePreventionMode,
    #[serde(rename = "pm")]
    pub price_match: PriceMatch,
    #[serde(rename = "gtd")]
    pub good_till_date: u64,
}

#[derive(Clone, Debug, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum PriceMatch {
    /// No price match
    None,
    /// Counterparty best price
    Opponent,
    /// The 5th best price from the counterparty
    Opponent5,
    /// The 10th best price from the counterparty
    Opponent10,
    /// The 20th best price from the counterparty
    Opponent20,
    /// The best price on the same side of the order book
    Queue,
    /// The 5th best price on the same side of the order book
    Queue5,
    /// The 10th best price on the same side of the order book
    Queue10,
    /// The 20th best price on the same side of the order book
    Queue20,
}

#[derive(Clone, Debug, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum SelfTradePreventionMode {
    /// No Self-Trade Prevention
    None,
    /// Expire taker order when STP trigger
    ExpireTaker,
    /// Expire taker and maker order when STP trigger
    ExpireBoth,
    /// Expire maker order when STP trigger
    ExpireMaker,
}

</document_content>
</document>
<document index="35">
<source>src/general.rs</source>
<document_content>
use serde_json::Value;

use crate::client::*;
use crate::errors::*;
use crate::rest_model::*;

#[derive(Clone)]
pub struct General {
    pub client: Client,
}

impl General {
    /// Test connectivity
    /// # Examples
    /// ```rust
    /// use binance::{api::*, general::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let general: General = Binance::new_with_env(&conf);
    /// let pong = tokio_test::block_on(general.ping());
    /// assert!(pong.is_ok(), "{:?}", pong);
    /// assert_eq!(pong.unwrap(), "pong");
    /// ```
    pub async fn ping(&self) -> Result<&'static str> {
        let _: Value = self.client.get("/api/v3/ping", None).await?;

        Ok("pong")
    }

    /// Check server time
    /// # Examples
    /// ```rust
    /// use binance::{api::*, general::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let general: General = Binance::new_with_env(&conf);
    /// let server_time = tokio_test::block_on(general.get_server_time());
    /// assert!(server_time.is_ok(), "{:?}", server_time);
    /// ```
    pub async fn get_server_time(&self) -> Result<ServerTime> { self.client.get("/api/v3/time", None).await }

    /// Obtain exchange information (rate limits, symbol metadata etc)
    /// # Examples
    /// ```rust
    /// use binance::{api::*, general::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let general: General = Binance::new_with_env(&conf);
    /// let exchange_info = tokio_test::block_on(general.exchange_info());
    /// assert!(exchange_info.is_ok(), "{:?}", exchange_info);
    /// ```
    pub async fn exchange_info(&self) -> Result<ExchangeInformation> {
        self.client.get("/api/v3/exchangeInfo", None).await
    }
}

</document_content>
</document>
<document index="36">
<source>src/lib.rs</source>
<document_content>
//! [![github]](https://github.com/Igosuki/binance-rs-async)&ensp;[![crates-io]](https://crates.io/Igosuki/binance-rs-async)&ensp;[![docs-rs]](https://docs.rs/binance-rs-async)
//!
//! [github]: https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github
//! [crates-io]: https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust
//! [docs-rs]: https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logoColor=white&logo=data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDUxMiA1MTIiPjxwYXRoIGZpbGw9IiNmNWY1ZjUiIGQ9Ik00ODguNiAyNTAuMkwzOTIgMjE0VjEwNS41YzAtMTUtOS4zLTI4LjQtMjMuNC0zMy43bC0xMDAtMzcuNWMtOC4xLTMuMS0xNy4xLTMuMS0yNS4zIDBsLTEwMCAzNy41Yy0xNC4xIDUuMy0yMy40IDE4LjctMjMuNCAzMy43VjIxNGwtOTYuNiAzNi4yQzkuMyAyNTUuNSAwIDI2OC45IDAgMjgzLjlWMzk0YzAgMTMuNiA3LjcgMjYuMSAxOS45IDMyLjJsMTAwIDUwYzEwLjEgNS4xIDIyLjEgNS4xIDMyLjIgMGwxMDMuOS01MiAxMDMuOSA1MmMxMC4xIDUuMSAyMi4xIDUuMSAzMi4yIDBsMTAwLTUwYzEyLjItNi4xIDE5LjktMTguNiAxOS45LTMyLjJWMjgzLjljMC0xNS05LjMtMjguNC0yMy40LTMzLjd6TTM1OCAyMTQuOGwtODUgMzEuOXYtNjguMmw4NS0zN3Y3My4zek0xNTQgMTA0LjFsMTAyLTM4LjIgMTAyIDM4LjJ2LjZsLTEwMiA0MS40LTEwMi00MS40di0uNnptODQgMjkxLjFsLTg1IDQyLjV2LTc5LjFsODUtMzguOHY3NS40em0wLTExMmwtMTAyIDQxLjQtMTAyLTQxLjR2LS42bDEwMi0zOC4yIDEwMiAzOC4ydi42em0yNDAgMTEybC04NSA0Mi41di03OS4xbDg1LTM4Ljh2NzUuNHptMC0xMTJsLTEwMiA0MS40LTEwMi00MS40di0uNmwxMDItMzguMiAxMDIgMzguMnYuNnoiPjwvcGF0aD48L3N2Zz4K
//!
//! <br>
//!
//! This library provides access to all of Binance's APIs using .
//! [`tokio`]: <https://docs.rs/tokio/latest/tokio/>
//!
//! <br>
//!
//! # Risk Warning
//!
//! It is a personal project, use at your own risk. I will not be responsible for your investment losses.
//! Cryptocurrency investment is subject to high market risk.
//! Nonetheless, this crate is aimed at high performance and production use.
//!
//! # Example
//!
//! This example simply pings the main binance api
//!
//! ```rust
//! # use std::io;
//! use binance::general::General;
//! use binance::api::Binance;
//! use binance::errors::Error as BinanceLibError;
//!
//! #[tokio::main]
//! async fn main() -> std::io::Result<()> {
//!     let general: General = Binance::new(None, None);
//!     let ping = general.ping().await;
//!     match ping {
//!         Ok(answer) => println!("{:?}", answer),
//!         Err(err) => {
//!             match err {
//!                 BinanceLibError::BinanceError { response } => match response.code {
//!                     -1000_i32 => println!("An unknown error occured while processing the request"),
//!                     _ => println!("Unknown code {}: {}", response.code, response.msg),
//!                 },
//!                 _ => println!("Other errors: {}.", err),
//!             };
//!         }
//!     }
//!     Ok(())
//! }
//! ```
//!
//! <br>
//!
//! # Details
//!
//! - Credentials are not enforced, you will get authentication errors if you don't provide
//! credentials and they are required by an endpoint
//!
//! - Error codes are handled on a best effort basis as some are inconsistent and not even
//! documented on Binance's side
//!
//! - Errors are implemented using [![thiserror]](https://docs.rs/thiserror/1.0.25/thiserror/)
//!

#![deny(unstable_features, unused_must_use, unused_mut, unused_imports, unused_import_braces)]

#[macro_use]
extern crate serde;
extern crate serde_qs as qs;

pub use util::bool_to_string;
pub use util::bool_to_string_some;

mod client;
pub mod errors;
pub mod util;

pub mod account;
pub mod api;
pub mod config;
#[cfg(feature = "futures_api")]
pub mod futures;
pub mod general;
#[cfg(feature = "margin_api")]
pub mod margin;
pub mod market;
pub mod rest_model;
#[cfg(feature = "savings_api")]
pub mod savings;
pub mod userstream;
#[cfg(feature = "wallet_api")]
pub mod wallet;
pub mod websockets;
pub mod ws_model;

</document_content>
</document>
<document index="37">
<source>src/market.rs</source>
<document_content>
use crate::client::*;
use crate::errors::*;
use crate::rest_model::*;
use crate::util::*;
use serde_json::Value;
// use std::collections::BTreeMap;

static API_V3_DEPTH: &str = "/api/v3/depth";
static API_V3_TICKER_PRICE: &str = "/api/v3/ticker/price";
static API_V3_AVG_PRICE: &str = "/api/v3/avgPrice";
static API_V3_BOOK_TICKER: &str = "/api/v3/ticker/bookTicker";
static API_V3_24H_TICKER: &str = "/api/v3/ticker/24hr";
static API_V3_AGG_TRADES: &str = "/api/v3/aggTrades";
static API_V3_KLINES: &str = "/api/v3/klines";

#[derive(Clone)]
pub struct Market {
    pub client: Client,
    pub recv_window: u64,
}

// Market Data endpoints
impl Market {
    fn symbol_request<S>(&self, symbol: S) -> String
    where
        S: AsRef<str>,
    {
        build_request([("symbol", symbol)])
    }

    /// Order book (Default 100; max 5000)
    /// # Examples
    /// ```rust
    /// use binance::{api::*, market::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let market: Market = Binance::new_with_env(&conf);
    /// let orderbook = tokio_test::block_on(market.get_depth("BTCUSDT".to_string()));
    /// assert!(orderbook.is_ok(), "{:?}", orderbook);
    /// ```
    pub async fn get_depth<S>(&self, symbol: S) -> Result<OrderBook>
    where
        S: AsRef<str>,
    {
        let request = self.symbol_request(symbol);
        self.client.get(API_V3_DEPTH, Some(&request)).await
    }

    /// Order book with a custom depth limit
    /// Supported limits are: 5, 10, 20, 50, 100, 500, 1000, 5000
    /// # Examples
    /// ```rust
    /// use binance::{api::*, market::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let market: Market = Binance::new_with_env(&conf);
    /// let orderbook = tokio_test::block_on(market.get_custom_depth("BTCUSDT".to_string(), 50));
    /// assert!(orderbook.is_ok(), "{:?}", orderbook);
    /// let bids_len = orderbook.unwrap().bids.len();
    /// assert_eq!(bids_len, 50);
    /// ```
    pub async fn get_custom_depth<S>(&self, symbol: S, limit: u16) -> Result<OrderBook>
    where
        S: AsRef<str>,
    {
        let parameters = [("symbol", symbol.as_ref().to_string()), ("limit", limit.to_string())];
        let request = build_request(parameters);
        self.client.get(API_V3_DEPTH, Some(&request)).await
    }

    /// Latest price for ALL symbols.
    /// # Examples
    /// ```rust
    /// use binance::{api::*, market::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let market: Market = Binance::new_with_env(&conf);
    /// let prices = tokio_test::block_on(market.get_all_prices());
    /// assert!(prices.is_ok(), "{:?}", prices);
    /// ```
    pub async fn get_all_prices(&self) -> Result<Prices> { self.client.get(API_V3_TICKER_PRICE, None).await }

    /// Latest price for ONE symbol.
    /// # Examples
    /// ```rust
    /// use binance::{api::*, market::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let market: Market = Binance::new_with_env(&conf);
    /// let price = tokio_test::block_on(market.get_price("BTCUSDT"));
    /// assert!(price.is_ok(), "{:?}", price);
    /// ```
    pub async fn get_price<S>(&self, symbol: S) -> Result<SymbolPrice>
    where
        S: AsRef<str>,
    {
        let request = self.symbol_request(symbol);
        self.client.get(API_V3_TICKER_PRICE, Some(&request)).await
    }

    /// Average price for ONE symbol.
    /// # Examples
    /// ```rust
    /// use binance::{api::*, market::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let market: Market = Binance::new_with_env(&conf);
    /// let avg_price = tokio_test::block_on(market.get_average_price("BTCUSDT"));
    /// assert!(avg_price.is_ok(), "{:?}", avg_price);
    /// ```
    pub async fn get_average_price<S>(&self, symbol: S) -> Result<AveragePrice>
    where
        S: AsRef<str>,
    {
        let request = self.symbol_request(symbol);
        self.client.get(API_V3_AVG_PRICE, Some(&request)).await
    }

    /// Symbols order book ticker
    /// -> Best price/qty on the order book for ALL symbols.
    /// # Examples
    /// ```rust
    /// use binance::{api::*, market::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let market: Market = Binance::new_with_env(&conf);
    /// let tickers = tokio_test::block_on(market.get_all_book_tickers());
    /// assert!(tickers.is_ok(), "{:?}", tickers);
    /// ```
    pub async fn get_all_book_tickers(&self) -> Result<BookTickers> { self.client.get(API_V3_BOOK_TICKER, None).await }

    /// -> Best price/qty on the order book for ONE symbol
    /// # Examples
    /// ```rust
    /// use binance::{api::*, market::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let market: Market = Binance::new_with_env(&conf);
    /// let tickers = tokio_test::block_on(market.get_book_ticker("BTCUSDT"));
    /// assert!(tickers.is_ok(), "{:?}", tickers);
    /// ```
    pub async fn get_book_ticker<S>(&self, symbol: S) -> Result<Tickers>
    where
        S: AsRef<str>,
    {
        let request = self.symbol_request(symbol);
        self.client.get(API_V3_BOOK_TICKER, Some(&request)).await
    }

    /// 24hr ticker price change statistics
    /// # Examples
    /// ```rust
    /// use binance::{api::*, market::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let market: Market = Binance::new_with_env(&conf);
    /// let price_stats = tokio_test::block_on(market.get_24h_price_stats("BTCUSDT"));
    /// assert!(price_stats.is_ok(), "{:?}", price_stats);
    /// ```
    pub async fn get_24h_price_stats<S>(&self, symbol: S) -> Result<PriceStats>
    where
        S: AsRef<str>,
    {
        let request = self.symbol_request(symbol);
        self.client.get(API_V3_24H_TICKER, Some(&request)).await
    }

    /// Get aggregated historical trades.
    /// If you provide start_time, you also need to provide end_time.
    /// If from_id, start_time and end_time are omitted, the most recent trades are fetched.
    /// # Examples
    /// ```rust
    /// use binance::{api::*, market::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let market: Market = Binance::new_with_env(&conf);
    /// let agg_trades = tokio_test::block_on(market.get_agg_trades("BNBETH", None, None, None, Some(10)));
    /// assert!(agg_trades.is_ok(), "{:?}", agg_trades);
    /// ```
    pub async fn get_agg_trades<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        from_id: S2,
        start_time: S3,
        end_time: S4,
        limit: S5,
    ) -> Result<Vec<AggTrade>>
    where
        S1: AsRef<str>,
        S2: Into<Option<u64>>,
        S3: Into<Option<u64>>,
        S4: Into<Option<u64>>,
        S5: Into<Option<u16>>,
    {
        let parameters = IntoIterator::into_iter([
            Some(("symbol", symbol.as_ref().to_string())),
            limit.into().map(|l| ("limit", l.to_string())),
            start_time.into().map(|s| ("startTime", s.to_string())),
            end_time.into().map(|e| ("endTime", e.to_string())),
            from_id.into().map(|f| ("fromId", f.to_string())),
        ])
        .flatten();

        let request = build_request(parameters);

        self.client.get_p(API_V3_AGG_TRADES, Some(&request)).await
    }

    /// Returns up to 'limit' klines for given symbol and interval ("1m", "5m", ...)
    /// <https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#klinecandlestick-data>
    /// # Examples
    /// ```rust
    /// use binance::{api::*, market::*, config::*};
    /// let conf = Config::default().set_rest_api_endpoint(DATA_REST_ENDPOINT);
    /// let market: Market = Binance::new_with_env(&conf);
    /// let klines = tokio_test::block_on(market.get_klines("BTCUSDT", "1m", None, None, None));
    /// assert!(klines.is_ok(), "{:?}", klines);
    /// ```
    pub async fn get_klines<S1, S2, S3, S4, S5>(
        &self,
        symbol: S1,
        interval: S2,
        limit: S3,
        start_time: S4,
        end_time: S5,
    ) -> Result<KlineSummaries>
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<Option<u16>>,
        S4: Into<Option<u64>>,
        S5: Into<Option<u64>>,
    {
        let parameters = IntoIterator::into_iter([
            Some(("symbol", symbol.into())),
            Some(("interval", interval.into())),
            limit.into().map(|l| ("limit", l.to_string())),
            start_time.into().map(|s| ("startTime", s.to_string())),
            end_time.into().map(|e| ("endTime", e.to_string())),
        ])
        .flatten();

        let request = build_request(parameters);

        let parsed_data: Vec<Vec<Value>> = self.client.get(API_V3_KLINES, Some(&request)).await?;

        let klines = KlineSummaries::AllKlineSummaries(
            parsed_data
                .iter()
                .map(|row| KlineSummary {
                    open_time: to_i64(&row[0]),
                    open: to_f64(&row[1]),
                    high: to_f64(&row[2]),
                    low: to_f64(&row[3]),
                    close: to_f64(&row[4]),
                    volume: to_f64(&row[5]),
                    close_time: to_i64(&row[6]),
                    quote_asset_volume: to_f64(&row[7]),
                    number_of_trades: to_i64(&row[8]),
                    taker_buy_base_asset_volume: to_f64(&row[9]),
                    taker_buy_quote_asset_volume: to_f64(&row[10]),
                })
                .collect(),
        );
        Ok(klines)
    }
}

</document_content>
</document>
<document index="38">
<source>src/savings.rs</source>
<document_content>
use crate::client::*;
use crate::errors::*;
use crate::rest_model::*;
use crate::util::*;
use std::collections::BTreeMap;

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct CoinInfo {
    pub coin: String,
    pub deposit_all_enable: bool,
    #[serde(with = "string_or_float")]
    pub free: f64,
    #[serde(with = "string_or_float")]
    pub freeze: f64,
    #[serde(with = "string_or_float")]
    pub ipoable: f64,
    #[serde(with = "string_or_float")]
    pub ipoing: f64,
    pub is_legal_money: bool,
    #[serde(with = "string_or_float")]
    pub locked: f64,
    pub name: String,
    pub network_list: Vec<Network>,
    #[serde(with = "string_or_float")]
    pub storage: f64,
    pub trading: bool,
    pub withdraw_all_enable: bool,
    #[serde(with = "string_or_float")]
    pub withdrawing: f64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Network {
    pub address_regex: String,
    pub coin: String,
    /// shown only when "depositEnable" is false.
    pub deposit_desc: Option<String>,
    pub deposit_enable: bool,
    pub is_default: bool,
    pub memo_regex: String,
    /// min number for balance confirmation
    pub min_confirm: u32,
    pub name: String,
    pub network: String,
    pub reset_address_status: bool,
    pub special_tips: Option<String>,
    /// confirmation number for balance unlock
    pub un_lock_confirm: u32,
    /// shown only when "withdrawEnable" is false.
    pub withdraw_desc: Option<String>,
    pub withdraw_enable: bool,
    #[serde(with = "string_or_float")]
    pub withdraw_fee: f64,
    #[serde(with = "string_or_float")]
    pub withdraw_min: f64,
    // pub insert_time: Option<u64>, //commented out for now, because they are not inside the actual response (only the api doc example)
    // pub update_time: Option<u64>,
    pub withdraw_integer_multiple: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AssetDetail {
    #[serde(with = "string_or_float")]
    pub min_withdraw_amount: f64,
    /// false if ALL of networks' are false
    pub deposit_status: bool,
    #[serde(with = "string_or_float")]
    pub withdraw_fee: f64,
    /// false if ALL of networks' are false
    pub withdraw_status: bool,
    /// reason
    pub deposit_tip: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DepositAddress {
    pub address: String,
    pub coin: String,
    pub tag: String,
    pub url: String,
}

#[derive(Clone)]
pub struct Savings {
    pub client: Client,
    pub recv_window: u64,
}

impl Savings {
    /// Get all coins available for deposit and withdrawal
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, savings::*, config::*};
    /// let savings: Savings = Binance::new_with_env(&Config::testnet());
    /// let coins = tokio_test::block_on(savings.get_all_coins());
    /// assert!(coins.is_ok(), "{:?}", coins)
    /// ```
    pub async fn get_all_coins(&self) -> Result<Vec<CoinInfo>> {
        let request = build_signed_request([("", "")], self.recv_window)?;
        self.client
            .get_signed_d("/sapi/v1/capital/config/getall", request.as_str())
            .await
    }

    /// Fetch details of assets supported on Binance.
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, savings::*, config::*};
    /// let savings: Savings = Binance::new_with_env(&Config::testnet());
    /// let coins = tokio_test::block_on(savings.asset_detail(Some("CTR")));
    /// assert!(coins.is_ok(), "{:?}", coins)
    /// ```
    pub async fn asset_detail(&self, asset: Option<&str>) -> Result<BTreeMap<String, AssetDetail>> {
        let parameters = if let Some(asset) = asset {
            [("asset", asset)]
        } else {
            [("", "")]
        };

        let request = build_signed_request(parameters, self.recv_window)?;
        self.client
            .get_signed_d("/sapi/v1/asset/assetDetail", request.as_str())
            .await
    }

    /// Fetch deposit address with network.
    ///
    /// You can get the available networks using `get_all_coins`.
    /// If no network is specified, the address for the default network is returned.
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, savings::*, config::*};
    /// let savings: Savings = Binance::new_with_env(&Config::testnet());
    /// let coins = tokio_test::block_on(savings.deposit_address("CTR", None));
    /// assert!(coins.is_ok(), "{:?}", coins)
    /// ```
    pub async fn deposit_address<S>(&self, coin: S, network: Option<&str>) -> Result<DepositAddress>
    where
        S: AsRef<str>,
    {
        let request = if let Some(network) = network {
            let parameters = [("network", network), ("coin", coin.as_ref())];
            build_signed_request(parameters, self.recv_window)?
        } else {
            let parameters = [("coin", coin.as_ref())];
            build_signed_request(parameters, self.recv_window)?
        };

        self.client
            .get_signed_d("/sapi/v1/capital/deposit/address", request.as_str())
            .await
    }
}

</document_content>
</document>
<document index="39">
<source>src/userstream.rs</source>
<document_content>
use crate::client::*;
use crate::errors::*;
use crate::rest_model::*;

static USER_DATA_STREAM: &str = "/api/v3/userDataStream";

#[derive(Clone)]
pub struct UserStream {
    pub client: Client,
    pub recv_window: u64,
}

impl UserStream {
    /// Get a listen key for the stream
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, userstream::*, config::*};
    /// let userstream: UserStream = Binance::new_with_env(&Config::testnet());
    /// let start = tokio_test::block_on(userstream.start());
    /// assert!(start.is_ok(), "{:?}", start);
    /// assert!(start.unwrap().listen_key.len() > 0)
    /// ```
    pub async fn start(&self) -> Result<UserDataStream> { self.client.post(USER_DATA_STREAM, None).await }

    /// Keep the connection alive, as the listen key becomes invalid after 60mn
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, userstream::*, config::*};
    /// let userstream: UserStream = Binance::new_with_env(&Config::testnet());
    /// let start = tokio_test::block_on(userstream.start());
    /// assert!(start.is_ok(), "{:?}", start);
    /// let keep_alive = tokio_test::block_on(userstream.keep_alive(&start.unwrap().listen_key));
    /// assert!(keep_alive.is_ok())
    /// ```
    pub async fn keep_alive(&self, listen_key: &str) -> Result<Success> {
        self.client.put(USER_DATA_STREAM, listen_key, None).await
    }

    /// Invalidate the listen key
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, userstream::*, config::*};
    /// let userstream: UserStream = Binance::new_with_env(&Config::testnet());
    /// let start = tokio_test::block_on(userstream.start());
    /// assert!(start.is_ok(), "{:?}", start);
    /// let close = tokio_test::block_on(userstream.close(&start.unwrap().listen_key));
    /// assert!(close.is_ok())
    /// ```
    pub async fn close(&self, listen_key: &str) -> Result<Success> {
        self.client.delete(USER_DATA_STREAM, listen_key, None).await
    }
}

</document_content>
</document>
<document index="40">
<source>src/util.rs</source>
<document_content>
use std::ops::Not;

use chrono::{Duration, Utc};
use serde_json::Value;

use crate::errors::*;

// pub fn build_request(parameters: &BTreeMap<String, String>) -> String {
pub fn build_request(parameters: impl IntoIterator<Item = (impl AsRef<str>, impl AsRef<str>)>) -> String {
    parameters
        .into_iter()
        .map(|(k, v)| format!("{}={}", k.as_ref(), v.as_ref()))
        .collect::<Vec<_>>()
        .join("&")
}

pub fn build_request_p<S>(payload: S) -> Result<String>
where
    S: serde::Serialize,
{
    Ok(qs::to_string(&payload)?)
}

pub fn build_signed_request(
    parameters: impl IntoIterator<Item = (impl AsRef<str>, impl AsRef<str>)>,
    recv_window: u64,
) -> Result<String> {
    let s = IntoIterator::into_iter([
        // Include recvWindow if window > 0
        if recv_window > 0 {
            Some(("recvWindow", recv_window))
        } else {
            None
        },
        // Always include timestamp
        Some(("timestamp", get_timestamp()?)),
    ])
    .flatten()
    .map(|(k, v)| format!("{k}={v}"))
    .chain(
        parameters
            .into_iter()
            .filter(|(k, _)| k.as_ref().is_empty().not())
            .map(|(k, v)| format!("{}={}", k.as_ref(), v.as_ref())),
    )
    .collect::<Vec<String>>()
    .join("&");

    Ok(s)
}

pub fn build_signed_request_p<S>(payload: S, recv_window: u64) -> Result<String>
where
    S: serde::Serialize,
{
    let query_string = qs::to_string(&payload)?;

    let s = IntoIterator::into_iter([
        // Include recvWindow if window > 0
        if recv_window > 0 {
            Some(("recvWindow", recv_window))
        } else {
            None
        },
        // Always include timestamp
        Some(("timestamp", get_timestamp()?)),
    ])
    .flatten()
    .map(|(k, v)| format!("{k}={v}"))
    .collect::<Vec<String>>()
    .join("&");

    let request = if query_string.is_empty() {
        s
    } else {
        format!("{s}&{query_string}")
    };
    Ok(request)
}

pub fn to_i64(v: &Value) -> i64 {
    // TODO: should this return result?
    v.as_i64().unwrap()
}

pub fn to_f64(v: &Value) -> f64 {
    // TODO: should this return result?
    v.as_str().unwrap().parse().unwrap()
}

pub fn get_timestamp() -> Result<u64> { Ok(Utc::now().timestamp_millis() as u64) }

/// Returns a duration in milliseconds for the `days`
pub fn days_millis(days: i64) -> i64 { Duration::days(days).num_milliseconds() }

const TRUE: &str = "TRUE";
const FALSE: &str = "FALSE";

pub fn bool_to_string(b: bool) -> String {
    if b {
        TRUE.to_string()
    } else {
        FALSE.to_string()
    }
}

pub fn bool_to_string_some(b: bool) -> Option<String> { Some(bool_to_string(b)) }

</document_content>
</document>
<document index="41">
<source>src/wallet.rs</source>
<document_content>
use crate::client::*;
use crate::errors::*;
use crate::rest_model::*;
use chrono::DateTime;
use chrono::{Duration, Utc};
use std::collections::HashMap;
use std::ops::Sub;

static SAPI_V1_SYSTEM_STATUS: &str = "/sapi/v1/system/status";
static SAPI_V1_CAPITAL_CONFIG_GETALL: &str = "/sapi/v1/capital/config/getall";
static SAPI_V1_ACCOUNTSNAPSHOT: &str = "/sapi/v1/accountSnapshot";
static SAPI_V1_ACCOUNT_DISABLEFASTWITHDRAWSWITCH: &str = "/sapi/v1/account/disableFastWithdrawSwitch";
static SAPI_V1_ACCOUNT_ENABLEFASTWITHDRAWSWITCH: &str = "/sapi/v1/account/enableFastWithdrawSwitch";
static SAPI_V1_CAPITAL_WITHDRAW_APPLY: &str = "/sapi/v1/capital/withdraw/apply";
static SAPI_V1_CAPITAL_DEPOSIT_HISREC: &str = "/sapi/v1/capital/deposit/hisrec";
static SAPI_V1_CAPITAL_WITHDRAW_HISTORY: &str = "/sapi/v1/capital/withdraw/history";
static SAPI_V1_CAPITAL_DEPOSIT_ADDRESS: &str = "/sapi/v1/capital/deposit/address";
static SAPI_V1_ACCOUNT_STATUS: &str = "/sapi/v1/account/status";
static SAPI_V1_ACCOUNT_APITRADINGSTATUS: &str = "/sapi/v1/account/apiTradingStatus";
static SAPI_V1_ASSET_DRIBBLET: &str = "/sapi/v1/asset/dribblet";
static SAPI_V1_ASSET_DUSTBTC: &str = "/sapi/v1/asset/dust-btc";
static SAPI_V1_ASSET_DUST: &str = "/sapi/v1/asset/dust";
static SAPI_V1_ASSET_ASSETDIVIDEND: &str = "/sapi/v1/asset/assetDividend";
static SAPI_V1_ASSET_ASSETDETAIL: &str = "/sapi/v1/asset/assetDetail";
static SAPI_V1_ASSET_TRADEFEE: &str = "/sapi/v1/asset/tradeFee";
static SAPI_V1_ASSET_TRADEFEE_US: &str = "/sapi/v1/asset/query/trading-fee";
static SAPI_V1_ASSET_TRANSFER: &str = "/sapi/v1/asset/transfer";
static SAPI_V1_ASSET_GETFUNDINGASSET: &str = "/sapi/v1/asset/get-funding-asset";
static SAPI_V1_ASSET_APIRESTRICTIONS: &str = "/sapi/v1/account/apiRestrictions";
static SAPI_V1_ASSET_WALLET_BALANCE: &str = "/sapi/v1/asset/wallet/balance";
static DEFAULT_WALLET_HISTORY_QUERY_INTERVAL_DAYS: i64 = 90;

/// This struct acts as a gateway for all wallet endpoints.
/// Preferably use the trait [`crate::api::Binance`] to get an instance.
#[derive(Clone)]
pub struct Wallet {
    pub client: Client,
    pub recv_window: u64,
    pub binance_us_api: bool,
}

impl Wallet {
    /// Fetch system status.
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let system_status = tokio_test::block_on(wallet.system_status());
    /// assert!(system_status.is_ok(), "{:?}", system_status);
    /// ```
    pub async fn system_status(&self) -> Result<SystemStatus> { self.client.get_p(SAPI_V1_SYSTEM_STATUS, None).await }

    /// Get information of coins (available for deposit and withdraw) for user.
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.all_coin_info());
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn all_coin_info(&self) -> Result<Vec<WalletCoinInfo>> {
        self.client
            .get_signed_p(SAPI_V1_CAPITAL_CONFIG_GETALL, Option::<String>::None, self.recv_window)
            .await
    }

    /// Daily account snapshot
    /// The query time period must be less then 30 days
    /// Support query within the last one month only
    /// If startTime and endTime not sent, return records of the last 7 days by default
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let query: AccountSnapshotQuery = AccountSnapshotQuery {start_time: None, end_time: None, limit: None, account_type: AccountSnapshotType::Spot};
    /// let records = tokio_test::block_on(wallet.daily_account_snapshot(query));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn daily_account_snapshot(&self, query: AccountSnapshotQuery) -> Result<AccountSnapshot> {
        self.client
            .get_signed_p(SAPI_V1_ACCOUNTSNAPSHOT, Some(query), self.recv_window)
            .await
    }

    /// Disable Fast Withdraw Switch
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.disable_fast_withdraw_switch());
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn disable_fast_withdraw_switch(&self) -> Result<()> {
        self.client
            .post_signed_p(
                SAPI_V1_ACCOUNT_DISABLEFASTWITHDRAWSWITCH,
                Option::<String>::None,
                self.recv_window,
            )
            .await
    }

    /// Enable Fast Withdraw Switch
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.enable_fast_withdraw_switch());
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn enable_fast_withdraw_switch(&self) -> Result<()> {
        self.client
            .post_signed_p(
                SAPI_V1_ACCOUNT_ENABLEFASTWITHDRAWSWITCH,
                Option::<String>::None,
                self.recv_window,
            )
            .await
    }

    /// Apply for Withdrawal
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let query: CoinWithdrawalQuery = CoinWithdrawalQuery::default();
    /// let records = tokio_test::block_on(wallet.withdraw(query));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn withdraw(&self, query: CoinWithdrawalQuery) -> Result<()> {
        self.client
            .post_signed_p(SAPI_V1_CAPITAL_WITHDRAW_APPLY, Some(query), self.recv_window)
            .await
    }

    /// Deposit History
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let query: DepositHistoryQuery = DepositHistoryQuery::default();
    /// let records = tokio_test::block_on(wallet.deposit_history(&query));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn deposit_history(&self, query: &DepositHistoryQuery) -> Result<Vec<DepositRecord>> {
        self.client
            .get_signed_p(SAPI_V1_CAPITAL_DEPOSIT_HISREC, Some(query), self.recv_window)
            .await
    }

    /// Withdraw History starting at start_from (defaults to now), ranging total_duration (defaults to 90 days), with intervals of 90 days.
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let query: DepositHistoryQuery = DepositHistoryQuery::default();
    /// let records = tokio_test::block_on(wallet.deposit_history_quick(query, None, None));
    /// assert!(records.is_ok(), "{:?}", records);
    pub async fn deposit_history_quick(
        &self,
        mut query: DepositHistoryQuery,
        start_from: Option<DateTime<Utc>>,
        total_duration: Option<Duration>,
    ) -> Result<Vec<RecordHistory<DepositRecord>>> {
        let mut result = vec![];

        let total_duration =
            total_duration.unwrap_or_else(|| Duration::days(DEFAULT_WALLET_HISTORY_QUERY_INTERVAL_DAYS));
        let interval_duration = Duration::days(DEFAULT_WALLET_HISTORY_QUERY_INTERVAL_DAYS);
        let mut current_period_end: DateTime<Utc> = start_from.unwrap_or_else(Utc::now);
        let end_at = current_period_end.sub(total_duration);
        let mut current_period_start: DateTime<Utc> = current_period_end.sub(interval_duration);

        // auto query by step:
        while current_period_end > end_at {
            // modify query duration:
            query.start_time = Some(current_period_start.timestamp_millis() as u64);
            query.end_time = Some(current_period_end.timestamp_millis() as u64);

            // eprintln!("query: {:?}", query);
            let records = self.deposit_history(&query).await?;

            if !records.is_empty() {
                let item = RecordHistory::<DepositRecord> {
                    start_at: current_period_start,
                    end_at: current_period_end,
                    records,
                };
                result.push(item);
            }

            current_period_start = current_period_start.sub(interval_duration);
            current_period_end = current_period_end.sub(interval_duration);
        }

        Ok(result)
    }

    /// Withdraw History
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let query: WithdrawalHistoryQuery = WithdrawalHistoryQuery::default();
    /// let records = tokio_test::block_on(wallet.withdraw_history(&query));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn withdraw_history(&self, query: &WithdrawalHistoryQuery) -> Result<Vec<WithdrawalRecord>> {
        self.client
            .get_signed_p(SAPI_V1_CAPITAL_WITHDRAW_HISTORY, Some(query), self.recv_window)
            .await
    }

    /// Withdraw History starting at start_from (defaults to now), ranging total_duration (defaults to 90 days), with intervals of 90 days.
    ///
    /// # Examples
    /// ```rust,no_run
    /// use chrono::Duration;
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let query: WithdrawalHistoryQuery = WithdrawalHistoryQuery::default();
    /// let records = tokio_test::block_on(wallet.withdraw_history_quick(query, None, Some(Duration::weeks( 52 * 5))));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn withdraw_history_quick(
        &self,
        mut query: WithdrawalHistoryQuery,
        start_from: Option<DateTime<Utc>>,
        total_duration: Option<Duration>,
    ) -> Result<Vec<RecordHistory<WithdrawalRecord>>> {
        let mut result = vec![];

        let total_duration =
            total_duration.unwrap_or_else(|| Duration::days(DEFAULT_WALLET_HISTORY_QUERY_INTERVAL_DAYS));
        let interval_duration = Duration::days(DEFAULT_WALLET_HISTORY_QUERY_INTERVAL_DAYS);
        let mut current_period_end: DateTime<Utc> = start_from.unwrap_or_else(Utc::now);
        let end_at = current_period_end.sub(total_duration);
        let mut current_period_start: DateTime<Utc> = current_period_end.sub(interval_duration);

        // auto query by step:
        while current_period_end > end_at {
            query.start_time = Some(current_period_start.timestamp_millis() as u64);
            query.end_time = Some(current_period_end.timestamp_millis() as u64);

            let records = self.withdraw_history(&query).await?;

            if !records.is_empty() {
                let item = RecordHistory::<WithdrawalRecord> {
                    start_at: current_period_start,
                    end_at: current_period_end,
                    records,
                };
                result.push(item);
            }

            current_period_start = current_period_start.sub(interval_duration);
            current_period_end = current_period_end.sub(interval_duration);
        }

        Ok(result)
    }

    /// Deposit address
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let query: DepositAddressQuery = DepositAddressQuery::default();
    /// let records = tokio_test::block_on(wallet.deposit_address(query));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn deposit_address(&self, query: DepositAddressQuery) -> Result<DepositAddress> {
        self.client
            .get_signed_p(SAPI_V1_CAPITAL_DEPOSIT_ADDRESS, Some(query), self.recv_window)
            .await
    }

    /// Universal Transfer
    ///
    /// from_symbol must be sent when transfer_type are IsolatedmarginMargin and IsolatedmarginIsolatedmargin
    /// to_symbol must be sent when transfer_type are MarginIsolatedmargin and IsolatedmarginIsolatedmargin
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.universal_transfer("BTC".to_string(), 1.0, None, None, UniversalTransferType::FundingMain));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn universal_transfer(
        &self,
        asset: String,
        amount: f64,
        from_symbol: Option<String>,
        to_symbol: Option<String>,
        transfer_type: UniversalTransferType,
    ) -> Result<TransactionId> {
        let transfer = UniversalTransfer {
            asset,
            amount,
            from_symbol: from_symbol.map(Into::<String>::into),
            to_symbol: to_symbol.map(Into::<String>::into),
            transfer_type,
        };
        self.client
            .post_signed_p(SAPI_V1_ASSET_TRANSFER, transfer, self.recv_window)
            .await
    }

    /// Universal Transfer
    ///
    /// from_symbol must be sent when transfer_type are IsolatedmarginMargin and IsolatedmarginIsolatedmargin
    /// to_symbol must be sent when transfer_type are MarginIsolatedmargin and IsolatedmarginIsolatedmargin
    /// Support query within the last 6 months only
    /// If query.start_time and query.end_time not sent, return records of the last 7 days by default
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let query: UniversalTransferHistoryQuery = UniversalTransferHistoryQuery { start_time: None, end_time: None, transfer_type: UniversalTransferType::FundingMain, current: None, from_symbol: None, to_symbol: None, size: None };
    /// let records = tokio_test::block_on(wallet.universal_transfer_history(query));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn universal_transfer_history(
        &self,
        query: UniversalTransferHistoryQuery,
    ) -> Result<RecordsQueryResult<UniversalTransferRecord>> {
        self.client
            .get_signed_p(SAPI_V1_ASSET_TRANSFER, Some(query), self.recv_window)
            .await
    }

    /// Current account status
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.account_status());
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn account_status(&self) -> Result<AccountStatus> {
        self.client
            .get_signed_p(SAPI_V1_ACCOUNT_STATUS, Option::<String>::None, self.recv_window)
            .await
    }

    /// Current api trading status
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.api_trading_status());
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn api_trading_status(&self) -> Result<ApiTradingStatus> {
        self.client
            .get_signed_p(
                SAPI_V1_ACCOUNT_APITRADINGSTATUS,
                Option::<String>::None,
                self.recv_window,
            )
            .await
    }

    /// Dust Log
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.dust_log(None, None));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn dust_log(&self, start_time: Option<u64>, end_time: Option<u64>) -> Result<DustLog> {
        let mut query = HashMap::new();
        query.insert("start_time", start_time);
        query.insert("end_time", end_time);
        self.client
            .get_signed_p(SAPI_V1_ASSET_DRIBBLET, Some(query), self.recv_window)
            .await
    }

    /// Assets convertible to BNB
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.convertible_assets());
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn convertible_assets(&self) -> Result<ConvertibleAssets> {
        self.client
            .post_signed_p(SAPI_V1_ASSET_DUSTBTC, Option::<String>::None, self.recv_window)
            .await
    }

    /// Dust Transfer
    ///
    /// Convert dust assets to bnb
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.dust_transfer(vec!["BTC".to_string()]));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn dust_transfer(&self, assets: Vec<String>) -> Result<DustTransfer> {
        let mut params = HashMap::new();
        params.insert("assets", assets);
        self.client
            .post_signed_p(SAPI_V1_ASSET_DUST, Some(params), self.recv_window)
            .await
    }

    /// Asset Dividend Record
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.asset_dividends(AssetDividendQuery::default()));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn asset_dividends(&self, query: AssetDividendQuery) -> Result<RecordsQueryResult<AssetDividend>> {
        self.client
            .get_signed_p(SAPI_V1_ASSET_ASSETDIVIDEND, Some(query), self.recv_window)
            .await
    }

    /// Asset Details
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.asset_detail(None));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn asset_detail(&self, asset: Option<String>) -> Result<SupportedAssetDetails> {
        self.client
            .get_signed_p(SAPI_V1_ASSET_ASSETDETAIL, asset, self.recv_window)
            .await
    }

    /// Trade Fees
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.trade_fees(None));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn trade_fees(&self, symbol: Option<String>) -> Result<TradeFees> {
        let mut query = HashMap::new();
        query.insert("symbol", symbol);
        self.client
            .get_signed_p(
                if self.binance_us_api {
                    SAPI_V1_ASSET_TRADEFEE_US
                } else {
                    SAPI_V1_ASSET_TRADEFEE
                },
                Some(query),
                self.recv_window,
            )
            .await
    }

    /// Funding Wallet
    ///
    /// Currently supports querying the following business assetsÔºöBinance Pay, Binance Card, Binance Gift Card, Stock Token
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.funding_wallet(None, None));
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn funding_wallet(
        &self,
        asset: Option<String>,
        need_btc_valuation: Option<bool>,
    ) -> Result<WalletFundings> {
        let mut query = HashMap::new();
        query.insert("asset", asset);
        query.insert("need_btc_valuation", need_btc_valuation.map(|b| format!("{b}")));
        self.client
            .post_signed_p(SAPI_V1_ASSET_GETFUNDINGASSET, Some(query), self.recv_window)
            .await
    }

    /// Api Key Permissions
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.api_key_permissions());
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn api_key_permissions(&self) -> Result<ApiKeyPermissions> {
        self.client
            .get_signed_p(SAPI_V1_ASSET_APIRESTRICTIONS, Option::<String>::None, self.recv_window)
            .await
    }

    /// Wallet
    ///
    /// # Examples
    /// ```rust,no_run
    /// use binance::{api::*, wallet::*, config::*, rest_model::*};
    /// let wallet: Wallet = Binance::new_with_env(&Config::testnet());
    /// let records = tokio_test::block_on(wallet.wallet_balance());
    /// assert!(records.is_ok(), "{:?}", records);
    /// ```
    pub async fn wallet_balance(&self) -> Result<WalletBalances> {
        self.client
            .get_signed_p(SAPI_V1_ASSET_WALLET_BALANCE, Option::<String>::None, self.recv_window)
            .await
    }
}

</document_content>
</document>
<document index="42">
<source>src/websockets.rs</source>
<document_content>
use std::sync::atomic::{AtomicBool, Ordering};

use futures::StreamExt;
use serde_json::from_str;
use tokio::net::TcpStream;
use tokio_tungstenite::tungstenite::handshake::client::Response;
use tokio_tungstenite::tungstenite::Message;
use tokio_tungstenite::WebSocketStream;
use tokio_tungstenite::{connect_async, MaybeTlsStream};
use url::Url;

use crate::config::Config;
use crate::errors::*;

pub static STREAM_ENDPOINT: &str = "stream";
pub static WS_ENDPOINT: &str = "ws";
pub static OUTBOUND_ACCOUNT_INFO: &str = "outboundAccountInfo";
pub static OUTBOUND_ACCOUNT_POSITION: &str = "outboundAccountPosition";
pub static EXECUTION_REPORT: &str = "executionReport";
pub static KLINE: &str = "kline";
pub static AGGREGATED_TRADE: &str = "aggTrade";
pub static DEPTH_ORDERBOOK: &str = "depthUpdate";
pub static PARTIAL_ORDERBOOK: &str = "lastUpdateId";
pub static DAYTICKER: &str = "24hrTicker";
pub static MARK_PRICE: &str = "markPrice";

pub fn all_ticker_stream() -> &'static str { "!ticker@arr" }

pub fn ticker_stream(symbol: &str) -> String { format!("{symbol}@ticker") }

pub fn agg_trade_stream(symbol: &str) -> String { format!("{symbol}@aggTrade") }

pub fn trade_stream(symbol: &str) -> String { format!("{symbol}@trade") }

pub fn kline_stream(symbol: &str, interval: &str) -> String { format!("{symbol}@kline_{interval}") }

pub fn book_ticker_stream(symbol: &str) -> String { format!("{symbol}@bookTicker") }

pub fn all_book_ticker_stream() -> &'static str { "!bookTicker" }

pub fn all_mini_ticker_stream() -> &'static str { "!miniTicker@arr" }

pub fn mini_ticker_stream(symbol: &str) -> String { format!("{symbol}@miniTicker") }

/// # Arguments
///
/// * `symbol`: the market symbol
/// * `update_speed`: 1 or 3
pub fn mark_price_stream(symbol: &str, update_speed: u8) -> String { format!("{symbol}@markPrice@{update_speed}s") }

/// # Arguments
///
/// * `symbol`: the market symbol
/// * `levels`: 5, 10 or 20
/// * `update_speed`: 1000 or 100
pub fn partial_book_depth_stream(symbol: &str, levels: u16, update_speed: u16) -> String {
    format!("{symbol}@depth{levels}@{update_speed}ms")
}

/// # Arguments
///
/// * `symbol`: the market symbol
/// * `update_speed`: 1000 or 100
pub fn diff_book_depth_stream(symbol: &str, update_speed: u16) -> String { format!("{symbol}@depth@{update_speed}ms") }

fn combined_stream(streams: Vec<String>) -> String { streams.join("/") }

pub struct WebSockets<'a, WE> {
    pub socket: Option<(WebSocketStream<MaybeTlsStream<TcpStream>>, Response)>,
    handler: Box<dyn FnMut(WE) -> Result<()> + 'a + Send>,
    conf: Config,
}

impl<'a, WE: serde::de::DeserializeOwned> WebSockets<'a, WE> {
    /// New websocket holder with default configuration
    /// # Examples
    /// see examples/binance_websockets.rs
    pub fn new<Callback>(handler: Callback) -> WebSockets<'a, WE>
    where
        Callback: FnMut(WE) -> Result<()> + 'a + Send,
    {
        Self::new_with_options(handler, Config::default())
    }

    /// New websocket holder with provided configuration
    /// # Examples
    /// see examples/binance_websockets.rs
    pub fn new_with_options<Callback>(handler: Callback, conf: Config) -> WebSockets<'a, WE>
    where
        Callback: FnMut(WE) -> Result<()> + 'a + Send,
    {
        WebSockets {
            socket: None,
            handler: Box::new(handler),
            conf,
        }
    }

    /// Connect to multiple websocket endpoints
    /// N.B: WE has to be CombinedStreamEvent
    pub async fn connect_multiple(&mut self, endpoints: Vec<String>) -> Result<()> {
        let mut url = Url::parse(&self.conf.ws_endpoint)?;
        url.path_segments_mut()
            .map_err(|_| Error::UrlParserError(url::ParseError::RelativeUrlWithoutBase))?
            .push(STREAM_ENDPOINT);
        url.set_query(Some(&format!("streams={}", combined_stream(endpoints))));

        self.handle_connect(url).await
    }

    /// Connect to a websocket endpoint
    pub async fn connect(&mut self, endpoint: &str) -> Result<()> {
        let wss: String = format!("{}/{}/{}", self.conf.ws_endpoint, WS_ENDPOINT, endpoint);
        let url = Url::parse(&wss)?;

        self.handle_connect(url).await
    }

    /// Connect to a futures websocket endpoint
    pub async fn connect_futures(&mut self, endpoint: &str) -> Result<()> {
        let wss: String = format!("{}/{}/{}", self.conf.futures_ws_endpoint, WS_ENDPOINT, endpoint);
        let url = Url::parse(&wss)?;

        self.handle_connect(url).await
    }

    async fn handle_connect(&mut self, url: Url) -> Result<()> {
        match connect_async(url).await {
            Ok(answer) => {
                self.socket = Some(answer);
                Ok(())
            }
            Err(e) => Err(Error::Msg(format!("Error during handshake {e}"))),
        }
    }

    /// Disconnect from the endpoint
    pub async fn disconnect(&mut self) -> Result<()> {
        if let Some(ref mut socket) = self.socket {
            socket.0.close(None).await?;
            Ok(())
        } else {
            Err(Error::Msg("Not able to close the connection".to_string()))
        }
    }

    pub fn socket(&self) -> &Option<(WebSocketStream<MaybeTlsStream<TcpStream>>, Response)> { &self.socket }

    pub async fn event_loop(&mut self, running: &AtomicBool) -> Result<()> {
        while running.load(Ordering::Relaxed) {
            if let Some((ref mut socket, _)) = self.socket {
                // TODO: return error instead of panic?
                let message = socket.next().await.unwrap()?;

                match message {
                    Message::Text(msg) => {
                        if msg.is_empty() {
                            return Ok(());
                        }
                        let event: WE = from_str(msg.as_str())?;
                        (self.handler)(event)?;
                    }
                    Message::Ping(_) | Message::Pong(_) | Message::Binary(_) | Message::Frame(_) => {}
                    Message::Close(e) => {
                        return Err(Error::Msg(format!("Disconnected {e:?}")));
                    }
                }
            }
        }
        Ok(())
    }
}

</document_content>
</document>
<document index="43">
<source>src/ws_model.rs</source>
<document_content>
use crate::rest_model::{string_or_float, Asks, Bids, ExecutionType, OrderBook, OrderSide, OrderStatus, OrderType,
                        TimeInForce};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "e")]
pub enum WebsocketEvent {
    #[serde(alias = "aggTrade")]
    AggTrade(Box<TradesEvent>),
    #[serde(alias = "trade")]
    Trade(Box<TradeEvent>),
    #[serde(alias = "kline")]
    Kline(Box<KlineEvent>),
    #[serde(alias = "24hrTicker")]
    DayTicker(Box<DayTickerEvent>),
    #[serde(alias = "24hrMiniTicker")]
    DayMiniTicker(Box<MiniDayTickerEvent>),
    #[serde(alias = "depthUpdate")]
    DepthOrderBook(Box<DepthOrderBookEvent>),
    #[serde(alias = "outboundAccountPosition")]
    AccountPositionUpdate(Box<AccountPositionUpdate>),
    #[serde(alias = "balanceUpdate")]
    BalanceUpdate(Box<BalanceUpdate>),
    #[serde(alias = "executionReport")]
    OrderUpdate(Box<OrderUpdate>),
    #[serde(alias = "listStatus")]
    ListOrderUpdate(Box<OrderListUpdate>),
    #[serde(alias = "markPriceUpdate")]
    MarkPriceUpdate(Box<MarkPriceEvent>),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct QueryResult {
    pub result: Option<String>,
    pub id: i64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TradesEvent {
    #[serde(rename = "E")]
    pub event_time: u64,

    #[serde(rename = "s")]
    pub symbol: String,

    #[serde(rename = "a")]
    pub aggregated_trade_id: u64,

    #[serde(rename = "p")]
    pub price: String,

    #[serde(rename = "q")]
    pub qty: String,

    #[serde(rename = "f")]
    pub first_break_trade_id: u64,

    #[serde(rename = "l")]
    pub last_break_trade_id: u64,

    #[serde(rename = "T")]
    pub trade_order_time: u64,

    #[serde(rename = "m")]
    pub is_buyer_maker: bool,

    #[serde(skip, rename = "M")]
    pub m_ignore: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TradeEvent {
    #[serde(rename = "E")]
    pub event_time: u64,

    #[serde(rename = "s")]
    pub symbol: String,

    #[serde(rename = "t")]
    pub trade_id: u64,

    #[serde(rename = "p")]
    pub price: String,

    #[serde(rename = "q")]
    pub qty: String,

    #[serde(rename = "T")]
    pub trade_order_time: u64,

    #[serde(rename = "m")]
    pub is_buyer_maker: bool,

    #[serde(skip, rename = "M")]
    pub m_ignore: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct DayTickerEvent {
    #[serde(rename = "E")]
    pub event_time: u64,
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "p")]
    pub price_change: String,
    #[serde(rename = "P")]
    pub price_change_percent: String,
    #[serde(rename = "w")]
    pub average_price: String,
    #[serde(rename = "x")]
    pub prev_close: String,
    #[serde(rename = "c")]
    pub current_close: String,
    #[serde(rename = "Q")]
    pub current_close_qty: String,
    #[serde(rename = "b")]
    pub best_bid: String,
    #[serde(rename = "B")]
    pub best_bid_qty: String,
    #[serde(rename = "a")]
    pub best_ask: String,
    #[serde(rename = "A")]
    pub best_ask_qty: String,
    #[serde(rename = "o")]
    pub open: String,
    #[serde(rename = "h")]
    pub high: String,
    #[serde(rename = "l")]
    pub low: String,
    #[serde(rename = "v")]
    pub volume: String,
    #[serde(rename = "q")]
    pub quote_volume: String,
    #[serde(rename = "O")]
    pub open_time: u64,
    #[serde(rename = "C")]
    pub close_time: u64,
    #[serde(rename = "F")]
    pub first_trade_id: i64,
    #[serde(rename = "L")]
    pub last_trade_id: i64,
    #[serde(rename = "n")]
    pub num_trades: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct MiniDayTickerEvent {
    #[serde(rename = "E")]
    pub event_time: u64,
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "c")]
    pub current_close: String,
    #[serde(rename = "o")]
    pub open: String,
    #[serde(rename = "h")]
    pub high: String,
    #[serde(rename = "l")]
    pub low: String,
    #[serde(rename = "v")]
    pub volume: String,
    #[serde(rename = "q")]
    pub quote_volume: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct KlineEvent {
    #[serde(rename = "E")]
    pub event_time: u64,
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "k")]
    pub kline: Kline,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Kline {
    #[serde(rename = "t")]
    pub start_time: i64,
    #[serde(rename = "T")]
    pub end_time: i64,
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "i")]
    pub interval: String,
    #[serde(rename = "f")]
    pub first_trade_id: i64,
    #[serde(rename = "L")]
    pub last_trade_id: i64,
    #[serde(with = "string_or_float")]
    #[serde(rename = "o")]
    pub open: f64,
    #[serde(with = "string_or_float")]
    #[serde(rename = "c")]
    pub close: f64,
    #[serde(with = "string_or_float")]
    #[serde(rename = "h")]
    pub high: f64,
    #[serde(with = "string_or_float")]
    #[serde(rename = "l")]
    pub low: f64,
    #[serde(with = "string_or_float")]
    #[serde(rename = "v")]
    pub volume: f64,
    #[serde(rename = "n")]
    pub number_of_trades: i64,
    #[serde(rename = "x")]
    pub is_final_bar: bool,
    #[serde(with = "string_or_float")]
    #[serde(rename = "q")]
    pub quote_volume: f64,
    #[serde(with = "string_or_float")]
    #[serde(rename = "V")]
    pub active_buy_volume: f64,
    #[serde(with = "string_or_float")]
    #[serde(rename = "Q")]
    pub active_volume_buy_quote: f64,
    #[serde(skip, rename = "B")]
    pub ignore_me: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct DepthOrderBookEvent {
    #[serde(rename = "E")]
    pub event_time: u64,
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "U")]
    pub first_update_id: u64,
    #[serde(rename = "u")]
    pub final_update_id: u64,
    #[serde(rename = "b")]
    pub bids: Vec<Bids>,
    #[serde(rename = "a")]
    pub asks: Vec<Asks>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct BookTickerEvent {
    #[serde(rename = "u")]
    pub update_id: u64,

    #[serde(rename = "s")]
    pub symbol: String,

    #[serde(rename = "b", with = "string_or_float")]
    pub best_bid: f64,

    #[serde(rename = "B", with = "string_or_float")]
    pub best_bid_qty: f64,

    #[serde(rename = "a", with = "string_or_float")]
    pub best_ask: f64,

    #[serde(rename = "A", with = "string_or_float")]
    pub best_ask_qty: f64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct MarkPriceEvent {
    #[serde(rename = "E")]
    pub event_time: u64,

    #[serde(rename = "s")]
    pub symbol: String,

    #[serde(rename = "p")]
    pub mark_price: String,

    #[serde(rename = "i")]
    pub index_price: String,

    #[serde(rename = "P")]
    pub estimated_settle_price: String,

    #[serde(rename = "r")]
    pub funding_rate: String,

    #[serde(rename = "T")]
    pub next_funding_time: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CombinedStreamEvent<T> {
    stream: String,
    pub data: T,
}

///
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebsocketEventUntag {
    WebsocketEvent(WebsocketEvent),
    Orderbook(Box<OrderBook>),
    BookTicker(Box<BookTickerEvent>),
}

impl<T> CombinedStreamEvent<T> {
    /// Returns (stream_name, channel)
    pub fn parse_stream(&self) -> (String, String) {
        let mut parsed = self.stream.clone();
        if let Some(0) = parsed.find('!') {
            parsed.remove(0);
        }
        let split = parsed.split_once('@').unwrap_or((&parsed, ""));
        (split.0.to_string(), split.1.to_string())
    }
}

/// User Stream related events

/// Account position update
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AccountPositionUpdate {
    #[serde(alias = "E")]
    pub event_time: u64,

    #[serde(alias = "u")]
    pub last_update_time: u64,

    #[serde(alias = "B")]
    pub balances: Vec<EventBalance>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AccountUpdate {
    #[serde(alias = "E")]
    pub event_time: u64,

    /// Maker commission rate (bips)
    #[serde(alias = "m")]
    maker_commission_rate: u64,
    /// Taker commission rate (bips)
    #[serde(alias = "t")]
    taker_commission_rate: u64,
    /// Buyer commission rate (bips)
    #[serde(alias = "b")]
    buyer_commission_rate: u64,
    /// Seller commission rate (bips)
    #[serde(alias = "s")]
    seller_commission_rate: u64,

    #[serde(alias = "T")]
    can_trade: bool,
    #[serde(alias = "W")]
    can_withdraw: bool,
    #[serde(alias = "D")]
    can_deposit: bool,

    #[serde(alias = "B")]
    pub balances: Vec<EventBalance>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct EventBalance {
    #[serde(rename = "a")]
    pub asset: String,
    #[serde(rename = "f")]
    #[serde(with = "string_or_float")]
    pub free: f64,
    #[serde(rename = "l")]
    #[serde(with = "string_or_float")]
    pub locked: f64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct BalanceUpdate {
    #[serde(alias = "E")]
    pub event_time: u64,

    #[serde(rename = "a")]
    pub asset: String,

    #[serde(rename = "d")]
    #[serde(with = "string_or_float")]
    pub delta: f64,

    #[serde(alias = "T")]
    pub clear_time: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrderUpdate {
    #[serde(rename = "E")]
    pub event_time: u64,
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "c")]
    pub client_order_id: Option<String>,
    #[serde(rename = "S")]
    pub side: OrderSide,
    #[serde(rename = "o")]
    pub order_type: OrderType,
    #[serde(rename = "f")]
    pub time_in_force: TimeInForce,
    #[serde(rename = "q")]
    #[serde(with = "string_or_float")]
    pub qty: f64,
    #[serde(rename = "p")]
    #[serde(with = "string_or_float")]
    pub price: f64,
    #[serde(rename = "P")]
    #[serde(with = "string_or_float")]
    pub stop_price: f64,
    #[serde(rename = "F")]
    #[serde(with = "string_or_float")]
    pub iceberg_qty: f64,
    #[serde(rename = "g")]
    pub order_list_id: i64,
    #[serde(rename = "C")]
    pub origin_client_id: Option<String>,
    #[serde(rename = "x")]
    pub execution_type: ExecutionType,
    #[serde(rename = "X")]
    pub current_order_status: OrderStatus,
    #[serde(rename = "r")]
    pub order_reject_reason: String,
    #[serde(rename = "i")]
    pub order_id: u64,
    #[serde(rename = "l")]
    #[serde(with = "string_or_float")]
    pub qty_last_executed: f64,
    #[serde(rename = "z")]
    #[serde(with = "string_or_float")]
    pub cumulative_filled_qty: f64,
    #[serde(rename = "L")]
    #[serde(with = "string_or_float")]
    pub last_executed_price: f64,
    #[serde(rename = "n")]
    #[serde(with = "string_or_float")]
    pub commission: f64,
    #[serde(rename = "N")]
    pub commission_asset: Option<String>,
    #[serde(rename = "T")]
    pub trade_order_time: u64,
    #[serde(rename = "t")]
    pub trade_id: i64,
    #[serde(skip, rename = "I")]
    pub i_ignore: u64,
    #[serde(rename = "w")]
    pub is_order_on_the_book: bool,
    #[serde(rename = "m")]
    pub is_buyer_maker: bool,
    #[serde(skip, rename = "M")]
    pub m_ignore: bool,
    #[serde(rename = "O")]
    pub order_creation_time: u64,
    #[serde(rename = "Z")]
    #[serde(with = "string_or_float")]
    pub cumulative_quote_asset_transacted_qty: f64,
    /// (i.e. lastPrice * lastQty)
    #[serde(rename = "Y")]
    #[serde(with = "string_or_float")]
    pub last_quote_asset_transacted_qty: f64,
    #[serde(rename = "Q")]
    #[serde(with = "string_or_float")]
    pub quote_order_qty: f64,
}

/// For OCO Events
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrderListUpdate {
    #[serde(rename = "E")]
    pub event_time: u64,
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "g")]
    order_list_id: i64,
    #[serde(rename = "c")]
    contingency_type: String,
    #[serde(rename = "l")]
    list_status_type: String,
    #[serde(rename = "L")]
    list_order_status: String,
    #[serde(rename = "r")]
    list_reject_reason: String,
    #[serde(rename = "C")]
    list_client_order_id: String,
    #[serde(rename = "T")]
    pub transaction_time: u64,
    #[serde(rename = "O")]
    pub objects: Vec<OrderListTransaction>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrderListTransaction {
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "i")]
    pub order_id: i64,
    #[serde(rename = "c")]
    pub client_order_id: String,
}

</document_content>
</document>
</documents>